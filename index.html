<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEWTUBE - Watch & Earn</title>
    <script src="https://telegram.org/js/telegram-web-app.js?56"></script>
    
    <!-- Monetag Ads Library -->
    <script src='//libtl.com/sdk.js' data-zone='9442539' data-sdk='show_9442539'></script>
    <!-- GigaPub Ads SDK -->
    <script src="https://ad.gigapub.tech/script?id=846"></script>
    <!-- Onclicka Rewarded Video SDK -->
    <script src="https://js.onclckvd.com/in-stream-ad-admanager/tma.js"></script>
    <!-- Adexium Ads SDK (New) -->
    <script type="text/javascript" src="https://cdn.tgads.space/assets/js/adexium-widget.min.js"></script>

    <style>
        :root {
            --primary-accent-color: #FF4500; --primary-accent-hover-color: #E03D00; --dark-bg: #000000;
            --card-bg: #1a1a1a; --header-bg: #181818; --text-light: #ffffff; --text-muted: #b3b3b3;
            --border-color: #282828; --success-color: #28a745; --disabled-color: #444;
            --yellow-color: #ffc107;
        }
        body { background-color: var(--dark-bg); color: var(--text-light); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; padding: 60px 0 0; }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }
        .main-header { background-color: var(--header-bg); padding: 10px 15px; border-bottom: 1px solid var(--border-color); position: fixed; top: 0; left: 0; right: 0; z-index: 1000; display: flex; justify-content: space-between; align-items: center; height: 40px; }
        .site-title { font-size: 1.2em; color: var(--primary-accent-color); font-weight: 700; text-transform: uppercase; }
        .header-right { display: flex; align-items: center; gap: 10px; }
        .inbox-container { position: relative; cursor: pointer; }
        #inbox-icon { width: 24px; height: 24px; color: var(--text-light); }
        #inbox-notification-dot { position: absolute; top: -2px; right: -2px; width: 8px; height: 8px; background-color: var(--primary-accent-color); border-radius: 50%; border: 1px solid var(--header-bg); display: none; }
        #inbox-notification-dot.visible { display: block; }
        .balance-display { background-color: #2a2a2a; color: var(--primary-accent-color); padding: 5px 12px; border-radius: 20px; font-weight: bold; font-size: 0.9em; }
        .menu-toggle-button { background: none; border: none; cursor: pointer; padding: 5px; display: flex; flex-direction: column; gap: 4px; }
        .menu-toggle-button .bar { width: 22px; height: 2px; background-color: var(--text-light); border-radius: 2px; }
        .side-menu { position: fixed; top: 0; right: -100%; width: 250px; height: 100%; background-color: var(--header-bg); z-index: 1001; transition: right 0.3s ease-in-out; display: flex; flex-direction: column; }
        .side-menu.is-open { right: 0; }
        .side-menu-header { padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .side-menu-header h3 { margin: 0; } .close-menu-btn { background: none; border: none; font-size: 1.5em; color: var(--text-light); cursor: pointer; }
        .side-menu-nav { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; }
        .side-menu-nav a { display: block; padding: 15px 20px; color: var(--text-muted); text-decoration: none; font-weight: 500; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s, color 0.2s; }
        .side-menu-nav a:hover, .side-menu-nav a.active { background-color: var(--primary-accent-color); color: var(--text-light); }
        .menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: none; }
        .menu-overlay.is-open { display: block; }
        .content-section { display: none; padding-top: 25px; } .content-section.active { display: block; }
        .section-title { font-size: 1.5em; margin-bottom: 20px; padding-bottom: 10px; color: var(--text-light); border-bottom: 2px solid var(--border-color); }
        .search-container { display: flex; gap: 10px; margin-bottom: 20px; }
        .search-container input { flex-grow: 1; padding: 10px; box-sizing: border-box; border-radius: 8px; border: 1px solid var(--border-color); background-color: #000; color: var(--text-light); font-size: 1em; }
        .search-container button { padding: 10px 15px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: var(--text-light); font-weight: bold; cursor: pointer; }
        .search-container button#clearSearchBtn { background-color: #444; }
        .item-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
        .movie-item, .task-card, .ad-task-card { background-color: var(--card-bg); border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; }
        .movie-item { cursor: pointer; transition: transform 0.2s; } .movie-item:hover{ transform: scale(1.03); }
        .thumbnail-container { width: 100%; aspect-ratio: 16/9; background-color: #333; position: relative; }
        .thumbnail-container img { width: 100%; height: 100%; object-fit: cover; }
        .movie-item-info, .task-card-info, .ad-task-card-info { padding: 15px; flex-grow: 1; text-align:center;}
        .movie-item-info h4, .task-card h4, .ad-task-card h4 { margin: 0 0 8px; font-size: 1.1em; line-height: 1.3; }
        .movie-reward, .ad-visits-left { color: var(--success-color); font-weight: bold; font-size: 0.9em; margin: 0; }
        .player-container { width: 100%; aspect-ratio: 16/9; background: #000; }
        .player-container iframe { width: 100%; height: 100%; border: none; }
        .task-card p, .ad-task-card p { margin: 8px 0 15px; color: var(--success-color); font-weight: bold; }
        .task-button, .ad-task-button, .daily-task-button { width: 100%; padding: 12px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; background-color: var(--primary-accent-color); color: var(--text-light); transition: background-color .2s; margin-top: auto; font-size: 1em;}
        .task-button:disabled, .ad-task-button:disabled, .daily-task-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        .card { max-width: 500px; margin: 20px auto; background-color: var(--card-bg); padding: 25px; border-radius: 12px; border: 1px solid var(--border-color); text-align: center; }
        .card-icon { width: 50px; height: 50px; margin: 0 auto 15px; color: var(--primary-accent-color); }
        .card h3 { margin-top: 0; font-size: 1.4em; } .card p { color: var(--text-muted); line-height: 1.6; }
        .form-group { margin-bottom: 15px; text-align: left; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 500; color: var(--text-muted); }
        .form-group input, .form-group select { width: 100%; padding: 12px; box-sizing: border-box; border-radius: 8px; border: 1px solid var(--border-color); background-color: #000; color: var(--text-light); font-size: 1em; }
        .form-button { width: 100%; padding: 12px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: var(--text-light); font-weight: bold; font-size: 1em; cursor: pointer; transition: background-color 0.2s; }
        .form-button:hover:not(:disabled) { background-color: var(--primary-accent-hover-color); }
        .form-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        .referral-link-wrapper { display: flex; gap: 10px; margin-top: 20px; }
        .referral-link-wrapper input { flex-grow: 1; text-align: center; }
        .referral-link-wrapper button { width: auto; flex-shrink: 0; padding: 0 15px; }
        .loader { border: 4px solid var(--border-color); border-top: 4px solid var(--primary-accent-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 50px auto; }
        .history-item, .leaderboard-item { background-color: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .leaderboard-item .rank { font-size: 1.2em; font-weight: bold; color: var(--primary-accent-color); min-width: 30px; text-align: center;}
        .leaderboard-item .info { flex-grow: 1; margin-left: 15px; }
        .leaderboard-item .info strong { color: var(--text-light); }
        .leaderboard-item .info small { color: var(--text-muted); }
        .leaderboard-item .count { font-size: 1.1em; font-weight: bold; color: var(--success-color); }
        .claim-referral-btn { padding: 8px 12px; font-size: 0.9em; width: auto; flex-shrink: 0; }
        .history-item .status-pending { color: var(--yellow-color); } .history-item .status-approved { color: var(--success-color); } .history-item .status-rejected { color: #dc3545; }
        .sub-card { background-color: #222; padding: 20px; border-radius: 10px; margin-bottom: 25px; }
        .info-text { font-size: 0.9em; color: var(--text-muted); margin-top: 10px; }
        .daily-task-card { background-color: var(--card-bg); border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; padding: 15px; flex-direction: row; justify-content: space-between; align-items: center; }
        .daily-task-info { text-align: left; }
        .daily-task-info h4 { margin: 0 0 5px; }
        .daily-task-info p { margin: 0; font-size: 0.9em; color: var(--success-color); }
        .daily-task-button { width: auto; flex-shrink: 0; padding: 10px 20px; font-size: 0.9em; margin-top:0; }
        .success-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .success-modal-overlay.show { display: flex; }
        .success-modal { background-color: var(--card-bg); color: var(--text-light); padding: 30px 40px; border-radius: 15px; text-align: center; transform: scale(0.9); opacity: 0; animation: modal-pop-in 0.3s forwards; }
        .success-modal-icon { width: 70px; height: 70px; border-radius: 50%; background-color: var(--success-color); display: flex; justify-content: center; align-items: center; font-size: 40px; font-weight: bold; color: white; margin: 0 auto 20px; animation: icon-pop-in 0.5s 0.2s backwards; }
        .success-modal h3 { margin: 0 0 10px; font-size: 1.6em; }
        .success-modal p { margin: 0; color: var(--text-muted); font-size: 1em;}
        .inbox-modal { background-color: var(--card-bg); color: var(--text-light); padding: 20px; border-radius: 15px; text-align: left; width: 90%; max-width: 400px; max-height: 80vh; display: flex; flex-direction: column; }
        .inbox-modal h3 { text-align: center; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        #inbox-message-list { overflow-y: auto; flex-grow: 1; margin-bottom: 15px; }
        .inbox-message-item { background-color: #2a2a2a; padding: 12px; border-radius: 8px; margin-bottom: 10px; }
        .inbox-message-item p { margin: 0; line-height: 1.5; }
        .inbox-message-item small { color: var(--text-muted); font-size: 0.8em; }
        #closeInboxBtn { padding: 10px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: white; cursor: pointer; }

        /* --- Game Zone Styles --- */
        .game-selector { display: flex; justify-content: center; margin-bottom: 25px; border-bottom: 2px solid #282828; padding-bottom: 15px; }
        .game-selector button { background-color: transparent; border: 2px solid var(--primary-accent-color); color: var(--primary-accent-color); padding: 10px 20px; margin: 0 5px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; }
        .game-selector button.active, .game-selector button:hover { background-color: var(--primary-accent-color); color: white; }
        .game-container { margin-top: 20px; display: none; }
        .game-container.active { display: block; }
        #math-quiz-container #question { font-size: 1.5rem; font-weight: bold; margin-bottom: 20px; }
        #math-quiz-container .btn-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px; }
        #math-quiz-container .btn { background-color: #333; color: white; border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; font-size: 1.1rem; cursor: pointer; transition: background-color 0.3s, transform 0.2s; }
        #math-quiz-container .btn:hover:not(:disabled) { background-color: #444; transform: translateY(-2px); }
        #math-quiz-container .btn.correct { background-color: var(--success-color); }
        #math-quiz-container .btn.incorrect { background-color: #dc3545; }
        #math-quiz-container .btn:disabled { cursor: not-allowed; opacity: 0.7; }
        #math-quiz-container #controls { display: flex; justify-content: space-between; align-items: center; }
        #math-quiz-container #score-container { font-size: 1.2rem; font-weight: bold; }
        #math-quiz-container #next-btn, #math-quiz-container #play-again-btn { background-color: var(--primary-accent-color); color: white; padding: 10px 20px; font-size: 1rem; border-radius: 5px; border: none; cursor: pointer; }
        #scratch-card-container #attempts-left { font-size: 1.2rem; font-weight: bold; color: var(--primary-accent-color); margin-bottom: 15px; }
        #scratch-card-container #card-area { position: relative; width: 300px; height: 150px; margin: 20px auto; border-radius: 10px; cursor: grabbing; touch-action: none; }
        #scratch-card-container #reward-result { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; font-size: 1.8rem; font-weight: bold; color: var(--primary-accent-color); background: linear-gradient(135deg, #333, #222); border-radius: 10px; }
        #scratch-card-container #scratch-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; border-radius: 10px; }
        #scratch-card-container #new-card-btn { background-color: var(--success-color); color: white; padding: 12px 25px; font-size: 1rem; border-radius: 5px; border: none; cursor: pointer; margin-top: 10px; }
        #scratch-card-container #new-card-btn:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        .hide { display: none; }
        
        /* --- Mining Section Styles --- */
        #mining-content .card { text-align: center; }
        #mining-content h1 { color: var(--primary-accent-color); margin-bottom: 5px; font-size: 2em; }
        #mining-content .subtitle { margin-bottom: 25px; color: var(--text-muted); }
        .mining-dashboard { background-color: #2a2a2a; padding: 20px; border-radius: 15px; margin-bottom: 25px; }
        .mining-balance-display { font-size: 2.2em; font-weight: 700; color: var(--success-color); margin: 5px 0; letter-spacing: 1px; }
        .mining-usdt-value { font-size: 1.1em; color: var(--yellow-color); margin-bottom: 20px; }
        .mining-status { display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 20px; }
        .mining-status-dot { width: 12px; height: 12px; border-radius: 50%; background-color: #dc3545; }
        .mining-status-dot.active { background-color: var(--success-color); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); } 100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); } }
        .mining-session-timer { font-size: 1.5em; font-weight: bold; color: var(--text-light); margin-bottom: 10px; }
        .mining-progress-bar-container { width: 100%; background-color: #444; border-radius: 5px; height: 10px; margin-bottom: 20px; }
        .mining-progress-bar { width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary-accent-color), var(--primary-accent-hover-color)); border-radius: 5px; transition: width 1s linear; }
        #mining-button { width: 100%; background-color: var(--primary-accent-color); color: #fff; border: none; padding: 15px; border-radius: 10px; font-size: 1.2em; cursor: pointer; transition: background-color 0.3s, transform 0.2s; font-weight: bold; }
        #mining-button:hover:not(:disabled) { background-color: var(--primary-accent-hover-color); transform: scale(1.02); }
        #mining-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }


        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes modal-pop-in { to { transform: scale(1); opacity: 1; } }
        @keyframes icon-pop-in { 0% { transform: scale(0); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <header class="main-header">
        <h1 class="site-title">NEWTUBE</h1>
        <div class="header-right">
             <div class="inbox-container" id="inbox-container">
                <svg id="inbox-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4-8 5-8-5V6l8 5 8-5v2z"/></svg>
                <span id="inbox-notification-dot"></span>
            </div>
            <div class="balance-display">PG: <span id="userPGBalanceDisplay">0.0000</span></div>
            <div class="balance-display">$: <span id="userUSDTBalanceDisplay">0.00</span></div>
            <div class="balance-display">Pts: <span id="userBalanceDisplay">0</span></div>
            <button class="menu-toggle-button" id="menu-toggle-button"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>
        </div>
    </header>

    <div class="menu-overlay" id="menu-overlay"></div>
    <aside class="side-menu" id="side-menu">
        <div class="side-menu-header"><h3>Menu</h3><button class="close-menu-btn" id="close-menu-btn">&times;</button></div>
        <ul class="side-menu-nav">
            <li><a href="#" class="nav-link active" data-tab-target="#home-content">Home</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#mining-content">Mining</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#ads-to-earn-content">Ads to Earn</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#task-content">Task to Earn</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#game-zone-content">Game Zone</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#referral-content">Referral Program</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#leaderboard-content">Leaderboard</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#withdraw-content">Withdraw</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#history-content">History</a></li>
        </ul>
    </aside>

    <main class="container">
        <section id="home-content" class="content-section active">
            <h3 class="section-title">Trending Videos</h3>
            <div class="search-container">
                <input type="search" id="videoSearchInput" placeholder="Search for videos...">
                <button id="videoSearchBtn">Search</button>
                <button id="clearSearchBtn" style="display:none;">Clear</button>
            </div>
            <div class="item-grid" id="video-grid"></div>
        </section>

        <section id="mining-content" class="content-section">
            <h3 class="section-title">PG Coin Mining</h3>
            <div class="card">
                <h1>Pg Coin Mining</h1>
                <p class="subtitle">Start your session every 4 hours to keep earning.</p>
        
                <div class="mining-dashboard">
                    <div class="mining-status">
                        <div id="mining-status-dot" class="mining-status-dot"></div>
                        <span id="mining-status-text">Inactive</span>
                    </div>
                    <h3>Your PG Balance</h3>
                    <div id="pg-balance" class="mining-balance-display">0.00000000 PG</div>
                    <div id="mining-usdt-value" class="mining-usdt-value">($0.00 USDT)</div>
        
                    <div id="mining-session-timer" class="mining-session-timer">04:00:00</div>
                    <div class="mining-progress-bar-container">
                        <div id="mining-progress-bar" class="mining-progress-bar"></div>
                    </div>
        
                    <button id="mining-button">Start 4H Session</button>
                </div>
                <p class="info-text">Hash Power: 2 GH/s (Fixed)</p>
                <p class="info-text">Total Daily Earning Potential: 0.5 PG</p>
            </div>
        </section>

        <section id="ads-to-earn-content" class="content-section">
             <h3 class="section-title">Watch Ads, Earn Points</h3>
             <div id="ad-task-list" class="item-grid"></div>
        </section>
        
        <section id="task-content" class="content-section">
             <h3 class="section-title">Daily Rewards</h3>
             <div id="daily-task-list" class="item-grid" style="grid-template-columns: 1fr; margin-bottom: 40px;"></div>
             <h3 class="section-title">Complete Tasks</h3>
             <div id="task-list" class="item-grid"></div>
        </section>

        <section id="game-zone-content" class="content-section">
            <h3 class="section-title">Game Zone</h3>
             <div class="card" style="padding: 15px 15px 25px 15px;">
                <div class="game-selector">
                    <button id="select-math-quiz" class="active">Math Quiz</button>
                    <button id="select-scratch-card">Scratch & Win</button>
                </div>
                <div id="math-quiz-container" class="game-container active">
                    <h1 style="font-size: 1.5rem;">Math Quiz</h1>
                    <p id="math-attempts-left" style="color: var(--text-muted); font-weight: bold;"></p>
                    <div id="quiz">
                        <div id="question-container"><div id="question">Question will be shown here</div></div>
                        <div id="answer-buttons" class="btn-grid"></div>
                        <div id="controls">
                            <div id="score-container">Score: 0</div>
                            <button id="next-btn" class="hide">Next Question</button>
                        </div>
                    </div>
                    <div id="math-results-container" class="hide">
                        <h2 id="final-score"></h2>
                        <button id="play-again-btn">Play Again</button>
                    </div>
                </div>
                <div id="scratch-card-container" class="game-container">
                    <h1 style="font-size: 1.5rem;">Scratch & Win</h1>
                    <p id="attempts-left">Attempts left: 10</p>
                    <div id="card-area">
                        <div id="reward-result"></div>
                        <canvas id="scratch-canvas" width="300" height="150"></canvas>
                    </div>
                    <button id="new-card-btn" class="hide">Get New Card</button>
                </div>
            </div>
        </section>

        <section id="referral-content" class="content-section">
            <div class="card">
                <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                <h3>Referral Program</h3>
                <p>Invite friends with your unique link. When your friend earns 500 points by working, you will receive a bonus of <strong>1000 Points!</strong></p>
                <div class="referral-link-wrapper"><input type="text" id="referralLinkInput" readonly value="Generating link..."><button id="copyReferralLinkBtn" class="form-button">Copy</button></div>
            </div>
        </section>
        <section id="leaderboard-content" class="content-section">
            <h3 class="section-title">Top Referrers</h3>
            <div class="card" style="text-align: left; padding-bottom: 10px;">
                <p style="text-align: center;">Here are the top users who have invited the most friends. The weekly top referrer gets an extra bonus!</p>
                <div id="leaderboard-list"></div>
            </div>
            <h3 class="section-title" style="margin-top: 40px;">Your Referrals</h3>
            <div class="card" style="text-align: left;">
                <p style="text-align: center;">Track the progress of the friends you've invited.</p>
                <div id="my-referrals-list"></div>
            </div>
        </section>
        
        <section id="withdraw-content" class="content-section">
             <div class="card">
                 <h3 class="section-title" style="border: none; margin-bottom: 5px; text-align: center;">Withdraw PG Coin</h3>
                 <div class="sub-card">
                     <h4>Withdraw your PG Coin</h4>
                     <p>Your PG Balance: <strong id="withdrawPgBalance">0.0000</strong></p>
                     
                     <div id="withdrawalRequirements" class="info-text" style="text-align: left; margin-bottom: 15px; padding: 10px; border: 1px solid var(--border-color); border-radius: 8px;">
                         <div id="pgCoinCheck">Requirement: 5 PG</div>
                         <div id="referralCheck">Requirement: 2 Referrals</div>
                     </div>

                     <form id="withdrawalForm">
                         <div class="form-group">
                            <label for="withdrawalMethod">Payment Method</label>
                            <select id="withdrawalMethod" required><option value="Bkash">Bkash</option><option value="Binance (Optimism)">Binance (Optimism)</option></select>
                         </div>
                         <div class="form-group">
                            <label for="accountDetails">Account Details</label>
                            <input type="text" id="accountDetails" placeholder="Your Bkash Number or Binance Address" required>
                         </div>
                         <div class="form-group">
                            <label for="withdrawalAmount">Amount (PG)</label>
                            <input type="number" id="withdrawalAmount" placeholder="e.g., 5.5" required step="0.0001">
                         </div>
                         <p class="info-text">Note: Your PG will be converted to USDT at the current rate upon payment.</p>
                         <button type="submit" class="form-button" id="requestWithdrawalBtn" disabled>Request Withdrawal</button>
                     </form>
                 </div>
             </div>
        </section>

        <section id="history-content" class="content-section"><h3 class="section-title">Withdrawal History</h3><div id="history-list"></div></section>
        
    </main>
    
    <div id="successModalOverlay" class="success-modal-overlay"><div class="success-modal"><div class="success-modal-icon">✓</div><h3 id="successModalTitle">Success!</h3><p id="successModalMessage">Your request has been sent.</p></div></div>
    
    <div id="inboxModalOverlay" class="success-modal-overlay">
        <div class="inbox-modal"><h3>Inbox</h3><div id="inbox-message-list"><div class="loader"></div></div><button id="closeInboxBtn" class="form-button" style="margin-top: 15px;">Close</button></div>
    </div>
    
    <script src="https://www.youtube.com/iframe_api" async></script>
    
    <!-- ** UPDATED: New Adexium Initialization Script ** -->
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', () => {
            const showAdexiumAd = () => {
                if (typeof AdexiumWidget !== 'undefined') {
                    console.log("Showing Adexium Ad...");
                    try {
                        new AdexiumWidget({wid: '165512cc-372e-4fb0-98d2-552219c72799', adFormat: 'interstitial'}).init();
                    } catch(e) {
                        console.error("Adexium widget initialization failed:", e);
                    }
                } else {
                    console.error("AdexiumWidget SDK not loaded.");
                }
            };
            
            // First ad after 45 seconds
            setTimeout(showAdexiumAd, 45000); 
            // Subsequent ads every 5 minutes
            setInterval(showAdexiumAd, 300000); 
        });
    </script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, orderBy, limit, addDoc, serverTimestamp, doc, getDoc, setDoc, updateDoc, runTransaction, increment, arrayUnion } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCKMa4NdIowD_8NioUbrn4L7g5M9y5Tts0",
            authDomain: "movie-zone-931d7.firebaseapp.com",
            projectId: "movie-zone-931d7",
            storageBucket: "movie-zone-931d7.appspot.com",
            messagingSenderId: "1006880112063",
            appId: "1:1006880112063:web:4a4cf5079ea365a6ce750a",
            measurementId: "G-TH1YSE4D9C"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const tg = window.Telegram.WebApp;

        let currentUser = null;
        let player;
        let currentPlayingItem = null;
        let videoPlaybackInterval = null;
        let dailyTimerInterval = null;
        let miningTimerInterval = null;
        let timeSpentThisSession = 0; // in seconds
        let gamePlayCounter = 0;
        let accumulatedWatchTime = 0;

        const AD_VISIT_LIMIT = 40; 
        const VIDEO_WATCH_LIMIT = 30;
        const GAME_AD_TRIGGER_COUNT = 3;
        const REFERRAL_POINTS_THRESHOLD = 500;
        const REFERRAL_BONUS_AMOUNT = 1000;

        // Mining Config
        const MINING_SESSION_DURATION = 4 * 60 * 60 * 1000; // 4 hours
        const MINING_REWARD_PER_SESSION = 0.5 / 6; // 0.5 PG per 24h = 0.5/6 per 4h
        const PG_TO_USDT_RATE = 0.02;

        // Withdrawal Config
        const MIN_PG_TO_WITHDRAW = 5;
        const MIN_REFERRALS_TO_WITHDRAW = 2;
        
        const dailyTasksConfig = [
            { id: 'visit_channel', title: 'Visit Telegram Channel', reward: 10, type: 'action', url: 'https://t.me/newtube12' },
            { id: 'stay_5m', title: 'Stay for 5 minutes', reward: 10, type: 'time', requirement: 300 },
            { id: 'stay_15m', title: 'Stay for 15 minutes', reward: 20, type: 'time', requirement: 900 },
            { id: 'stay_30m', title: 'Stay for 30 minutes', reward: 35, type: 'time', requirement: 1800 },
            { id: 'stay_45m', title: 'Stay for 45 minutes', reward: 50, type: 'time', requirement: 2700 },
            { id: 'stay_1h', title: 'Stay for 1 hour', reward: 70, type: 'time', requirement: 3600 }
        ];

        async function fetchAndUpdateCurrentUser() {
            if (!currentUser?.id) return;
            try {
                const userRef = doc(db, 'users', currentUser.id);
                const userSnap = await getDoc(userRef);
                if (userSnap.exists()) {
                    currentUser = { id: userSnap.id, ...userSnap.data() };
                    updateBalanceUI(currentUser.balance, currentUser.usdtBalance, currentUser.pgBalance);
                }
            } catch (error) { console.error("Error fetching current user:", error); }
        }
        
        async function checkAndResetDailies() {
            if (!currentUser) return;
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            let updates = {};

            const lastAdVisitDate = currentUser.lastAdVisitDate?.toDate();
            const lastAdVisitTime = lastAdVisitDate ? new Date(lastAdVisitDate.getFullYear(), lastAdVisitDate.getMonth(), lastAdVisitDate.getDate()).getTime() : 0;
            if (lastAdVisitTime < today) {
                updates.adVisitsToday = 0;
            }

            const lastDailyReset = currentUser.dailyTasks?.lastReset?.toDate();
            const lastDailyResetTime = lastDailyReset ? new Date(lastDailyReset.getFullYear(), lastDailyReset.getMonth(), lastDailyReset.getDate()).getTime() : 0;
            if (!lastDailyReset || lastDailyResetTime < today) {
                updates['dailyTasks.claimed'] = [];
                updates['dailyTasks.timeSpent'] = 0;
                updates['dailyTasks.lastReset'] = serverTimestamp();
            }

            const lastGameReset = currentUser.dailyGamePlays?.lastReset?.toDate();
            const lastGameResetTime = lastGameReset ? new Date(lastGameReset.getFullYear(), lastGameReset.getMonth(), lastGameReset.getDate()).getTime() : 0;
            if (!lastGameReset || lastGameResetTime < today) {
                updates['dailyGamePlays.math'] = 0;
                updates['dailyGamePlays.scratch'] = 0;
                updates['dailyGamePlays.lastReset'] = serverTimestamp();
            }

            if (!currentUser.videoProgress) {
                updates.videoProgress = {};
            } else {
                const lastVideoReset = currentUser.videoProgress.lastReset?.toDate();
                const lastVideoResetTime = lastVideoReset ? new Date(lastVideoReset.getFullYear(), lastVideoReset.getMonth(), lastVideoReset.getDate()).getTime() : 0;
                if(lastVideoResetTime < today) {
                    updates['videoProgress.dailyWatchedCount'] = 0;
                }
            }

            if (Object.keys(updates).length > 0) {
                try {
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, updates);
                    await fetchAndUpdateCurrentUser(); 
                } catch (error) { console.error("Error resetting daily limits:", error); }
            }
        }

        async function initializeUser(tgUser, referrerCode) {
            const userId = String(tgUser.id);
            const userRef = doc(db, 'users', userId);
            let userSnap = await getDoc(userRef);

            const fieldsToEnsure = {
                balance: 0, usdtBalance: 0, pgBalance: 0, lifetimePointsEarned: 0,
                referralCount: 0, completedTasks: [], adVisitsToday: 0, 
                dailyTasks: { claimed: [], timeSpent: 0, lastReset: serverTimestamp() },
                dailyGamePlays: { math: 0, scratch: 0, lastReset: serverTimestamp() },
                videoProgress: { dailyWatchedCount: 0, lastReset: serverTimestamp() },
                readMessages: [],
                miningSessionEndTime: null, withdrawalCount: 0
            };
            
            if (!userSnap.exists()) {
                const defaultUserData = {
                    ...fieldsToEnsure,
                    createdAt: serverTimestamp(),
                    telegramUsername: tgUser.username || 'N/A',
                };
                if (referrerCode && referrerCode !== userId) {
                    defaultUserData.referredBy = referrerCode;
                }
                await setDoc(userRef, defaultUserData);

                if (referrerCode && referrerCode !== userId) {
                    try {
                        const referrerRef = doc(db, 'users', referrerCode);
                        const referrerSnap = await getDoc(referrerRef);
                        if (referrerSnap.exists()) {
                            await updateDoc(referrerRef, { referralCount: increment(1) });
                        }
                    } catch (e) { console.error("Could not update referrer count", e); }
                }
                userSnap = await getDoc(userRef);
            }
            
            let userData = userSnap.data();
            let updatesForOldUsers = {};

            if (!userData.referredBy && referrerCode && referrerCode !== userId) {
                 try {
                    const referrerRef = doc(db, 'users', referrerCode);
                    const referrerSnap = await getDoc(referrerRef);
                    if (referrerSnap.exists()) {
                        updatesForOldUsers.referredBy = referrerCode;
                        await updateDoc(referrerRef, { referralCount: increment(1) });
                    }
                } catch(e) { console.error("Could not update referrer count for existing user", e); }
            }
            
            for (const key in fieldsToEnsure) {
                if (!userData.hasOwnProperty(key)) {
                    updatesForOldUsers[key] = fieldsToEnsure[key];
                }
            }
            if (!userData.dailyTasks) updatesForOldUsers.dailyTasks = fieldsToEnsure.dailyTasks;
            if (!userData.dailyGamePlays) updatesForOldUsers.dailyGamePlays = fieldsToEnsure.dailyGamePlays;
            if (!Array.isArray(userData.completedTasks)) updatesForOldUsers.completedTasks = [];
            if (!userData.videoProgress?.dailyWatchedCount) updatesForOldUsers['videoProgress.dailyWatchedCount'] = 0;
            if (!userData.videoProgress?.lastReset) updatesForOldUsers['videoProgress.lastReset'] = serverTimestamp();
            if (!Array.isArray(userData.readMessages)) updatesForOldUsers.readMessages = [];
            if (!userData.hasOwnProperty('referralBonusPaidOut')) updatesForOldUsers.referralBonusPaidOut = false;
            
            if (userData.telegramUsername !== (tgUser.username || 'N/A')) {
                updatesForOldUsers.telegramUsername = tgUser.username || 'N/A';
            }
            if (Object.keys(updatesForOldUsers).length > 0) {
                await updateDoc(userRef, updatesForOldUsers).catch(err => console.error("Error updating old user fields:", err));
            }

            const finalUserSnap = await getDoc(userRef);
            currentUser = { id: finalUserSnap.id, ...finalUserSnap.data() };
            
            await checkAndResetDailies();

            updateBalanceUI(currentUser.balance, currentUser.usdtBalance, currentUser.pgBalance);
            generateReferralLink(currentUser.id);
            checkForUnreadMessages();
            startDailyTimer();
        }
        
        function formatPoints(num) {
            const n = Math.floor(num || 0);
            if (n >= 1000000) return `${(n / 1000000).toFixed(1).replace(/\.0$/, '')}M`;
            if (n >= 10000) return `${(n / 1000).toFixed(1).replace(/\.0$/, '')}K`;
            return n;
        }

        function updateBalanceUI(balance, usdtBalance, pgBalance) {
            const points = formatPoints(balance);
            const usdt = parseFloat(usdtBalance || 0).toFixed(2);
            const pg = parseFloat(pgBalance || 0).toFixed(4);
            document.getElementById('userBalanceDisplay').textContent = points;
            document.getElementById('userUSDTBalanceDisplay').textContent = usdt;
            document.getElementById('userPGBalanceDisplay').textContent = pg;
        }

        function generateReferralLink(userId) {
            const botUsername = "NewTube12_bot";
            const webAppShortName = "newtubecash";
            const referralLink = `https://t.me/${botUsername}/${webAppShortName}?startapp=${userId}`;
            document.getElementById('referralLinkInput').value = referralLink;
        }
        
        document.getElementById('copyReferralLinkBtn').addEventListener('click', () => {
            const copyButton = document.getElementById('copyReferralLinkBtn');
            navigator.clipboard.writeText(copyButton.previousElementSibling.value).then(() => {
                copyButton.textContent = 'Copied!';
                if (tg && tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
            });
        });

        async function grantPoints(amount, source) {
            if (!currentUser || amount <= 0) return;
            const userRef = doc(db, 'users', currentUser.id);
            await updateDoc(userRef, {
                balance: increment(amount),
                lifetimePointsEarned: increment(amount)
            });
            await fetchAndUpdateCurrentUser();
        }

        async function grantPGReward(amount, source) {
            if (!currentUser || amount <= 0) return;
            const userRef = doc(db, 'users', currentUser.id);
            await updateDoc(userRef, {
                pgBalance: increment(amount)
            });
            await fetchAndUpdateCurrentUser();
        }
        
        async function renderVideos(snapshot) {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = ''; 
            if (snapshot.empty) {
                grid.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No videos found.</p>';
                return;
            }
            snapshot.docs.forEach((docSnap) => {
                const video = docSnap.data();
                const item = document.createElement('article');
                item.className = 'movie-item';
                item.dataset.youtubeId = video.youtubeId;
                item.dataset.videoId = docSnap.id;
                
                item.originalContent = `
                    <div class="thumbnail-container">
                        <img src="${video.thumbnailUrl}" alt="${video.title}" loading="lazy">
                    </div>
                    <div class="movie-item-info">
                        <h4>${video.title}</h4>
                        <p class="movie-reward">Watch to Earn Points</p>
                    </div>`;
                item.innerHTML = item.originalContent;
                item.addEventListener('click', handleVideoClick);
                grid.appendChild(item);
            });
        }

        async function fetchContent() {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = '<div class="loader"></div>';
            try {
                const videosCollection = collection(db, 'videos');
                const q = query(videosCollection, orderBy('createdAt', 'desc'), limit(VIDEO_WATCH_LIMIT));
                const snapshot = await getDocs(q);
                await renderVideos(snapshot);
            } catch (error) { 
                console.error("Error fetching content:", error); 
                grid.innerHTML = '<p style="grid-column: 1 / -1;">Error loading content.</p>'; 
            }
        }
        
        async function searchVideos(searchTerm) { /* ... unchanged ... */ }

        async function handleVideoClick(event) {
            if (!currentUser) { alert("User data not loaded yet."); return; }

            const dailyWatchedCount = currentUser.videoProgress?.dailyWatchedCount || 0;
            if(dailyWatchedCount >= VIDEO_WATCH_LIMIT){
                alert(`You have reached your daily video watch limit of ${VIDEO_WATCH_LIMIT}.`);
                return;
            }

            if (currentPlayingItem) {
                clearInterval(videoPlaybackInterval);
                const originalContent = currentPlayingItem.originalContent;
                if(originalContent) currentPlayingItem.innerHTML = originalContent;
                if (player) { player.destroy(); player = null; }
            }
            const clickedItem = event.currentTarget;
            if (currentPlayingItem === clickedItem) {
                currentPlayingItem = null;
                return;
            }
            currentPlayingItem = clickedItem;
            const { youtubeId, videoId } = clickedItem.dataset;
            const playerDivId = `player-${youtubeId}-${Date.now()}`;
            
            clickedItem.innerHTML = `<div id="${playerDivId}" class="player-container"></div>`;
            
            accumulatedWatchTime = 0;

            player = new YT.Player(playerDivId, {
                height: '100%', width: '100%', videoId: youtubeId,
                playerVars: { 'autoplay': 1, 'controls': 1, 'rel': 0, 'fs': 1 },
                events: {
                    'onReady': (e) => { e.target.playVideo(); startVideoMonitoring(videoId); },
                    'onStateChange': (e) => {
                         if (e.data === YT.PlayerState.PLAYING) {
                            startVideoMonitoring(videoId);
                        } else {
                            clearInterval(videoPlaybackInterval);
                        }
                    }
                }
            });
        }
        
        function startVideoMonitoring(videoId) {
            clearInterval(videoPlaybackInterval);
            videoPlaybackInterval = setInterval(() => {
                if (player && player.getPlayerState() === YT.PlayerState.PLAYING) {
                    accumulatedWatchTime += 2;
                    
                    if (accumulatedWatchTime >= 300) { // 5 minutes
                        clearInterval(videoPlaybackInterval);
                        processFiveMinuteReward(videoId);
                        accumulatedWatchTime = 0;
                    }
                }
            }, 2000);
        }
        
        async function processFiveMinuteReward(videoId) {
            console.log("5 minutes watched. Processing reward...");
            const pointsToGrant = Math.floor(Math.random() * (40 - 5 + 1)) + 5;
            
            const userRef = doc(db, 'users', currentUser.id);

            const grantAndContinue = async () => {
                await grantPoints(pointsToGrant, 'video');
                await updateDoc(userRef, { 
                    [`videoProgress.${videoId}.watchedIntervals`]: increment(1),
                    'videoProgress.dailyWatchedCount': increment(1),
                    'videoProgress.lastReset': serverTimestamp()
                });

                showSuccessModal("Reward!", `You earned ${pointsToGrant} points for watching.`);
                startVideoMonitoring(videoId);
            };

            const userSnap = await getDoc(userRef);
            const videoData = userSnap.data().videoProgress?.[videoId] || { watchedIntervals: 0 };
            const intervalsWatched = videoData.watchedIntervals;

            if (intervalsWatched > 0 && intervalsWatched % 2 !== 0) {
                console.log("Showing ad before video reward...");
                try {
                    await showRandomAdForGames();
                    console.log("Ad watched successfully.");
                    await grantAndContinue();
                } catch (err) {
                    console.log("Ad failed or was closed.", err);
                    alert("You must watch the ad to get your reward.");
                    startVideoMonitoring(videoId);
                }
            } else {
                await grantAndContinue();
            }
        }
        
        function stopAndClearVideo() {
            clearInterval(videoPlaybackInterval);
            if (currentPlayingItem) {
                const originalContent = currentPlayingItem.originalContent;
                if(originalContent) currentPlayingItem.innerHTML = originalContent;
            }
            if (player) {
                try { player.destroy(); } catch (e) { console.error(e); }
                player = null;
            }
            currentPlayingItem = null;
            videoPlaybackInterval = null;
        }

        function setupAdsToEarn() {
            const adTaskListContainer = document.getElementById('ad-task-list');
            adTaskListContainer.innerHTML = '';
            const visitsToday = currentUser.adVisitsToday || 0;
            const visitsLeft = AD_VISIT_LIMIT - visitsToday;
            const isLimitReached = visitsLeft <= 0;
            const buttonCount = 2;

            for(let i=1; i <= buttonCount; i++) {
                const card = document.createElement('div');
                card.className = 'ad-task-card';
                card.innerHTML = `<div class="ad-task-card-info"><h4>Watch Ad & Earn</h4><p>Reward: 50 Points</p><p class="ad-visits-left">Today's Visits Left: ${visitsLeft > 0 ? visitsLeft : 0} / ${AD_VISIT_LIMIT}</p></div><button class="ad-task-button" ${isLimitReached ? 'disabled' : ''}>${isLimitReached ? 'Daily Limit Reached' : 'Watch Ad'}</button>`;
                adTaskListContainer.appendChild(card);
            }
        }
        
        document.getElementById('ad-task-list').addEventListener('click', async (e) => {
            if (!e.target.matches('.ad-task-button') || e.target.disabled) return;
            
            const button = e.target;
            button.disabled = true;
            button.textContent = 'Loading Ad...';

            const grantAdReward = async () => {
                if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                try {
                    await grantPoints(50, 'ad');
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, {
                        adVisitsToday: increment(1),
                        lastAdVisitDate: serverTimestamp()
                    });
                    await fetchAndUpdateCurrentUser();
                    setupAdsToEarn(); 
                    showSuccessModal("Congratulations!", "You've earned 50 points.");
                } catch (error) {
                    console.error("Ad task reward error:", error);
                    setupAdsToEarn();
                }
            };
            
            const showMonetagAd = () => new Promise((res, rej) => typeof show_9442539 === 'function' ? show_9442539().then(res).catch(rej) : rej('Monetag SDK missing'));
            const showGigaPubAd = () => new Promise((res, rej) => typeof window.showGiga === 'function' ? window.showGiga("main").then(res).catch(rej) : rej('GigaPub SDK missing'));
            const showOnclickaVideoAd = () => new Promise((res, rej) => {
                if (window.showOnclickaVideoFunc) {
                    window.showOnclickaVideoFunc().then(res).catch(rej);
                } else {
                    rej('Onclicka Video function not available.');
                }
            });

            const adNetworks = [showMonetagAd, showGigaPubAd, showOnclickaVideoAd];
            const randomAdFunction = adNetworks[Math.floor(Math.random() * adNetworks.length)];

            try {
                console.log(`Attempting to show ad from: ${randomAdFunction.name}`);
                await randomAdFunction();
                await grantAdReward();
            } catch (err) {
                console.log('Ad not shown or completed:', err);
                alert('You need to watch the complete ad to earn points.');
                setupAdsToEarn();
            }
        });

        async function fetchTasks() {
            const taskListContainer = document.getElementById('task-list');
            taskListContainer.innerHTML = '<div class="loader"></div>';
            try {
                const tasksRef = collection(db, 'tasks');
                const snapshot = await getDocs(query(tasksRef, orderBy("createdAt", "desc")));
                taskListContainer.innerHTML = '';
                if (snapshot.empty) {
                    taskListContainer.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No tasks available right now. Check back later!</p>'; return;
                }
                snapshot.forEach(docSnap => {
                    const task = docSnap.data();
                    const taskId = docSnap.id;
                    const card = document.createElement('div');
                    card.className = 'task-card';
                    const isCompleted = currentUser.completedTasks?.includes(taskId);
                    const completionCount = task.completionCount || 0;
                    const taskLimit = task.limit || 0;
                    const isLimitReached = (taskLimit > 0) && (completionCount >= taskLimit);
                    let buttonText = 'Start Task'; let buttonDisabled = false; let buttonState = 'start';
                    if (isCompleted) { buttonText = 'Done'; buttonDisabled = true; buttonState = 'done'; }
                    else if (isLimitReached) { buttonText = 'Limit Reached'; buttonDisabled = true; buttonState = 'limit_reached'; }
                    card.innerHTML = `
                        <div class="task-card-info">
                            <h4>${task.title}</h4>
                            <p>Reward: ${task.reward} Points</p>
                        </div>
                        <button class="task-button" data-task-id="${taskId}" data-task-url="${task.url}" data-reward="${task.reward}" data-visit-duration="${task.visitDurationSeconds || 0}" data-state="${buttonState}" ${buttonDisabled ? 'disabled' : ''}>
                            ${buttonText}
                        </button>`;
                    taskListContainer.appendChild(card);
                });
            } catch (error) {
                console.error("Error fetching tasks:", error);
                taskListContainer.innerHTML = '<p style="color:red; text-align:center; grid-column: 1 / -1;">Could not load tasks. Please try again later.</p>';
            }
        }
        
        document.getElementById('task-list').addEventListener('click', async (e) => {
            if (!e.target.matches('.task-button') || e.target.disabled) return;
            const button = e.target;
            const { taskId, taskUrl, reward, state } = button.dataset;
            const visitDuration = parseInt(button.dataset.visitDuration, 10);
            if (state === 'start') {
                if (!taskUrl) { alert('Task URL is missing.'); return; }
                tg.openLink(taskUrl);
                if (visitDuration > 0) {
                    button.disabled = true; let countdown = visitDuration;
                    const intervalId = setInterval(() => {
                        countdown--; button.textContent = `Wait ${countdown}s...`;
                        if (countdown <= 0) {
                            clearInterval(intervalId); button.disabled = false;
                            button.textContent = 'Claim Reward'; button.dataset.state = 'claim';
                            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('warning');
                        }
                    }, 1000);
                } else {
                    button.textContent = 'Claim Reward'; button.dataset.state = 'claim';
                    if (tg.HapticFeedback) tg.HapticFeedback.impactOccurred('light');
                }
            } else if (state === 'claim') {
                button.disabled = true; button.textContent = 'Verifying...';
                try {
                    await runTransaction(db, async (transaction) => {
                        const userRef = doc(db, 'users', currentUser.id);
                        const taskRef = doc(db, 'tasks', taskId);
                        const userDoc = await transaction.get(userRef);
                        const taskDoc = await transaction.get(taskRef);
                        if (!userDoc.exists() || !taskDoc.exists()) throw "USER_OR_TASK_NOT_FOUND";
                        const userData = userDoc.data();
                        const taskData = taskDoc.data();
                        if (userData.completedTasks?.includes(taskId)) throw "ALREADY_COMPLETED";
                        const completionCount = taskData.completionCount || 0;
                        const taskLimit = taskData.limit || 0;
                        if ((taskLimit > 0) && (completionCount >= taskLimit)) throw "TASK_LIMIT_REACHED";
                        
                        transaction.update(userRef, { 
                            completedTasks: arrayUnion(taskId) 
                        });
                        transaction.update(taskRef, { completionCount: increment(1) });
                    });
                    
                    await grantPoints(Number(reward), 'task');
                    
                    showSuccessModal("Reward Claimed!", `${reward} points have been added to your balance.`);
                    if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                    button.textContent = 'Done';
                } catch (error) {
                    const errorMessages = { "ALREADY_COMPLETED": "You have already completed this task.", "TASK_LIMIT_REACHED": "This task has reached its completion limit.", "USER_OR_TASK_NOT_FOUND": "Task not found. It might have been removed."};
                    const message = errorMessages[error] || 'Failed to claim reward. Please try again.';
                    alert(message);
                    button.textContent = (error === "ALREADY_COMPLETED" || error === "TASK_LIMIT_REACHED") ? 'Done' : 'Claim Reward';
                    button.disabled = (error !== 'Failed to claim reward. Please try again.');
                }
            }
        });

        function showSuccessModal(title, message) {
            const modal = document.getElementById('successModalOverlay');
            document.getElementById('successModalTitle').textContent = title;
            document.getElementById('successModalMessage').textContent = message;
            modal.classList.add('show');
            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
            setTimeout(() => { modal.classList.remove('show'); }, 3000);
        }
        
        // --- MINING LOGIC ---
        const miningApp = {
            DOMElements: {
                balance: document.getElementById('pg-balance'),
                usdtValue: document.getElementById('mining-usdt-value'),
                miningButton: document.getElementById('mining-button'),
                statusDot: document.getElementById('mining-status-dot'),
                statusText: document.getElementById('mining-status-text'),
                sessionTimer: document.getElementById('mining-session-timer'),
                progressBar: document.getElementById('mining-progress-bar'),
            },

            formatTime(ms) {
                if (ms < 0) ms = 0;
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
                const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
                const seconds = (totalSeconds % 60).toString().padStart(2, '0');
                return `${hours}:${minutes}:${seconds}`;
            },

            updateUI() {
                if (!currentUser) return;
                if (miningTimerInterval) clearInterval(miningTimerInterval);

                const { DOMElements } = this;
                const pgBalance = currentUser.pgBalance || 0;
                DOMElements.balance.textContent = `${pgBalance.toFixed(8)} PG`;
                DOMElements.usdtValue.textContent = `($${(pgBalance * PG_TO_USDT_RATE).toFixed(4)} USDT)`;

                const sessionEnd = currentUser.miningSessionEndTime?.toMillis();
                const now = Date.now();

                if (sessionEnd) {
                    if (now < sessionEnd) { // Session is active
                        this.enterActiveState(sessionEnd);
                    } else { // Session has ended, ready to claim
                        this.enterClaimState();
                    }
                } else { // No active session
                    this.enterIdleState();
                }
            },

            enterIdleState() {
                const { DOMElements } = this;
                DOMElements.statusDot.classList.remove('active');
                DOMElements.statusText.textContent = "Inactive";
                DOMElements.miningButton.textContent = "Start 4H Session";
                DOMElements.miningButton.disabled = false;
                DOMElements.miningButton.onclick = () => this.startSession();
                DOMElements.sessionTimer.textContent = this.formatTime(MINING_SESSION_DURATION);
                DOMElements.progressBar.style.width = '0%';
            },

            enterActiveState(sessionEnd) {
                const { DOMElements } = this;
                DOMElements.statusDot.classList.add('active');
                DOMElements.statusText.textContent = "Mining Active";
                DOMElements.miningButton.textContent = "Session in Progress";
                DOMElements.miningButton.disabled = true;
                
                const updateTimer = () => {
                    const timeLeft = sessionEnd - Date.now();
                    if (timeLeft <= 0) {
                        clearInterval(miningTimerInterval);
                        this.enterClaimState();
                        return;
                    }
                    const progress = ((MINING_SESSION_DURATION - timeLeft) / MINING_SESSION_DURATION) * 100;
                    DOMElements.sessionTimer.textContent = this.formatTime(timeLeft);
                    DOMElements.progressBar.style.width = `${progress}%`;
                };

                miningTimerInterval = setInterval(updateTimer, 1000);
                updateTimer();
            },

            enterClaimState() {
                const { DOMElements } = this;
                DOMElements.statusDot.classList.remove('active');
                DOMElements.statusText.textContent = "Session Ended";
                DOMElements.miningButton.textContent = `Claim ${MINING_REWARD_PER_SESSION.toFixed(4)} PG`;
                DOMElements.miningButton.disabled = false;
                DOMElements.miningButton.onclick = () => this.claimReward();
                DOMElements.sessionTimer.textContent = this.formatTime(0);
                DOMElements.progressBar.style.width = '100%';
            },
            
            async startSession() {
                if (!currentUser) return;
                const { DOMElements } = this;
                DOMElements.miningButton.disabled = true;
                DOMElements.miningButton.textContent = 'Starting...';

                const newEndTime = new Date(Date.now() + MINING_SESSION_DURATION);
                try {
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, { miningSessionEndTime: newEndTime });
                    await fetchAndUpdateCurrentUser();
                    this.updateUI(); // Re-initialize UI based on new state
                } catch(error) {
                    console.error("Failed to start mining session:", error);
                    alert("Error starting session. Please try again.");
                    this.updateUI();
                }
            },

            async claimReward() {
                 if (!currentUser || !currentUser.miningSessionEndTime) return;
                 const { DOMElements } = this;
                 DOMElements.miningButton.disabled = true;
                 DOMElements.miningButton.textContent = 'Claiming...';

                 try {
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, {
                        pgBalance: increment(MINING_REWARD_PER_SESSION),
                        miningSessionEndTime: null
                    });
                    showSuccessModal("Reward Claimed!", `${MINING_REWARD_PER_SESSION.toFixed(4)} PG has been added to your balance.`);
                    await fetchAndUpdateCurrentUser();
                    this.updateUI();
                 } catch (error) {
                    console.error("Failed to claim mining reward:", error);
                    alert("Error claiming reward. Please try again.");
                    this.updateUI();
                 }
            }
        };
        
        // --- WITHDRAWAL LOGIC ---
        function renderWithdrawalUI() {
            if (!currentUser) return;
            const pgBalance = parseFloat(currentUser.pgBalance || 0);
            const referralCount = currentUser.referralCount || 0;

            document.getElementById('withdrawPgBalance').textContent = pgBalance.toFixed(4);

            const pgCheckEl = document.getElementById('pgCoinCheck');
            const refCheckEl = document.getElementById('referralCheck');
            const requestBtn = document.getElementById('requestWithdrawalBtn');

            const hasEnoughPg = pgBalance >= MIN_PG_TO_WITHDRAW;
            const hasEnoughRefs = referralCount >= MIN_REFERRALS_TO_WITHDRAW;

            pgCheckEl.innerHTML = `Requirement: ${MIN_PG_TO_WITHDRAW} PG <span style="color: ${hasEnoughPg ? 'var(--success-color)' : '#dc3545'};">(${pgBalance.toFixed(2)} owned)</span>`;
            refCheckEl.innerHTML = `Requirement: ${MIN_REFERRALS_TO_WITHDRAW} Referrals <span style="color: ${hasEnoughRefs ? 'var(--success-color)' : '#dc3545'};">(${referralCount} referred)</span>`;

            requestBtn.disabled = !(hasEnoughPg && hasEnoughRefs);
        }

        document.getElementById('withdrawalForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!currentUser) return;
            const submitButton = e.target.querySelector('button[type="submit"]');
            
            const amount = parseFloat(document.getElementById('withdrawalAmount').value);
            const pgBalance = parseFloat(currentUser.pgBalance || 0);
            const referralCount = currentUser.referralCount || 0;

            if (isNaN(amount) || amount <= 0) {
                alert(`Please enter a valid amount.`); return;
            }
            if (amount < MIN_PG_TO_WITHDRAW) {
                alert(`Minimum withdrawal is ${MIN_PG_TO_WITHDRAW} PG.`); return;
            }
            if (amount > pgBalance) {
                alert("Insufficient PG Coin balance."); return;
            }
            if (referralCount < MIN_REFERRALS_TO_WITHDRAW) {
                alert(`You need at least ${MIN_REFERRALS_TO_WITHDRAW} referrals to withdraw.`); return;
            }

            submitButton.disabled = true; submitButton.textContent = 'Processing...';
            const requestData = { 
                userId: currentUser.id, 
                telegramUsername: currentUser.telegramUsername, 
                pgAmount: amount,
                coinType: 'PG',
                method: document.getElementById('withdrawalMethod').value, 
                details: document.getElementById('accountDetails').value, 
                status: 'pending', 
                createdAt: serverTimestamp() 
            };
            try {
                await runTransaction(db, async (transaction) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await transaction.get(userRef);
                    if (!userDoc.exists() || userDoc.data().pgBalance < amount) throw new Error("Insufficient PG balance.");
                    
                    transaction.set(doc(collection(db, 'withdrawals')), requestData);
                    transaction.update(userRef, { 
                        pgBalance: increment(-amount),
                        withdrawalCount: increment(1)
                     });
                });
                await fetchAndUpdateCurrentUser();
                renderWithdrawalUI();
                e.target.reset();
                showSuccessModal("Successfully Sent!", "Your withdrawal request is pending. Check status in History.");
            } catch (error) {
                console.error("Withdrawal Error:", error);
                alert(`An error occurred: ${error.message || "Please try again."}`);
            } finally {
                submitButton.disabled = false; submitButton.textContent = 'Request Withdrawal';
            }
        });

        async function displayWithdrawalHistory() {
            const historyContainer = document.getElementById('history-list');
            historyContainer.innerHTML = '<div class="loader"></div>';
            try {
                const q = query(collection(db, "withdrawals"), where("userId", "==", currentUser.id), orderBy("createdAt", "desc"), limit(50));
                const snapshot = await getDocs(q);
                historyContainer.innerHTML = '';
                if (snapshot.empty) { historyContainer.innerHTML = '<p style="text-align:center;">No withdrawal history found.</p>'; return; }
                snapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    const date = data.createdAt?.toDate().toLocaleDateString() || 'N/A';
                    const status = data.status || 'pending';
                    let amountText = '';
                    if (data.coinType === 'PG' && data.pgAmount) {
                        amountText = `${data.pgAmount.toFixed(4)} PG`;
                    } else if (data.usdAmount) {
                        amountText = `$${parseFloat(data.usdAmount || 0).toFixed(2)} USDT`;
                    } else {
                        amountText = `${data.pointsAmount} Points`;
                    }
                    item.innerHTML = `<div><strong>${amountText}</strong><br><small>${data.method} - ${date}</small></div><strong class="status-${status}">${status.charAt(0).toUpperCase() + status.slice(1)}</strong>`;
                    historyContainer.appendChild(item);
                });
            } catch (error) { console.error("Error fetching withdrawal history:", error); historyContainer.innerHTML = '<p style="color:red;">Error loading history.</p>'; }
        }
        
        async function fetchLeaderboard() {
            const listContainer = document.getElementById('leaderboard-list');
            const myReferralsContainer = document.getElementById('my-referrals-list');
            listContainer.innerHTML = '<div class="loader"></div>';
            myReferralsContainer.innerHTML = '<div class="loader"></div>';

            try {
                const topReferrersQuery = query(collection(db, "users"), where("referralCount", ">", 0), orderBy("referralCount", "desc"), limit(20));
                const topSnapshot = await getDocs(topReferrersQuery);
                listContainer.innerHTML = '';
                if (topSnapshot.empty) { 
                    listContainer.innerHTML = '<p style="text-align:center;">Leaderboard is empty. Be the first to refer!</p>';
                } else {
                    let rank = 1;
                    topSnapshot.forEach(docSnap => {
                        const user = docSnap.data();
                        const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        item.innerHTML = `<div class="rank">#${rank}</div><div class="info"><strong>${user.telegramUsername || 'User ' + docSnap.id.substring(0, 5)}</strong></div><div class="count">${user.referralCount} Referrals</div>`;
                        listContainer.appendChild(item);
                        rank++;
                    });
                }
            } catch (error) {
                console.error("Error fetching leaderboard:", error);
                listContainer.innerHTML = '<p style="color:red; text-align:center;">Could not load leaderboard.</p>';
            }
            
            try {
                const myReferralsQuery = query(collection(db, "users"), where("referredBy", "==", currentUser.id));
                const myReferralsSnapshot = await getDocs(myReferralsQuery);
                myReferralsContainer.innerHTML = '';
                if (myReferralsSnapshot.empty) {
                    myReferralsContainer.innerHTML = '<p style="text-align:center;">You haven\'t referred anyone yet.</p>';
                } else {
                     myReferralsSnapshot.forEach(docSnap => {
                        const referee = docSnap.data();
                        const refereeId = docSnap.id;
                        const item = document.createElement('div');
                        item.className = 'leaderboard-item';

                        const lifetimePoints = referee.lifetimePointsEarned || 0;
                        const isBonusPaid = referee.referralBonusPaidOut === true;
                        
                        let statusHtml;
                        if (isBonusPaid) {
                            statusHtml = `<div class="count" style="color: var(--success-color);">Claimed</div>`;
                        } else if (lifetimePoints >= REFERRAL_POINTS_THRESHOLD) {
                            statusHtml = `<button class="form-button claim-referral-btn" data-referee-id="${refereeId}">Claim ${REFERRAL_BONUS_AMOUNT}</button>`;
                        } else {
                            statusHtml = `<div class="count" style="color: var(--text-muted);">${formatPoints(lifetimePoints)} / ${REFERRAL_POINTS_THRESHOLD}</div>`;
                        }
                        
                        item.innerHTML = `<div class="info" style="margin-left:0;"><strong>${referee.telegramUsername || 'User ' + refereeId.substring(0, 5)}</strong><br><small>Points Earned: ${formatPoints(lifetimePoints)}</small></div>${statusHtml}`;
                        myReferralsContainer.appendChild(item);
                    });
                }
            } catch(error) {
                console.error("Error fetching your referrals:", error);
                myReferralsContainer.innerHTML = '<p style="color:red; text-align:center;">Could not load your referrals.</p>';
            }
        }

        async function claimReferralBonus(refereeId, button) {
            button.disabled = true;
            button.textContent = '...';

            const referrerRef = doc(db, 'users', currentUser.id);
            const refereeRef = doc(db, 'users', refereeId);

            try {
                await runTransaction(db, async (transaction) => {
                    const refereeSnap = await transaction.get(refereeRef);
                    if (!refereeSnap.exists()) { throw new Error("Referee not found."); }
                    
                    const refereeData = refereeSnap.data();
                    if (refereeData.referralBonusPaidOut === true) { throw new Error("Bonus already paid."); }
                    if ((refereeData.lifetimePointsEarned || 0) < REFERRAL_POINTS_THRESHOLD) { throw new Error("Referee has not reached the threshold."); }

                    transaction.update(referrerRef, { balance: increment(REFERRAL_BONUS_AMOUNT) });
                    transaction.update(refereeRef, { referralBonusPaidOut: true });
                });

                showSuccessModal("Bonus Claimed!", `${REFERRAL_BONUS_AMOUNT} points have been added to your balance.`);
                await fetchAndUpdateCurrentUser(); // Update balance in UI
                button.textContent = 'Claimed';
                button.style.backgroundColor = 'var(--success-color)';

            } catch (error) {
                console.error("Failed to claim referral bonus:", error);
                alert(`Error: ${error.message}`);
                button.disabled = false;
                button.textContent = `Claim ${REFERRAL_BONUS_AMOUNT}`;
            }
        }
        
        document.getElementById('my-referrals-list').addEventListener('click', async (e) => {
            if (e.target.matches('.claim-referral-btn') && !e.target.disabled) {
                const refereeId = e.target.dataset.refereeId;
                await claimReferralBonus(refereeId, e.target);
            }
        });
        
        function startDailyTimer() {
            if (dailyTimerInterval) clearInterval(dailyTimerInterval);
            dailyTimerInterval = setInterval(async () => {
                timeSpentThisSession++;
                if (timeSpentThisSession > 0 && timeSpentThisSession % 60 === 0) {
                    if (!currentUser?.id) return;
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, { 'dailyTasks.timeSpent': increment(60) });
                    await fetchAndUpdateCurrentUser(); 
                }
                if (document.getElementById('task-content').classList.contains('active')) {
                    renderDailyTasks();
                }
            }, 1000);
        }

        function renderDailyTasks() {
            if (!currentUser) return;
            const container = document.getElementById('daily-task-list');
            container.innerHTML = '';
            
            const claimedTasks = currentUser.dailyTasks?.claimed || [];
            const timeSpent = (currentUser.dailyTasks?.timeSpent || 0);

            dailyTasksConfig.forEach(task => {
                const card = document.createElement('div');
                card.className = 'daily-task-card';
                
                const isClaimed = claimedTasks.includes(task.id);
                let canClaim = false;
                let buttonText = 'Go';

                if (isClaimed) {
                    buttonText = 'Claimed';
                } else if (task.type === 'time') {
                    if (timeSpent + timeSpentThisSession >= task.requirement) {
                        canClaim = true;
                        buttonText = 'Claim';
                    } else {
                        const timeLeft = task.requirement - (timeSpent + timeSpentThisSession);
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        buttonText = `Wait ${minutes}m ${seconds}s`;
                    }
                } else if (task.type === 'action') {
                    canClaim = true;
                    buttonText = 'Go & Claim';
                }
                
                card.innerHTML = `
                    <div class="daily-task-info">
                        <h4>${task.title}</h4>
                        <p>Reward: ${task.reward} Points</p>
                    </div>
                    <button class="daily-task-button" 
                            data-task-id="${task.id}" 
                            data-task-type="${task.type}"
                            data-task-url="${task.url || ''}"
                            data-reward="${task.reward}"
                            ${isClaimed || !canClaim ? 'disabled' : ''}>
                        ${buttonText}
                    </button>`;
                container.appendChild(card);
            });
        }

        document.getElementById('daily-task-list').addEventListener('click', async (e) => {
            if (!e.target.matches('.daily-task-button') || e.target.disabled) return;
            const button = e.target;
            const { taskId, taskType, taskUrl, reward } = button.dataset;

            if (taskType === 'action' && taskUrl) {
                tg.openLink(taskUrl);
            }

            button.disabled = true; button.textContent = '...';
            try {
                const userRef = doc(db, 'users', currentUser.id);
                await grantPoints(Number(reward), 'daily_task');
                await updateDoc(userRef, { 'dailyTasks.claimed': arrayUnion(taskId) });
                await fetchAndUpdateCurrentUser();
                renderDailyTasks();
                showSuccessModal("Reward Claimed!", `You earned ${reward} points.`);
            } catch (error) {
                alert("Failed to claim task. Please try again.");
                button.disabled = false;
                console.error("Daily task claim error:", error);
            }
        });

        let game_mathQuiz = {};
        let game_scratchCard = {};

        // Shared ad functions for games
        const showMonetagAd = () => new Promise((res, rej) => typeof show_9442539 === 'function' ? show_9442539().then(res).catch(rej) : rej('Monetag SDK missing'));
        const showGigaPubAd = () => new Promise((res, rej) => typeof window.showGiga === 'function' ? window.showGiga("main").then(res).catch(rej) : rej('GigaPub SDK missing'));
        const showOnclickaVideoAd = () => new Promise((res, rej) => {
            if (window.showOnclickaVideoFunc) {
                window.showOnclickaVideoFunc()
                  .then(() => { console.log('Onclicka ad played.'); res(); })
                  .catch(e => { console.error('Onclicka ad error.', e); rej(e); });
            } else {
                rej('Onclicka Video function not available.');
            }
        });
        
        async function showRandomAdForGames() {
            const gameAdNetworks = [showMonetagAd, showGigaPubAd, showOnclickaVideoAd];
            const randomAdFunction = gameAdNetworks[Math.floor(Math.random() * gameAdNetworks.length)];
            console.log(`Attempting to show game ad from: ${randomAdFunction.name}`);
            return randomAdFunction();
        }

        function renderGameZone() {
            if (!currentUser) return;
            game_mathQuiz.init();
            game_scratchCard.init();
        }

        async function handleGamePlay(gameType) {
            if (!currentUser) return false;
            
            gamePlayCounter++;
            const userRef = doc(db, 'users', currentUser.id);

            try {
                await updateDoc(userRef, { [`dailyGamePlays.${gameType}`]: increment(1) });
                await fetchAndUpdateCurrentUser();
                
                if (gamePlayCounter >= GAME_AD_TRIGGER_COUNT) {
                    gamePlayCounter = 0; // Reset counter
                    console.log("Triggering ad after game play...");
                    await showRandomAdForGames();
                }
                return true;
            } catch (error) {
                console.error(`Error in handleGamePlay for ${gameType}:`, error);
                alert("Ad could not be shown, but you will still get your reward.");
                return true; 
            }
        }

        (function() { // Math Quiz Logic
            const questionElement = document.getElementById('question');
            const answerButtonsElement = document.getElementById('answer-buttons');
            const nextButton = document.getElementById('next-btn');
            const scoreElement = document.getElementById('score-container');
            const quizContainer = document.getElementById('quiz');
            const resultsContainer = document.getElementById('math-results-container');
            const finalScoreElement = document.getElementById('final-score');
            const playAgainButton = document.getElementById('play-again-btn');
            const attemptsLeftDisplay = document.getElementById('math-attempts-left');
            
            const questions = [{ q: '5+7', o: [10, 12, 13, 11], a: 12 }, { q: '15-6', o: [9, 8, 10, 7], a: 9 }, { q: '8×4', o: [32, 28, 36, 24], a: 32 }, { q: '24÷3', o: [6, 7, 8, 9], a: 8 }, { q: '9+9', o: [18, 16, 20, 17], a: 18 }];
            let currentQuestionIndex = 0; let score = 0;

            function updateAttempts() {
                const plays = currentUser.dailyGamePlays?.math || 0;
                const limit = 10;
                attemptsLeftDisplay.textContent = `Today's Attempts: ${plays}/${limit}`;
                return plays < limit;
            }

            function startGame() { 
                resultsContainer.classList.add('hide');
                quizContainer.classList.remove('hide');
                if (!updateAttempts()) {
                    quizContainer.innerHTML = '<p>No more quiz attempts for today.</p>';
                    return;
                }
                currentQuestionIndex = 0; score = 0; scoreElement.innerText = `Score: 0`; 
                showQuestion(); 
            }
            function showQuestion() { resetState(); let currentQuestion = questions[currentQuestionIndex]; questionElement.innerText = `Question ${currentQuestionIndex + 1}: ${currentQuestion.q} = ?`; currentQuestion.o.forEach(opt => { const button = document.createElement('button'); button.innerText = opt; button.classList.add('btn'); if (opt === currentQuestion.a) button.dataset.correct = true; button.addEventListener('click', selectAnswer); answerButtonsElement.appendChild(button); }); }
            function resetState() { nextButton.classList.add('hide'); while (answerButtonsElement.firstChild) { answerButtonsElement.removeChild(answerButtonsElement.firstChild); } }
            function selectAnswer(e) { const selectedBtn = e.target; if (selectedBtn.dataset.correct) { score++; scoreElement.innerText = `Score: ${score}`; } Array.from(answerButtonsElement.children).forEach(button => { setStatusClass(button, button.dataset.correct); button.disabled = true; }); nextButton.classList.remove('hide'); }
            function setStatusClass(element, correct) { if(correct) { element.classList.add('correct'); } else { element.classList.add('incorrect'); } }
            
            async function handleNextButton() {
                currentQuestionIndex++;
                if (currentQuestionIndex < questions.length) { showQuestion(); } else { await showResults(); }
            }

            async function showResults() {
                quizContainer.classList.add('hide');
                resultsContainer.classList.remove('hide');
                finalScoreElement.innerText = `You scored ${score} out of ${questions.length}!`;
                
                await handleGamePlay('math');
                const pointsWon = Math.floor(Math.random() * (50 - 3 + 1)) + 3;
                await grantPoints(pointsWon, 'math_quiz');
                showSuccessModal("Quiz Complete!", `You won ${pointsWon} points!`);
                updateAttempts();
            }

            nextButton.addEventListener('click', handleNextButton);
            playAgainButton.addEventListener('click', startGame);
            game_mathQuiz.init = startGame;
        })();

        (function() { // Scratch Card Logic
            const canvas = document.getElementById('scratch-canvas');
            const ctx = canvas.getContext('2d');
            const rewardResult = document.getElementById('reward-result');
            const attemptsLeftDisplay = document.getElementById('attempts-left');
            const newCardBtn = document.getElementById('new-card-btn');
            
            let canScratch = false; let isDrawing = false;

            function updateAttempts() {
                const plays = currentUser.dailyGamePlays?.scratch || 0;
                const limit = 10;
                attemptsLeftDisplay.textContent = `Attempts left: ${limit - plays}`;
                if (plays >= limit) {
                    rewardResult.textContent = "See You Tomorrow!";
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    newCardBtn.classList.add('hide');
                    return false;
                }
                return true;
            }

            function generateReward() { return Math.random() < 0.2 ? "Empty! Try Again." : `${Math.floor(Math.random() * (50 - 3 + 1)) + 3} Points Won!`; }
            function generateNewCard() { if (!updateAttempts()) return; newCardBtn.classList.add('hide'); canScratch = true; ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = '#bdc3c7'; ctx.fillRect(0, 0, canvas.width, canvas.height); rewardResult.textContent = generateReward(); }
            function getEventCoords(e) { const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; if (e.touches && e.touches.length > 0) return { x: (e.touches[0].clientX - rect.left) * scaleX, y: (e.touches[0].clientY - rect.top) * scaleY }; return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY }; }
            function startScratching(e) { if (!canScratch) return; isDrawing = true; const coords = getEventCoords(e); scratch(coords.x, coords.y); }
            function stopScratching() { isDrawing = false; }
            function doScratch(e) { if (!isDrawing || !canScratch) return; e.preventDefault(); const coords = getEventCoords(e); scratch(coords.x, coords.y); }
            function scratch(x, y) { ctx.globalCompositeOperation = 'destination-out'; ctx.beginPath(); ctx.arc(x, y, 20, 0, 2 * Math.PI); ctx.fill(); checkScratchPercentage(); }
            
            canvas.addEventListener('mousedown', startScratching); canvas.addEventListener('touchstart', startScratching);
            canvas.addEventListener('mousemove', doScratch); canvas.addEventListener('touchmove', doScratch);
            window.addEventListener('mouseup', stopScratching); window.addEventListener('touchend', stopScratching);
            newCardBtn.addEventListener('click', generateNewCard);

            function checkScratchPercentage() {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data; let transparentPixels = 0;
                for (let i = 3; i < pixels.length; i += 4) { if (pixels[i] === 0) transparentPixels++; }
                if ((transparentPixels / (canvas.width * canvas.height)) * 100 > 65) { finishCard(); }
            }
            
            async function finishCard() {
                if (!canScratch) return;
                canScratch = false;
                
                await handleGamePlay('scratch');
                
                const rewardText = rewardResult.textContent;
                if (rewardText.includes("Points Won!")) {
                    const pointsWon = parseInt(rewardText);
                    await grantPoints(pointsWon, 'scratch_card');
                    showSuccessModal("You Won!", `You received ${pointsWon} points.`);
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                newCardBtn.classList.remove('hide');
                updateAttempts();
            }
            game_scratchCard.init = generateNewCard;
        })();

        document.getElementById('select-math-quiz').addEventListener('click', () => {
            document.getElementById('scratch-card-container').classList.remove('active'); document.getElementById('math-quiz-container').classList.add('active');
            document.getElementById('select-math-quiz').classList.add('active'); document.getElementById('select-scratch-card').classList.remove('active');
        });
        document.getElementById('select-scratch-card').addEventListener('click', () => {
            document.getElementById('math-quiz-container').classList.remove('active'); document.getElementById('scratch-card-container').classList.add('active');
            document.getElementById('select-scratch-card').classList.add('active'); document.getElementById('select-math-quiz').classList.remove('active');
        });

        async function checkForUnreadMessages() {
            if (!currentUser?.id) return;
            const messagesRef = collection(db, 'messages');
            const q = query(messagesRef, where("isGlobal", "==", true));
            const snapshot = await getDocs(q);
            const userReadMessages = currentUser.readMessages || [];
            const unreadMessagesExist = snapshot.docs.some(doc => !userReadMessages.includes(doc.id));
            
            if (unreadMessagesExist) {
                document.getElementById('inbox-notification-dot').classList.add('visible');
            } else {
                document.getElementById('inbox-notification-dot').classList.remove('visible');
            }
        }
        
        document.getElementById('inbox-container').addEventListener('click', async () => {
            const modalOverlay = document.getElementById('inboxModalOverlay');
            const messageList = document.getElementById('inbox-message-list');
            messageList.innerHTML = '<div class="loader"></div>';
            modalOverlay.classList.add('show');
            
            try {
                const messagesRef = collection(db, 'messages');
                const q = query(messagesRef, where("isGlobal", "==", true), orderBy("createdAt", "desc"), limit(20));
                const snapshot = await getDocs(q);

                messageList.innerHTML = '';
                if (snapshot.empty) {
                    messageList.innerHTML = '<p style="text-align: center; color: var(--text-muted);">No new messages.</p>';
                } else {
                    const messagesToMarkAsRead = [];
                    snapshot.forEach(doc => {
                        const msg = doc.data();
                        const item = document.createElement('div');
                        item.className = 'inbox-message-item';
                        item.innerHTML = `<p>${msg.content}</p><small>${msg.createdAt.toDate().toLocaleString()}</small>`;
                        messageList.appendChild(item);
                        if (!currentUser.readMessages.includes(doc.id)) {
                           messagesToMarkAsRead.push(doc.id);
                        }
                    });
                    
                    if (messagesToMarkAsRead.length > 0) {
                        const userRef = doc(db, 'users', currentUser.id);
                        await updateDoc(userRef, {
                            readMessages: arrayUnion(...messagesToMarkAsRead)
                        });
                        document.getElementById('inbox-notification-dot').classList.remove('visible');
                    }
                }
            } catch (error) {
                console.error("Error fetching inbox messages:", error);
                messageList.innerHTML = '<p style="text-align: center; color: red;">Failed to load messages.</p>';
            }
        });

        document.getElementById('closeInboxBtn').addEventListener('click', () => {
            document.getElementById('inboxModalOverlay').classList.remove('show');
        });

        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', async (e) => {
                e.preventDefault();
                stopAndClearVideo();
                if (miningTimerInterval) clearInterval(miningTimerInterval);

                document.querySelectorAll('.nav-link, .content-section').forEach(el => el.classList.remove('active'));
                link.classList.add('active');
                const targetId = link.dataset.tabTarget;
                const target = document.querySelector(targetId);
                if(target) target.classList.add('active');
                switch(targetId) {
                    case '#home-content': fetchContent(); break;
                    case '#mining-content': miningApp.updateUI(); break;
                    case '#ads-to-earn-content': setupAdsToEarn(); break;
                    case '#task-content': fetchTasks(); renderDailyTasks(); break;
                    case '#game-zone-content': renderGameZone(); break;
                    case '#leaderboard-content': fetchLeaderboard(); break;
                    case '#withdraw-content': renderWithdrawalUI(); break;
                    case '#history-content': displayWithdrawalHistory(); break;
                }
                document.getElementById('side-menu').classList.remove('is-open');
                document.getElementById('menu-overlay').classList.remove('is-open');
            });
        });

        async function main() {
            try {
                if (!tg.initDataUnsafe?.user) {
                    document.body.innerHTML = `<div class="card" style="margin-top: 50px;"><h3>Error</h3><p>This application can only be launched from Telegram.</p></div>`; return;
                }

                try {
                    window.initCdTma?.({ id: '343423' }).then(show => {
                        window.showOnclickaVideoFunc = show;
                        console.log("Onclicka Rewarded Video Engine Initialized.");
                    }).catch(e => console.error("Onclicka Init Error:", e));
                } catch(e) {
                    console.error("Onclicka init script failed:", e);
                }
                
                tg.ready(); tg.expand();
                await initializeUser(tg.initDataUnsafe.user, tg.initDataUnsafe.start_param);
                document.querySelector('.nav-link[data-tab-target="#home-content"]').click();
                
                const menuToggleBtn = document.getElementById('menu-toggle-button');
                const closeMenuBtn = document.getElementById('close-menu-btn');
                const sideMenu = document.getElementById('side-menu');
                const menuOverlay = document.getElementById('menu-overlay');
                const toggleMenu = () => { sideMenu.classList.toggle('is-open'); menuOverlay.classList.toggle('is-open'); };
                [menuToggleBtn, closeMenuBtn, menuOverlay].forEach(el => el.addEventListener('click', toggleMenu));

                const searchInput = document.getElementById('videoSearchInput');
                const searchBtn = document.getElementById('videoSearchBtn');
                const clearBtn = document.getElementById('clearSearchBtn');
                const performSearch = () => { const searchTerm = searchInput.value.trim(); searchVideos(searchTerm); clearBtn.style.display = searchTerm ? 'inline-block' : 'none'; };
                searchBtn.addEventListener('click', performSearch);
                searchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { performSearch(); } });
                clearBtn.addEventListener('click', () => { searchInput.value = ''; fetchContent(); clearBtn.style.display = 'none'; });

            } catch (error) {
                console.error("Initialization failed:", error);
                document.body.innerHTML = `<div class="card" style="margin-top: 50px;"><h3>Application Error</h3><p>Could not initialize. Please restart.</p><p style="font-size: 0.8em; color: #888;">Error: ${error.message}</p></div>`;
            }
        }
        
        main();

    </script>
</body>
</html>