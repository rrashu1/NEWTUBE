<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MOVIE FOR VIRAL - Watch & Earn</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- Monetag Ads Library -->
    <script src='//libtl.com/sdk.js' data-zone='9442539' data-sdk='show_9442539'></script>
    <style>
        :root {
            --primary-accent-color: #FF4500; --primary-accent-hover-color: #E03D00; --dark-bg: #000000;
            --card-bg: #1a1a1a; --header-bg: #181818; --text-light: #ffffff; --text-muted: #b3b3b3;
            --border-color: #282828; --success-color: #28a745; --disabled-color: #444;
        }
        body { background-color: var(--dark-bg); color: var(--text-light); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; padding: 60px 0 0; }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }
        .main-header { background-color: var(--header-bg); padding: 10px 15px; border-bottom: 1px solid var(--border-color); position: fixed; top: 0; left: 0; right: 0; z-index: 1000; display: flex; justify-content: space-between; align-items: center; height: 40px; }
        .site-title { font-size: 1.2em; color: var(--primary-accent-color); font-weight: 700; text-transform: uppercase; }
        .header-right { display: flex; align-items: center; gap: 15px; }
        .inbox-container { position: relative; cursor: pointer; }
        #inbox-icon { width: 24px; height: 24px; color: var(--text-light); }
        #inbox-notification-dot { position: absolute; top: -2px; right: -2px; width: 8px; height: 8px; background-color: var(--primary-accent-color); border-radius: 50%; border: 1px solid var(--header-bg); display: none; }
        #inbox-notification-dot.visible { display: block; }
        .balance-display { background-color: #2a2a2a; color: var(--primary-accent-color); padding: 5px 12px; border-radius: 20px; font-weight: bold; font-size: 0.9em; }
        .menu-toggle-button { background: none; border: none; cursor: pointer; padding: 5px; display: flex; flex-direction: column; gap: 4px; }
        .menu-toggle-button .bar { width: 22px; height: 2px; background-color: var(--text-light); border-radius: 2px; }
        .side-menu { position: fixed; top: 0; right: -100%; width: 250px; height: 100%; background-color: var(--header-bg); z-index: 1001; transition: right 0.3s ease-in-out; display: flex; flex-direction: column; }
        .side-menu.is-open { right: 0; }
        .side-menu-header { padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .side-menu-header h3 { margin: 0; } .close-menu-btn { background: none; border: none; font-size: 1.5em; color: var(--text-light); cursor: pointer; }
        .side-menu-nav { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; }
        .side-menu-nav a { display: block; padding: 15px 20px; color: var(--text-muted); text-decoration: none; font-weight: 500; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s, color 0.2s; }
        .side-menu-nav a:hover, .side-menu-nav a.active { background-color: var(--primary-accent-color); color: var(--text-light); }
        .menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: none; }
        .menu-overlay.is-open { display: block; }
        .content-section { display: none; padding-top: 25px; } .content-section.active { display: block; }
        .section-title { font-size: 1.5em; margin-bottom: 20px; padding-bottom: 10px; color: var(--text-light); border-bottom: 2px solid var(--border-color); }
        .item-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
        .movie-item, .task-card, .ad-task-card { background-color: var(--card-bg); border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; }
        .movie-item { cursor: pointer; transition: transform 0.2s; } .movie-item:hover{ transform: scale(1.03); }
        .thumbnail-container { width: 100%; aspect-ratio: 16/9; background-color: #333; position: relative; }
        .thumbnail-container img { width: 100%; height: 100%; object-fit: cover; }
        .video-progress-bar-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 5px; background-color: rgba(255, 255, 255, 0.3); }
        .video-progress-bar { width: 0%; height: 100%; background-color: var(--success-color); transition: width 0.5s linear; }
        .movie-item-info, .task-card-info, .ad-task-card-info { padding: 15px; flex-grow: 1; text-align:center;}
        .movie-item-info h4, .task-card h4, .ad-task-card h4 { margin: 0 0 8px; font-size: 1.1em; line-height: 1.3; }
        .movie-reward, .ad-visits-left { color: var(--success-color); font-weight: bold; font-size: 0.9em; margin: 0; }
        .player-container { width: 100%; aspect-ratio: 16/9; background: #000; }
        .task-card p, .ad-task-card p { margin: 8px 0 15px; color: var(--success-color); font-weight: bold; }
        .task-button, .ad-task-button { width: 100%; padding: 12px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; background-color: var(--primary-accent-color); color: var(--text-light); transition: background-color .2s; margin-top: auto; font-size: 1em;}
        .task-button:disabled, .ad-task-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        .card { max-width: 500px; margin: 20px auto; background-color: var(--card-bg); padding: 25px; border-radius: 12px; border: 1px solid var(--border-color); text-align: center; }
        .card-icon { width: 50px; height: 50px; margin: 0 auto 15px; color: var(--primary-accent-color); }
        .card h3 { margin-top: 0; font-size: 1.4em; } .card p { color: var(--text-muted); line-height: 1.6; }
        .form-group { margin-bottom: 15px; text-align: left; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 500; color: var(--text-muted); }
        .form-group input, .form-group select { width: 100%; padding: 12px; box-sizing: border-box; border-radius: 8px; border: 1px solid var(--border-color); background-color: #000; color: var(--text-light); font-size: 1em; }
        .form-button { width: 100%; padding: 12px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: var(--text-light); font-weight: bold; font-size: 1em; cursor: pointer; transition: background-color 0.2s; }
        .form-button:hover:not(:disabled) { background-color: var(--primary-accent-hover-color); }
        .form-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        .referral-link-wrapper { display: flex; gap: 10px; margin-top: 20px; }
        .referral-link-wrapper input { flex-grow: 1; text-align: center; }
        .referral-link-wrapper button { width: auto; flex-shrink: 0; padding: 0 15px; }
        .loader { border: 4px solid var(--border-color); border-top: 4px solid var(--primary-accent-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 50px auto; }
        .history-item, .leaderboard-item { background-color: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .leaderboard-item .rank { font-size: 1.2em; font-weight: bold; color: var(--primary-accent-color); min-width: 30px; text-align: center;}
        .leaderboard-item .info { flex-grow: 1; margin-left: 15px; }
        .leaderboard-item .info strong { color: var(--text-light); }
        .leaderboard-item .info small { color: var(--text-muted); }
        .leaderboard-item .count { font-size: 1.1em; font-weight: bold; color: var(--success-color); }
        .history-item .status-pending { color: #ffc107; } .history-item .status-approved { color: #28a745; } .history-item .status-rejected { color: #dc3545; }
        .conversion-info { font-size: 0.9em; color: var(--text-muted); margin-bottom: 15px; }
        .withdrawal-cooldown-message { background-color: #2a2a2a; padding: 20px; border-radius: 8px; text-align: center; color: #ffc107; display: none; }
        .withdrawal-cooldown-message p { margin: 0; line-height: 1.5; font-size: 0.9em;}
        .success-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .success-modal-overlay.show { display: flex; }
        .success-modal { background-color: var(--card-bg); color: var(--text-light); padding: 30px 40px; border-radius: 15px; text-align: center; transform: scale(0.9); opacity: 0; animation: modal-pop-in 0.3s forwards; }
        .success-modal-icon { width: 70px; height: 70px; border-radius: 50%; background-color: var(--success-color); display: flex; justify-content: center; align-items: center; font-size: 40px; font-weight: bold; color: white; margin: 0 auto 20px; animation: icon-pop-in 0.5s 0.2s backwards; }
        .success-modal h3 { margin: 0 0 10px; font-size: 1.6em; }
        .success-modal p { margin: 0; color: var(--text-muted); font-size: 1em;}
        .inbox-modal { background-color: var(--card-bg); color: var(--text-light); padding: 20px; border-radius: 15px; text-align: left; width: 90%; max-width: 400px; max-height: 80vh; display: flex; flex-direction: column; }
        .inbox-modal h3 { text-align: center; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        #inbox-message-list { overflow-y: auto; flex-grow: 1; margin-bottom: 15px; }
        .inbox-message-item { background-color: #2a2a2a; padding: 12px; border-radius: 8px; margin-bottom: 10px; }
        .inbox-message-item p { margin: 0; line-height: 1.5; }
        .inbox-message-item small { color: var(--text-muted); font-size: 0.8em; }
        #closeInboxBtn { padding: 10px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: white; cursor: pointer; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes modal-pop-in { to { transform: scale(1); opacity: 1; } }
        @keyframes icon-pop-in { 0% { transform: scale(0); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <header class="main-header">
        <h1 class="site-title">Movie for Viral</h1>
        <div class="header-right">
             <div class="inbox-container" id="inbox-container">
                <svg id="inbox-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4-8 5-8-5V6l8 5 8-5v2z"/></svg>
                <span id="inbox-notification-dot"></span>
            </div>
            <div class="balance-display">Points: <span id="userBalanceDisplay">0</span></div>
            <button class="menu-toggle-button" id="menu-toggle-button"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>
        </div>
    </header>

    <div class="menu-overlay" id="menu-overlay"></div>
    <aside class="side-menu" id="side-menu">
        <div class="side-menu-header"><h3>Menu</h3><button class="close-menu-btn" id="close-menu-btn">&times;</button></div>
        <ul class="side-menu-nav">
            <li><a href="#" class="nav-link active" data-tab-target="#home-content">Home</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#videos-content">Videos</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#ads-to-earn-content">Ads to Earn</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#task-content">Task to Earn</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#referral-content">Referral Program</a></li>
            <!-- NEW: Leaderboard Menu Item -->
            <li><a href="#" class="nav-link" data-tab-target="#leaderboard-content">Leaderboard</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#withdrawal-content">Withdrawal</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#history-content">History</a></li>
        </ul>
    </aside>

    <main class="container">
        <section id="home-content" class="content-section active"><h3 class="section-title">Trending</h3><div class="item-grid"></div></section>
        <section id="videos-content" class="content-section"><h3 class="section-title">Videos</h3><div class="item-grid"></div></section>
        <section id="ads-to-earn-content" class="content-section"><h3 class="section-title">Watch Ads, Earn Points</h3><div id="ad-task-list" class="item-grid"></div></section>
        <section id="task-content" class="content-section"><h3 class="section-title">Complete Tasks</h3><div id="task-list" class="item-grid"></div></section>
        <section id="referral-content" class="content-section">
            <div class="card">
                <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                <h3>Referral Program</h3>
                <!-- UPDATED: Referral description -->
                <p>Invite friends with your unique link. When your friend earns 500 points by working, you will receive a bonus of <strong>$0.02 USDT!</strong></p>
                <div class="referral-link-wrapper"><input type="text" id="referralLinkInput" readonly value="Generating link..."><button id="copyReferralLinkBtn" class="form-button">Copy</button></div>
            </div>
        </section>
        <!-- NEW: Leaderboard Section -->
        <section id="leaderboard-content" class="content-section">
            <h3 class="section-title">Top Referrers</h3>
            <div class="card" style="text-align: left;">
                <p style="text-align: center;">Here are the top users who have invited the most friends. The weekly top referrer gets an extra bonus!</p>
                <div id="leaderboard-list"></div>
            </div>
        </section>
        <section id="withdrawal-content" class="content-section">
            <div class="card">
                <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>
                <h3>Withdrawal</h3>
                <!-- UPDATED: Display both Point and USDT balance -->
                <p>Your current balance: <strong><span id="withdrawalBalance">0</span> Points</strong></p>
                <p>Your bonus balance: <strong><span id="usdtBalance">0.00</span> USDT</strong></p>
                <div class="conversion-info">Conversion: 1000 Points = $0.02 USD<br>Minimums: 10,000 Points (Bkash) / 25,000 Points (Binance)</div>
                <div id="withdrawalCooldownMessage" class="withdrawal-cooldown-message"><p>You can request a withdrawal once every 7 days.<br>Please try again later.</p></div>
                <form id="withdrawalForm" style="margin-top: 20px;"><div class="form-group"><label for="withdrawalMethod">Payment Method</label><select id="withdrawalMethod" required><option value="Bkash">Bkash</option><option value="Binance (Optimism)">Binance (Optimism)</option></select></div><div class="form-group"><label for="accountDetails">Account Details</label><input type="text" id="accountDetails" placeholder="Your Bkash Number" required></div><div class="form-group"><label for="withdrawalAmount">Amount (Points)</label><input type="number" id="withdrawalAmount" placeholder="10000 - 100000" required step="1" min="10000" max="100000"></div><button type="submit" class="form-button">Request Withdrawal</button></form>
            </div>
             <!-- NEW: USDT to Points Conversion Card -->
            <div class="card" id="usdtConversionCard" style="margin-top: 30px; display: none;">
                <h3>Convert Bonus to Points</h3>
                <p>Convert your USDT bonus into points to use in the app.</p>
                <p>Rate: <strong>$0.01 USDT = 100 Points</strong></p>
                <form id="usdtConversionForm">
                    <div class="form-group">
                        <label for="usdtToConvert">USDT Amount to Convert</label>
                        <input type="number" id="usdtToConvert" placeholder="e.g., 0.02" required step="0.01" min="0.01">
                    </div>
                    <button type="submit" class="form-button">Convert to Points</button>
                </form>
            </div>
        </section>
        <section id="history-content" class="content-section"><h3 class="section-title">Withdrawal History</h3><div id="history-list"></div></section>
    </main>
    
    <div id="successModalOverlay" class="success-modal-overlay"><div class="success-modal"><div class="success-modal-icon">✓</div><h3>Success!</h3><p id="successModalMessage">Your request has been sent.</p></div></div>
    
    <div id="inboxModalOverlay" class="success-modal-overlay">
        <div class="inbox-modal">
            <h3>Inbox</h3>
            <div id="inbox-message-list"><div class="loader"></div></div>
            <button id="closeInboxBtn" class="form-button" style="margin-top: 15px;">Close</button>
        </div>
    </div>
    
    <script type="text/javascript" src="https://cdn.tgads.space/assets/js/adexium-widget.min.js"></script>
    <script src="https://ad.gigapub.tech/script?id=846"></script>
    <script src="https://www.youtube.com/iframe_api" async></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, orderBy, limit, addDoc, serverTimestamp, doc, getDoc, setDoc, updateDoc, runTransaction, increment, arrayUnion, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCKMa4NdIowD_8NioUbrn4L7g5M9y5Tts0",
            authDomain: "movie-zone-931d7.firebaseapp.com",
            projectId: "movie-zone-931d7",
            storageBucket: "movie-zone-931d7.appspot.com",
            messagingSenderId: "1006880112063",
            appId: "1:1006880112063:web:4a4cf5079ea365a6ce750a",
            measurementId: "G-TH1YSE4D9C"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const tg = window.Telegram.WebApp;

        let currentUser = null;
        let player;
        let currentPlayingItem = null;
        let videoPlaybackInterval = null; // NEW: To monitor video time
        const AD_VISIT_LIMIT = 20;
        const DAILY_VIDEO_POINT_LIMIT = 725; // NEW: Daily limit for video points

        // --- NEW: Tiered Video Rewards Configuration ---
        const videoRewardTiers = [
            { time: 30, points: 15, ad: null },
            { time: 60, points: 30, ad: null },
            { time: 300, points: 80, ad: 'Monetag' },
            { time: 600, points: 200, ad: 'GigaPub' },
            { time: 1200, points: 400, ad: 'any' }
        ];

        // --- DATABASE AND STATE MANAGEMENT ---
        async function fetchAndUpdateCurrentUser() {
            if (!currentUser?.id) return;
            const userRef = doc(db, 'users', currentUser.id);
            const userSnap = await getDoc(userRef);
            if (userSnap.exists()) {
                currentUser = { id: userSnap.id, ...userSnap.data() };
                updateBalanceUI(currentUser.balance, currentUser.usdt_balance);
            }
        }
        
        async function checkAndResetDailyLimits() {
            if (!currentUser) return;
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            
            let updates = {};
            
            const lastAdVisitDate = currentUser.lastAdVisitDate?.toDate();
            const lastAdVisitTime = lastAdVisitDate ? new Date(lastAdVisitDate.getFullYear(), lastAdVisitDate.getMonth(), lastAdVisitDate.getDate()).getTime() : 0;
            if (lastAdVisitTime < today) {
                updates.adVisitsToday = 0;
            }

            const lastVideoResetDate = currentUser.lastVideoPointsReset?.toDate();
            const lastVideoResetTime = lastVideoResetDate ? new Date(lastVideoResetDate.getFullYear(), lastVideoResetDate.getMonth(), lastVideoResetDate.getDate()).getTime() : 0;
            if (lastVideoResetTime < today) {
                updates.dailyVideoPointsEarned = 0;
                updates.lastVideoPointsReset = serverTimestamp();
            }

            if (Object.keys(updates).length > 0) {
                const userRef = doc(db, 'users', currentUser.id);
                await updateDoc(userRef, updates);
                Object.assign(currentUser, updates); // Update local state
            }
        }

        async function initializeUser(tgUser, referrerCode) {
            const userRef = doc(db, 'users', String(tgUser.id));
            let userSnap = await getDoc(userRef);
            
            const defaultUserData = {
                balance: 0, 
                usdt_balance: 0, // NEW
                lifetimePointsEarned: 0, // NEW
                referralBonusPaidOut: false, // NEW
                createdAt: serverTimestamp(), 
                completedTasks: [],
                lastWithdrawalRequestAt: null,
                telegramUsername: tgUser.username || 'N/A',
                adVisitsToday: 0,
                lastAdVisitDate: null,
                dailyVideoPointsEarned: 0, // NEW
                lastVideoPointsReset: serverTimestamp() // NEW
            };

            if (!userSnap.exists()) {
                const newUser = { ...defaultUserData };
                if (referrerCode) {
                    newUser.referredBy = referrerCode;
                }
                await setDoc(userRef, newUser);
                currentUser = { id: tgUser.id, ...newUser };
                // NEW: Increment referrer's count
                if (referrerCode) {
                    const referrerRef = doc(db, 'users', referrerCode);
                    await updateDoc(referrerRef, { referralCount: increment(1) }).catch(console.error);
                }
            } else {
                let data = userSnap.data();
                let updates = {};
                // Ensure all new fields exist on old users
                const fieldsToUpdate = {
                    telegramUsername: tgUser.username || 'N/A',
                    usdt_balance: 0, lifetimePointsEarned: 0, referralBonusPaidOut: false,
                    adVisitsToday: 0, dailyVideoPointsEarned: 0, referralCount: 0
                };
                for (const [key, value] of Object.entries(fieldsToUpdate)) {
                    if (!data.hasOwnProperty(key)) updates[key] = value;
                }
                if (data.telegramUsername !== tgUser.username) updates.telegramUsername = tgUser.username || 'N/A';
                
                if (Object.keys(updates).length > 0) {
                    await updateDoc(userRef, updates);
                    data = {...data, ...updates};
                }
                currentUser = { id: userSnap.id, ...data };
            }
            if (!currentUser.completedTasks) currentUser.completedTasks = [];
            
            await checkAndResetDailyLimits(); 
            
            updateBalanceUI(currentUser.balance, currentUser.usdt_balance);
            generateReferralLink(currentUser.id);
            checkForUnreadMessages();
        }
        
        function updateBalanceUI(balance, usdtBalance = 0) {
            const points = Math.floor(balance || 0);
            document.getElementById('userBalanceDisplay').textContent = points;
            document.getElementById('withdrawalBalance').textContent = points;
            document.getElementById('usdtBalance').textContent = (usdtBalance || 0).toFixed(2);
            // NEW: Show/hide USDT conversion card
            const conversionCard = document.getElementById('usdtConversionCard');
            if(usdtBalance > 0) {
                conversionCard.style.display = 'block';
                document.getElementById('usdtToConvert').max = usdtBalance;
            } else {
                conversionCard.style.display = 'none';
            }
        }

        function generateReferralLink(userId) {
            document.getElementById('referralLinkInput').value = `https://t.me/NewTube12_bot?start=${userId}`;
        }
        
        document.getElementById('copyReferralLinkBtn').addEventListener('click', () => {
            const copyButton = document.getElementById('copyReferralLinkBtn');
            navigator.clipboard.writeText(copyButton.previousElementSibling.value).then(() => {
                copyButton.textContent = 'Copied!';
                if (tg && tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
            });
        });

        // --- NEW: Centralized Point Granting & Referral Bonus Logic ---
        async function grantPoints(amount, source) {
            if (amount <= 0) return;

            let pointsToGrant = amount;
            let updates = {};

            // Check daily video limit
            if (source === 'video') {
                const currentVideoPoints = currentUser.dailyVideoPointsEarned || 0;
                if (currentVideoPoints >= DAILY_VIDEO_POINT_LIMIT) {
                    console.log("Daily video point limit reached.");
                    return 0; // No points to grant
                }
                if (currentVideoPoints + amount > DAILY_VIDEO_POINT_LIMIT) {
                    pointsToGrant = DAILY_VIDEO_POINT_LIMIT - currentVideoPoints;
                }
                updates.dailyVideoPointsEarned = increment(pointsToGrant);
            }
            
            updates.balance = increment(pointsToGrant);
            updates.lifetimePointsEarned = increment(pointsToGrant);

            const userRef = doc(db, 'users', currentUser.id);
            await updateDoc(userRef, updates);
            
            // Check for referral bonus eligibility after granting points
            const newLifetimePoints = (currentUser.lifetimePointsEarned || 0) + pointsToGrant;
            if (currentUser.referredBy && !currentUser.referralBonusPaidOut && newLifetimePoints >= 500) {
                await awardReferralBonus();
            }

            await fetchAndUpdateCurrentUser();
            return pointsToGrant;
        }
        
        async function awardReferralBonus() {
             const userRef = doc(db, 'users', currentUser.id);
             const referrerRef = doc(db, 'users', currentUser.referredBy);
             
             try {
                await runTransaction(db, async (transaction) => {
                    const userSnap = await transaction.get(userRef);
                    if (userSnap.data().referralBonusPaidOut) return; // Already paid

                    transaction.update(referrerRef, { usdt_balance: increment(0.02) });
                    transaction.update(userRef, { referralBonusPaidOut: true });
                });
                console.log("Referral bonus awarded to " + currentUser.referredBy);
                // No need to fetch user data here, the referrer got the bonus, not the current user.
             } catch (e) {
                console.error("Failed to award referral bonus:", e);
             }
        }
        
        // --- CONTENT (VIDEOS) ---
        // COMPLETELY REWRITTEN VIDEO LOGIC
        async function fetchContent(targetId, category) {
            const grid = document.querySelector(`${targetId} .item-grid`);
            if (!grid) return;
            grid.innerHTML = '<div class="loader"></div>';
            try {
                const videosCollection = collection(db, 'videos');
                const q = category === 'Home' 
                    ? query(videosCollection, orderBy('createdAt', 'desc'), limit(20))
                    : query(videosCollection, orderBy('createdAt', 'desc'));
                
                const snapshot = await getDocs(q);
                grid.innerHTML = ''; 
                if (snapshot.empty) { grid.innerHTML = '<p style="text-align:center;">No content found.</p>'; return; }
                
                for (const docSnap of snapshot.docs) {
                    const video = docSnap.data();
                    const videoId = docSnap.id;
                    
                    const progressRef = doc(db, 'users', currentUser.id, 'videoProgress', videoId);
                    const progressSnap = await getDoc(progressRef);
                    const progress = progressSnap.exists() ? progressSnap.data() : { totalPoints: 0 };
                    
                    const item = document.createElement('article');
                    item.className = 'movie-item';
                    item.dataset.youtubeId = video.youtubeId;
                    item.dataset.videoId = videoId;

                    const rewardText = `Earn up to ${DAILY_VIDEO_POINT_LIMIT} Points`;
                    const earnedText = `Earned: ${progress.totalPoints} / ${DAILY_VIDEO_POINT_LIMIT}`;

                    item.originalContent = `
                        <div class="thumbnail-container">
                            <img src="${video.thumbnailUrl}" alt="${video.title}" loading="lazy">
                            <div class="video-progress-bar-container">
                                <div class="video-progress-bar" style="width: ${(progress.totalPoints / DAILY_VIDEO_POINT_LIMIT) * 100}%"></div>
                            </div>
                        </div>
                        <div class="movie-item-info">
                            <h4>${video.title}</h4>
                            <p class="movie-reward">${earnedText}</p>
                        </div>`;
                    item.innerHTML = item.originalContent;
                    item.addEventListener('click', handleVideoClick);
                    grid.appendChild(item);
                }
            } catch (error) { console.error("Error fetching content:", error); grid.innerHTML = '<p>Error loading content.</p>'; }
        }

        async function handleVideoClick(event) {
            if (!currentUser) { alert("User data not loaded yet."); return; }

            // Stop any currently playing video and monitoring
            if (currentPlayingItem) {
                clearInterval(videoPlaybackInterval);
                currentPlayingItem.innerHTML = currentPlayingItem.originalContent;
                if (player) { player.destroy(); player = null; }
            }
            
            const clickedItem = event.currentTarget;
            if (currentPlayingItem === clickedItem) {
                currentPlayingItem = null;
                return; // Clicking the same item again closes it
            }

            currentPlayingItem = clickedItem;
            const { youtubeId, videoId } = clickedItem.dataset;

            const playerDivId = `player-${youtubeId}-${Date.now()}`;
            clickedItem.innerHTML = `<div id="${playerDivId}" class="player-container"></div>`;
            player = new YT.Player(playerDivId, {
                height: '100%', width: '100%', videoId: youtubeId,
                playerVars: { 'autoplay': 1, 'controls': 1, 'rel': 0 },
                events: {
                    'onReady': (e) => {
                        e.target.playVideo();
                        startVideoMonitoring(videoId);
                    },
                    'onStateChange': (e) => {
                         if (e.data === YT.PlayerState.PAUSED || e.data === YT.PlayerState.ENDED) {
                            clearInterval(videoPlaybackInterval);
                        } else if (e.data === YT.PlayerState.PLAYING) {
                            startVideoMonitoring(videoId);
                        }
                    }
                }
            });
        }
        
        function startVideoMonitoring(videoId) {
            clearInterval(videoPlaybackInterval); // Clear any existing interval
            videoPlaybackInterval = setInterval(async () => {
                if (!player || typeof player.getCurrentTime !== 'function') return;
                const currentTime = player.getCurrentTime();
                checkVideoTiers(videoId, currentTime);
            }, 5000); // Check every 5 seconds
        }

        async function checkVideoTiers(videoId, currentTime) {
            const progressRef = doc(db, 'users', currentUser.id, 'videoProgress', videoId);
            const progressSnap = await getDoc(progressRef);
            const progress = progressSnap.exists() ? progressSnap.data() : { claimedTiers: [], totalPoints: 0 };
            
            for (let i = 0; i < videoRewardTiers.length; i++) {
                const tier = videoRewardTiers[i];
                if (currentTime >= tier.time && !progress.claimedTiers.includes(tier.time)) {
                    
                    // Grant points
                    const pointsGranted = await grantPoints(tier.points, 'video');
                    
                    if (pointsGranted > 0) {
                        // Trigger ad if configured
                        if(tier.ad === 'Monetag') showMonetagAd().catch(console.error);
                        if(tier.ad === 'GigaPub') showGigaPubAd().catch(console.error);
                        if(tier.ad === 'any') [showMonetagAd, showGigaPubAd, showAdexiumAd][Math.floor(Math.random()*3)]();

                        // Update progress in Firestore
                        const newTotalPoints = (progress.totalPoints || 0) + pointsGranted;
                        const newClaimedTiers = [...(progress.claimedTiers || []), tier.time];
                        await setDoc(progressRef, { totalPoints: newTotalPoints, claimedTiers: newClaimedTiers }, { merge: true });
                        
                        console.log(`Claimed tier ${tier.time}s for ${pointsGranted} points.`);
                        if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');

                        // Optimistically update the UI without a full reload
                        const progressBar = currentPlayingItem?.querySelector('.video-progress-bar');
                        const rewardText = currentPlayingItem?.querySelector('.movie-reward');
                        if(progressBar) progressBar.style.width = `${(newTotalPoints / DAILY_VIDEO_POINT_LIMIT) * 100}%`;
                        if(rewardText) rewardText.textContent = `Earned: ${newTotalPoints} / ${DAILY_VIDEO_POINT_LIMIT}`;
                    }

                    // Must break after claiming a tier to wait for the next interval
                    break;
                }
            }
        }
        
        async function stopAndClearVideo() {
            if (videoPlaybackInterval) clearInterval(videoPlaybackInterval);
            if (currentPlayingItem) {
                currentPlayingItem.innerHTML = currentPlayingItem.originalContent;
            }
            if (player) {
                player.destroy();
                player = null;
            }
            currentPlayingItem = null;
            videoPlaybackInterval = null;
        }

        // --- ADS TO EARN ---
        const showMonetagAd = () => new Promise((res, rej) => typeof show_9442539 === 'function' ? show_9442539().then(res).catch(rej) : rej('SDK missing'));
        const showGigaPubAd = () => new Promise((res, rej) => typeof window.showGiga === 'function' ? window.showGiga().then(res).catch(rej) : rej('SDK missing'));
        const showAdexiumAd = () => new Promise((res, rej) => { try { new AdexiumWidget({wid: '165512cc-372e-4fb0-98d2-552219c72799', adFormat: 'interstitial'}).init(); setTimeout(res, 3000); } catch(e){rej(e);} });

        function setupAdsToEarn() {
            const adTaskListContainer = document.getElementById('ad-task-list');
            adTaskListContainer.innerHTML = '';
            const visitsToday = currentUser.adVisitsToday || 0;
            const visitsLeft = AD_VISIT_LIMIT - visitsToday;
            const isLimitReached = visitsLeft <= 0;

            [1, 2].forEach(() => {
                const card = document.createElement('div');
                card.className = 'ad-task-card';
                card.innerHTML = `<div class="ad-task-card-info"><h4>Watch Ad & Earn</h4><p>Reward: 50 Points</p><p class="ad-visits-left">Today's Visits Left: ${visitsLeft > 0 ? visitsLeft : 0}</p></div><button class="ad-task-button" ${isLimitReached ? 'disabled' : ''}>${isLimitReached ? 'Daily Limit Reached' : 'Watch Ad'}</button>`;
                adTaskListContainer.appendChild(card);
            });
        }

        document.getElementById('ad-task-list').addEventListener('click', async (e) => {
            if (!e.target.matches('.ad-task-button') || e.target.disabled) return;
            const button = e.target;
            button.disabled = true;
            button.textContent = 'Loading Ad...';

            showMonetagAd().then(async () => {
                if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                try {
                    await grantPoints(50, 'ad'); // Use grantPoints
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, { adVisitsToday: increment(1), lastAdVisitDate: serverTimestamp() });
                    await fetchAndUpdateCurrentUser();
                    setupAdsToEarn(); 
                    showSuccessModal("Congratulations!", "You've earned 50 points.");
                } catch (error) { console.error("Ad task reward error:", error); setupAdsToEarn(); }
            }).catch(err => { console.log('Ad not shown:', err); alert('You need to watch the ad to earn points.'); setupAdsToEarn(); });
        });

        // --- TASKS TO EARN ---
        async function fetchTasks() { /* ... unchanged ... */ }
        document.getElementById('task-list').addEventListener('click', async (e) => { /* ... modified to use grantPoints ... */
             if (!e.target.matches('.task-button') || e.target.disabled) return;
            const button = e.target;
            const { taskId, taskUrl, reward, state } = button.dataset;

            if (state === 'start') {
                if (!taskUrl) { alert('Task URL is missing.'); return; }
                tg.openLink(taskUrl);
                button.textContent = 'Claim Reward';
                button.dataset.state = 'claim';
                if (tg.HapticFeedback) tg.HapticFeedback.impactOccurred('light');
            } else if (state === 'claim') {
                button.disabled = true;
                button.textContent = 'Verifying...';
                try {
                    await runTransaction(db, async (transaction) => {
                        const userRef = doc(db, 'users', currentUser.id);
                        const taskRef = doc(db, 'tasks', taskId);
                        const [userDoc, taskDoc] = await Promise.all([transaction.get(userRef), transaction.get(taskRef)]);
                        if (!userDoc.exists() || !taskDoc.exists()) throw "User or Task not found.";
                        const taskData = taskDoc.data();
                        if (userDoc.data().completedTasks?.includes(taskId)) throw "ALREADY_COMPLETED";
                        if ((taskData.limit > 0) && (taskData.completionCount >= taskData.limit)) throw "TASK_LIMIT_REACHED";
                        
                        // Use grantPoints here, but within the transaction context it's tricky.
                        // We will add to balance and lifetime points manually in the transaction.
                        const pointsToGrant = Number(reward);
                        transaction.update(userRef, { 
                            balance: increment(pointsToGrant), 
                            lifetimePointsEarned: increment(pointsToGrant),
                            completedTasks: arrayUnion(taskId) 
                        });
                        transaction.update(taskRef, { completionCount: increment(1) });
                    });
                    
                    await fetchAndUpdateCurrentUser(); // This will handle the referral check
                    showSuccessModal("Reward Claimed!", `${reward} points have been added to your balance.`);
                    if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                    button.textContent = 'Done';
                } catch (error) {
                    const message = { "ALREADY_COMPLETED": "You have already completed this task.", "TASK_LIMIT_REACHED": "This task has reached its completion limit." }[error] || 'Failed to claim reward. Please try again.';
                    alert(message);
                    button.textContent = (error === "ALREADY_COMPLETED" || error === "TASK_LIMIT_REACHED") ? 'Done' : 'Claim Reward';
                    button.disabled = (error !== 'Failed to claim reward. Please try again.');
                }
            }
        });

        // --- WITHDRAWAL & CONVERSION ---
        function showSuccessModal(title, message) {
            document.getElementById('successModalOverlay').classList.add('show');
            document.querySelector('#successModalOverlay h3').textContent = title;
            document.querySelector('#successModalOverlay p').textContent = message;
            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
            setTimeout(() => { document.getElementById('successModalOverlay').classList.remove('show'); }, 3000);
        }
        
        // NEW: USDT to Points Conversion Logic
        document.getElementById('usdtConversionForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const button = e.target.querySelector('button');
            const amountToConvert = parseFloat(document.getElementById('usdtToConvert').value);

            if (isNaN(amountToConvert) || amountToConvert <= 0 || amountToConvert > currentUser.usdt_balance) {
                alert("Invalid amount.");
                return;
            }

            button.disabled = true;
            button.textContent = "Converting...";

            const pointsToAdd = Math.floor(amountToConvert * 10000); // $0.01 = 100 points => $1 = 10000 points
            const userRef = doc(db, 'users', currentUser.id);

            try {
                await updateDoc(userRef, {
                    usdt_balance: increment(-amountToConvert),
                    balance: increment(pointsToAdd)
                });
                await fetchAndUpdateCurrentUser();
                e.target.reset();
                showSuccessModal("Conversion Successful!", `${pointsToAdd} points have been added to your balance.`);
            } catch (error) {
                console.error("Conversion error:", error);
                alert("Failed to convert. Please try again.");
            } finally {
                button.disabled = false;
                button.textContent = "Convert to Points";
            }
        });

        document.getElementById('withdrawalForm').addEventListener('submit', async (e) => { /* ... unchanged logic, but uses custom success modal ... */
            e.preventDefault();
            const submitButton = e.target.querySelector('button[type="submit"]');
            if (!checkWithdrawalEligibility()) { alert("You have already made a withdrawal request this week."); return; }
            
            const method = document.getElementById('withdrawalMethod').value;
            const amount = parseInt(document.getElementById('withdrawalAmount').value, 10);
            const minAmount = (method === 'Bkash') ? 10000 : 25000;

            if (amount < minAmount) { alert(`Minimum withdrawal for ${method} is ${minAmount} points.`); return; }
            if (amount > currentUser.balance) { alert("Insufficient balance."); return; }
            
            submitButton.disabled = true; submitButton.textContent = 'Processing...';
            
            const usdAmount = (amount / 1000) * 0.02;
            const requestData = { userId: currentUser.id, telegramUsername: currentUser.telegramUsername, pointsAmount: amount, usdAmount: usdAmount.toFixed(2), method, details: document.getElementById('accountDetails').value, status: 'pending', createdAt: serverTimestamp() };
            
            try {
                await runTransaction(db, async (transaction) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await transaction.get(userRef);
                    if (!userDoc.exists() || userDoc.data().balance < amount) throw new Error("Insufficient balance.");
                    transaction.set(doc(collection(db, 'withdrawals')), requestData);
                    transaction.update(userRef, { balance: increment(-amount), lastWithdrawalRequestAt: serverTimestamp() });
                });
                
                await fetchAndUpdateCurrentUser();
                e.target.reset();
                showSuccessModal("Successfully Sent!", "Your withdrawal request is pending. ✅");
                setTimeout(() => document.querySelector('.nav-link[data-tab-target="#history-content"]').click(), 3100);
                checkWithdrawalEligibility();
            } catch (error) {
                console.error("Withdrawal Error:", error);
                alert(`An error occurred: ${error.message || "Please try again."}`);
            } finally {
                submitButton.disabled = false; submitButton.textContent = 'Request Withdrawal';
            }
        });
        function checkWithdrawalEligibility() { /* ... unchanged ... */ }
        async function displayWithdrawalHistory() { /* ... unchanged ... */ }
        
        // --- NEW: LEADERBOARD ---
        async function fetchLeaderboard() {
            const listContainer = document.getElementById('leaderboard-list');
            listContainer.innerHTML = '<div class="loader"></div>';

            try {
                const q = query(collection(db, "users"), orderBy("referralCount", "desc"), limit(20));
                const snapshot = await getDocs(q);
                listContainer.innerHTML = '';
                if (snapshot.empty) {
                    listContainer.innerHTML = '<p style="text-align:center;">Leaderboard is empty.</p>';
                    return;
                }
                
                let rank = 1;
                snapshot.forEach(docSnap => {
                    const user = docSnap.data();
                    if (user.referralCount > 0) {
                         const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        item.innerHTML = `
                            <div class="rank">#${rank}</div>
                            <div class="info">
                                <strong>${user.telegramUsername || 'User ' + docSnap.id.substring(0, 5)}</strong>
                            </div>
                            <div class="count">${user.referralCount} Referrals</div>
                        `;
                        listContainer.appendChild(item);
                        rank++;
                    }
                });
            } catch (error) {
                console.error("Error fetching leaderboard:", error);
                listContainer.innerHTML = '<p style="color:red; text-align:center;">Could not load leaderboard.</p>';
            }
        }


        // --- INBOX/MESSAGING ---
        async function checkForUnreadMessages() { /* ... unchanged ... */ }
        document.getElementById('inbox-container').addEventListener('click', async () => { /* ... unchanged ... */ });
        document.getElementById('closeInboxBtn').addEventListener('click', () => { /* ... unchanged ... */ });

        // --- NAVIGATION AND INITIALIZATION ---
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', async (e) => {
                e.preventDefault();
                
                stopAndClearVideo(); // NEW: Clear video player on navigation

                document.querySelectorAll('.nav-link, .content-section').forEach(el => el.classList.remove('active'));
                link.classList.add('active');
                const targetId = link.dataset.tabTarget;
                const target = document.querySelector(targetId);
                if(target) target.classList.add('active');

                // Load content for the new tab
                switch(targetId) {
                    case '#home-content': fetchContent(targetId, 'Home'); break;
                    case '#videos-content': fetchContent(targetId, 'Videos'); break;
                    case '#ads-to-earn-content': setupAdsToEarn(); break;
                    case '#task-content': fetchTasks(); break;
                    case '#leaderboard-content': fetchLeaderboard(); break; // NEW
                    case '#withdrawal-content': checkWithdrawalEligibility(); break;
                    case '#history-content': displayWithdrawalHistory(); break;
                }
                document.getElementById('side-menu').classList.remove('is-open');
                document.getElementById('menu-overlay').classList.remove('is-open');
            });
        });

        function initializeAdexium() { /* ... unchanged ... */ }

        async function init() {
            if (!tg.initDataUnsafe?.user) {
                document.body.innerHTML = `<div class="card" style="margin-top: 50px;"><h3>Error</h3><p>This application can only be launched from Telegram.</p></div>`;
                return;
            }
            tg.ready();
            tg.expand();
            
            await initializeUser(tg.initDataUnsafe.user, tg.initDataUnsafe.start_param);
            document.querySelector('.nav-link[data-tab-target="#home-content"]').click();
            initializeAdexium();

            const menuToggleBtn = document.getElementById('menu-toggle-button'), closeMenuBtn = document.getElementById('close-menu-btn'), sideMenu = document.getElementById('side-menu'), menuOverlay = document.getElementById('menu-overlay');
            const toggleMenu = () => { sideMenu.classList.toggle('is-open'); menuOverlay.classList.toggle('is-open'); };
            [menuToggleBtn, closeMenuBtn, menuOverlay].forEach(el => el.addEventListener('click', toggleMenu));
        }
        
        init();
    </script>
</body>
</html>