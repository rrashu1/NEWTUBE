<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEWTUBE - Watch & Earn</title>
    <script src="https://telegram.org/js/telegram-web-app.js?56"></script>
    
    <!-- Monetag Ads Library -->
    <script src='//libtl.com/sdk.js' data-zone='9442539' data-sdk='show_9442539'></script>
    <!-- GigaPub Ads SDK -->
    <script src="https://ad.gigapub.tech/script?id=846"></script>
    <!-- Adexium Ads SDK (New) -->
    <script type="text/javascript" src="https://cdn.tgads.space/assets/js/adexium-widget.min.js"></script>
    <!-- Fonts for Lottery -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Hind+Siliguri:wght@400;600;700&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">


    <style>
        :root {
            --primary-accent-color: #007BFF; 
            --primary-accent-hover-color: #0056b3; 
            --dark-bg: #000000;
            --card-bg: #1a1a1a; --header-bg: #181818; --text-light: #ffffff; --text-muted: #b3b3b3;
            --border-color: #282828; --success-color: #28a745; --disabled-color: #444;
        }
        body { background-color: var(--dark-bg); color: var(--text-light); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; padding: 60px 0 0; }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }
        .main-header { background-color: var(--header-bg); padding: 10px 15px; border-bottom: 1px solid var(--border-color); position: fixed; top: 0; left: 0; right: 0; z-index: 1000; display: flex; justify-content: space-between; align-items: center; height: 40px; }
        .site-title-container { display: flex; flex-direction: column; align-items: flex-start; }
        .site-title { font-size: 1.2em; color: var(--primary-accent-color); font-weight: 700; text-transform: uppercase; margin: 0; padding: 0; line-height: 1; }
        .user-id-container { display: flex; align-items: center; gap: 8px; cursor: pointer; margin-top: 1px; }
        .user-id-display { font-size: 0.7em; color: var(--text-muted); font-weight: normal; }
        .copy-user-id-btn { background: none; border: none; padding: 0; display: flex; align-items: center; justify-content: center; color: var(--text-muted); }
        .copy-user-id-btn svg { width: 12px; height: 12px; }
        .user-id-container:hover .user-id-display, .user-id-container:hover .copy-user-id-btn { color: var(--text-light); }
        
        .header-right { display: flex; align-items: center; gap: 10px; }
        .inbox-container { position: relative; cursor: pointer; }
        #inbox-icon { width: 24px; height: 24px; color: var(--text-light); }
        #inbox-notification-dot { position: absolute; top: -2px; right: -2px; width: 8px; height: 8px; background-color: var(--primary-accent-color); border-radius: 50%; border: 1px solid var(--header-bg); display: none; }
        #inbox-notification-dot.visible { display: block; }
        .balance-display { background-color: #2a2a2a; color: var(--primary-accent-color); padding: 5px 12px; border-radius: 20px; font-weight: bold; font-size: 0.9em; }
        .menu-toggle-button { background: none; border: none; cursor: pointer; padding: 5px; display: flex; flex-direction: column; gap: 4px; }
        .menu-toggle-button .bar { width: 22px; height: 2px; background-color: var(--text-light); border-radius: 2px; }
        .side-menu { position: fixed; top: 0; right: -100%; width: 250px; height: 100%; background-color: var(--header-bg); z-index: 1001; transition: right 0.3s ease-in-out; display: flex; flex-direction: column; }
        .side-menu.is-open { right: 0; }
        .side-menu-header { padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        .side-menu-header h3 { margin: 0; } .close-menu-btn { background: none; border: none; font-size: 1.5em; color: var(--text-light); cursor: pointer; }
        .side-menu-nav { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; }
        .side-menu-nav a { display: block; padding: 15px 20px; color: var(--text-muted); text-decoration: none; font-weight: 500; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s, color 0.2s; }
        .side-menu-nav a:hover, .side-menu-nav a.active { background-color: var(--primary-accent-color); color: var(--text-light); }
        .menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: none; }
        .menu-overlay.is-open { display: block; }
        .content-section { display: none; padding-top: 25px; } .content-section.active { display: block; }
        .section-title { font-size: 1.5em; margin-bottom: 20px; padding-bottom: 10px; color: var(--text-light); border-bottom: 2px solid var(--border-color); }
        .search-container { display: flex; gap: 10px; margin-bottom: 20px; }
        .search-container input { flex-grow: 1; padding: 10px; box-sizing: border-box; border-radius: 8px; border: 1px solid var(--border-color); background-color: #000; color: var(--text-light); font-size: 1em; }
        .search-container button { padding: 10px 15px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: var(--text-light); font-weight: bold; cursor: pointer; }
        .search-container button#clearSearchBtn { background-color: #444; }
        .item-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
        .movie-item, .task-card, .ad-task-card, .daily-task-card { background-color: var(--card-bg); border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; }
        .movie-item { cursor: pointer; transition: transform 0.2s; } .movie-item:hover{ transform: scale(1.03); }
        .thumbnail-container { width: 100%; aspect-ratio: 16/9; background-color: #333; position: relative; }
        .thumbnail-container img { width: 100%; height: 100%; object-fit: cover; }
        .player-container { width: 100%; aspect-ratio: 16/9; background: #000; }
        .player-container iframe { width: 100%; height: 100%; border: none; }
        .movie-item-info, .task-card-info, .ad-task-card-info { padding: 15px; flex-grow: 1; text-align:center;}
        .movie-item-info h4, .task-card h4, .ad-task-card h4 { margin: 0 0 8px; font-size: 1.1em; line-height: 1.3; }
        .movie-reward, .ad-visits-left { color: var(--success-color); font-weight: bold; font-size: 0.9em; margin: 0; }
        .task-card p, .ad-task-card p { margin: 8px 0 15px; color: var(--text-muted); font-weight: bold; }
        .task-reward-points { color: var(--success-color); }
        .task-reward-pg { color: #ff9900; } /* Orange for PG Coin */
        .task-button, .ad-task-button, .daily-task-button { width: 100%; padding: 12px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; background-color: var(--primary-accent-color); color: var(--text-light); transition: background-color .2s; margin-top: auto; font-size: 1em;}
        .task-button:disabled, .ad-task-button:disabled, .daily-task-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        .card { max-width: 500px; margin: 20px auto; background-color: var(--card-bg); padding: 25px; border-radius: 12px; border: 1px solid var(--border-color); text-align: center; }
        .card-icon { width: 50px; height: 50px; margin: 0 auto 15px; color: var(--primary-accent-color); }
        .card h3 { margin-top: 0; font-size: 1.4em; } .card p { color: var(--text-muted); line-height: 1.6; }
        .form-group { margin-bottom: 15px; text-align: left; }
        .form-group label { display: block; margin-bottom: 5px; font-weight: 500; color: var(--text-muted); }
        .form-group input, .form-group select { width: 100%; padding: 12px; box-sizing: border-box; border-radius: 8px; border: 1px solid var(--border-color); background-color: #000; color: var(--text-light); font-size: 1em; }
        .form-button { width: 100%; padding: 12px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: var(--text-light); font-weight: bold; font-size: 1em; cursor: pointer; transition: background-color 0.2s; }
        .form-button:hover:not(:disabled) { background-color: var(--primary-accent-hover-color); }
        .form-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        .referral-link-wrapper { display: flex; gap: 10px; margin-top: 20px; }
        .referral-link-wrapper input { flex-grow: 1; text-align: center; }
        .referral-link-wrapper button { width: auto; flex-shrink: 0; padding: 0 15px; }
        .loader { border: 4px solid var(--border-color); border-top: 4px solid var(--primary-accent-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 50px auto; }
        .history-item, .leaderboard-item { background-color: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .leaderboard-item .rank { font-size: 1.2em; font-weight: bold; color: var(--primary-accent-color); min-width: 40px; text-align: center;}
        .leaderboard-item .info { flex-grow: 1; margin-left: 15px; }
        .leaderboard-item .info strong { color: var(--text-light); }
        .leaderboard-item .info small { color: var(--text-muted); }
        .leaderboard-item .count { font-size: 1.1em; font-weight: bold; color: var(--success-color); }
        .claim-referral-btn { padding: 8px 12px; font-size: 0.9em; width: auto; flex-shrink: 0; }
        .history-item .status-pending { color: #ffc107; } .history-item .status-approved { color: #28a745; } .history-item .status-rejected { color: #dc3545; }
        .conversion-info { font-size: 0.9em; color: var(--text-muted); margin-bottom: 15px; }
        .success-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .success-modal-overlay.show { display: flex; }
        .success-modal { background-color: var(--card-bg); color: var(--text-light); padding: 30px 40px; border-radius: 15px; text-align: center; transform: scale(0.9); opacity: 0; animation: modal-pop-in 0.3s forwards; }
        .success-modal-icon { width: 70px; height: 70px; border-radius: 50%; background-color: var(--success-color); display: flex; justify-content: center; align-items: center; font-size: 40px; font-weight: bold; color: white; margin: 0 auto 20px; animation: icon-pop-in 0.5s 0.2s backwards; }
        .success-modal h3 { margin: 0 0 10px; font-size: 1.6em; }
        .success-modal p { margin: 0; color: var(--text-muted); font-size: 1em;}
        .inbox-modal { background-color: var(--card-bg); color: var(--text-light); padding: 20px; border-radius: 15px; text-align: left; width: 90%; max-width: 400px; max-height: 80vh; display: flex; flex-direction: column; }
        .inbox-modal h3 { text-align: center; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        #inbox-message-list { overflow-y: auto; flex-grow: 1; margin-bottom: 15px; }
        .inbox-message-item { background-color: #2a2a2a; padding: 12px; border-radius: 8px; margin-bottom: 10px; }
        .inbox-message-item p { margin: 0; line-height: 1.5; }
        .inbox-message-item small { color: var(--text-muted); font-size: 0.8em; }
        #closeInboxBtn { padding: 10px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: white; cursor: pointer; }
        .sub-card { background-color: #222; padding: 20px; border-radius: 10px; margin-bottom: 25px; }
        .info-text { font-size: 0.9em; color: var(--text-muted); margin-top: 10px; }
        .daily-task-card { padding: 15px; flex-direction: row; justify-content: space-between; align-items: center; }
        .daily-task-info { text-align: left; }
        .daily-task-info h4 { margin: 0 0 5px; }
        .daily-task-info p { margin: 0; font-size: 0.9em; color: var(--success-color); }
        .daily-task-button { width: auto; flex-shrink: 0; padding: 10px 20px; font-size: 0.9em; }
        .task-category-selector { display: flex; justify-content: center; margin-bottom: 25px; border-bottom: 2px solid #282828; padding-bottom: 15px; }
        .task-category-selector .task-category-btn { background-color: transparent; border: 2px solid var(--primary-accent-color); color: var(--primary-accent-color); padding: 10px 20px; margin: 0 5px; border-radius: 25px; font-size: 1rem; font-weight: bold; cursor: pointer; transition: all 0.3s ease; }
        .task-category-selector .task-category-btn.active, .task-category-selector .task-category-btn:hover { background-color: var(--primary-accent-color); color: white; }
        .task-category-container { display: none; } .task-category-container.active { display: block; }
        
        /* Profile Section Styles */
        #profile-card { background-color: var(--card-bg); padding: 30px; border-radius: 15px; text-align: center; }
        #profile-avatar { 
            width: 100px; height: 100px; border-radius: 50%; 
            border: 4px solid var(--primary-accent-color); 
            margin: 0 auto 20px; 
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            font-size: 48px;
            font-weight: bold;
            color: var(--text-light);
            background-size: cover;
            background-position: center;
        }
        #profile-username { font-size: 1.8em; font-weight: bold; margin: 0 0 10px; }
        #profile-userid { font-size: 1em; color: var(--text-muted); margin-bottom: 25px; }
        #profile-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .profile-stat-item { background-color: #222; padding: 20px; border-radius: 10px; }
        .profile-stat-item h4 { margin: 0 0 8px; font-size: 1em; color: var(--text-muted); }
        .profile-stat-item p { margin: 0; font-size: 1.4em; font-weight: bold; color: var(--primary-accent-color); }

        /* Lottery Section Styles */
        .lottery-container { background-color: var(--card-bg); padding: 25px; border-radius: 12px; text-align: center; width: 100%; max-width: 450px; margin: 0 auto; }
        .lottery-container h1 { font-family: 'Hind Siliguri', sans-serif; }
        #lottery-result-display { font-family: 'Roboto Mono', monospace; font-size: 3.5rem; font-weight: 700; color: #0056b3; background-color: #e7f3ff; padding: 15px; border-radius: 8px; margin-bottom: 25px; min-height: 80px; display: flex; justify-content: center; align-items: center; transition: all 0.3s ease; }
        #lottery-result-display.tier-1 { color: #333; background-color: #f0f0f0; }
        #lottery-result-display.tier-2 { color: #1e8449; background-color: #eafaf1; }
        #lottery-result-display.tier-3 { color: #2980b9; background-color: #eaf2f8; }
        #lottery-result-display.tier-4 { color: #884ea0; background-color: #f4eef7; }
        #lottery-result-display.tier-5 { color: #d35400; background-color: #fbeee6; border: 2px solid #d35400;}
        #lottery-result-display.tier-6 { color: #c0392b; background-color: #f9ebea; border: 2px solid #c0392b; text-shadow: 0 0 5px #ffdddd;}
        .lottery-button { background-color: var(--primary-accent-color); color: white; border: none; padding: 12px 20px; font-size: 1rem; font-weight: 600; border-radius: 8px; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease; width: 100%; margin-top: 15px; }
        .lottery-button:hover:not(:disabled) { background-color: var(--primary-accent-hover-color); }
        .lottery-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        #lottery-info { color: var(--text-muted); font-size: 0.9rem; margin-top: 15px; min-height: 20px; }


        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes modal-pop-in { to { transform: scale(1); opacity: 1; } }
        @keyframes icon-pop-in { 0% { transform: scale(0); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <header class="main-header">
        <div class="site-title-container">
            <h1 class="site-title">NEWTUBE</h1>
            <div class="user-id-container" id="userIdContainer">
                <span id="userIdDisplay" class="user-id-display"></span>
                <button class="copy-user-id-btn" title="Copy User ID">
                    <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><path fill="currentColor" d="M384 336H192c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16l140.1 0L400 115.9V320c0 8.8-7.2 16-16 16zM192 384H384c35.3 0 64-28.7 64-64V115.9c0-12.7-5.1-24.9-14.1-33.9L366.1 14.1c-9-9-21.2-14.1-33.9-14.1H192c-35.3 0-64 28.7-64 64V320c0 35.3 28.7 64 64 64zM64 128c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H256c35.3 0 64-28.7 64-64V416H272v32c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V192c0-8.8 7.2-16 16-16H96V128H64z"/></svg>
                </button>
            </div>
        </div>
        <div class="header-right">
             <div class="inbox-container" id="inbox-container">
                <svg id="inbox-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4-8 5-8-5V6l8 5 8-5v2z"/></svg>
                <span id="inbox-notification-dot"></span>
            </div>
            <div class="balance-display">$: <span id="userUSDTBalanceDisplay">0.00</span></div>
            <div class="balance-display">Pts: <span id="userBalanceDisplay">0</span></div>
            <div class="balance-display">PG: <span id="userPgCoinDisplay">0.000</span></div>
            <button class="menu-toggle-button" id="menu-toggle-button"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>
        </div>
    </header>

    <div class="menu-overlay" id="menu-overlay"></div>
    <aside class="side-menu" id="side-menu">
        <div class="side-menu-header"><h3>Menu</h3><button class="close-menu-btn" id="close-menu-btn">&times;</button></div>
        <ul class="side-menu-nav">
            <li><a href="#" class="nav-link active" data-tab-target="#home-content">Home</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#profile-content">Profile</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#ads-to-earn-content">Ads to Earn</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#task-content">Tasks</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#lottery-content">Daily Lottery</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#referral-content">Referral Program</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#leaderboard-content">Leaderboard</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#convert-withdraw-content">Convert & Withdraw</a></li>
            <li><a href="#" class="nav-link" data-tab-target="#history-content">History</a></li>
        </ul>
    </aside>

    <main class="container">
        <section id="home-content" class="content-section active">
            <h3 class="section-title">Trending Videos</h3>
            <div class="search-container">
                <input type="search" id="videoSearchInput" placeholder="Search for videos...">
                <button id="videoSearchBtn">Search</button>
                <button id="clearSearchBtn" style="display:none;">Clear</button>
            </div>
            <div class="item-grid" id="video-grid"></div>
        </section>

        <section id="profile-content" class="content-section">
            <h3 class="section-title">Your Profile</h3>
            <div id="profile-card">
                <div id="profile-avatar"></div>
                <h2 id="profile-username">Loading...</h2>
                <p id="profile-userid">ID: Loading...</p>
                
                <div class="profile-stat-item" style="grid-column: 1 / -1; margin-bottom: 20px;">
                    <h4>Your Level</h4>
                    <p id="profile-level">Loading...</p>
                </div>

                <div id="profile-stats-grid">
                    <div class="profile-stat-item">
                        <h4>Total Points</h4>
                        <p id="profile-points">0</p>
                    </div>
                    <div class="profile-stat-item">
                        <h4>PG Coins</h4>
                        <p id="profile-pg-coins">0.000</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="ads-to-earn-content" class="content-section">
             <h3 class="section-title">Watch Ads, Earn Points</h3>
             <div id="ad-task-list" class="item-grid"></div>
        </section>
        
        <section id="task-content" class="content-section">
            <div class="task-category-selector">
                <button class="task-category-btn active" data-task-category="daily-rewards">Daily Rewards</button>
                <button class="task-category-btn" data-task-category="complete-tasks">Complete Tasks</button>
            </div>
            <div id="daily-rewards-container" class="task-category-container active">
                <h3 class="section-title">Special 24-Hour Tasks</h3>
                <div id="special-task-list" class="item-grid"></div>
                <h3 class="section-title" style="margin-top: 40px;">Daily Check-in Rewards</h3>
                <div id="daily-task-list" class="item-grid" style="grid-template-columns: 1fr;"></div>
            </div>
            <div id="complete-tasks-container" class="task-category-container">
                <h3 class="section-title">Complete Tasks</h3>
                <div id="task-list" class="item-grid"></div>
            </div>
        </section>
        
        <section id="lottery-content" class="content-section">
            <div class="lottery-container">
                <h3 class="section-title" style="border: none; text-align: center;">Lottery Spin Game</h3>
                <p>Click a button below to test your luck!</p>
                
                <div id="lottery-result-display">?</div>
                
                <button id="free-spin-button" class="lottery-button">Free Daily Spin (1 left)</button>
                <button id="ad-spin-button" class="lottery-button">Spin with Ad (3 left)</button>
                <button id="ref-spin-button" class="lottery-button">Get More Spins (Refer)</button>

                <div id="lottery-info"></div>
            </div>
        </section>


        <section id="referral-content" class="content-section">
            <div class="card">
                <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                <h3>Referral Program</h3>
                <p>Invite friends to earn bonuses! For each successful referral, you get <strong>1000 Points</strong>, <strong>0.5 PG Coin</strong>, and <strong>1 Lottery Spin!</strong></p>
                <div class="referral-link-wrapper"><input type="text" id="referralLinkInput" readonly value="Generating link..."><button id="copyReferralLinkBtn" class="form-button">Copy</button></div>
                
                <div class="sub-card" style="margin-top: 25px; text-align: left;">
                    <h4 style="text-align: center;">Your Lifetime Referral Stats</h4>
                    <div id="referral-stats-list">
                        <div class="leaderboard-item" style="background: #222; margin-bottom: 5px;">
                            <div class="info" style="margin-left: 0;"><strong>Total Referrals</strong></div>
                            <div id="referral-stats-count" class="count">0</div>
                        </div>
                        <div class="leaderboard-item" style="background: #222; margin-bottom: 5px;">
                            <div class="info" style="margin-left: 0;"><strong>Points Earned</strong></div>
                            <div id="referral-stats-points" class="count">0</div>
                        </div>
                        <div class="leaderboard-item" style="background: #222; margin-bottom: 5px;">
                            <div class="info" style="margin-left: 0;"><strong>Lottery Spins Earned</strong></div>
                            <div id="referral-stats-spins" class="count">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="leaderboard-content" class="content-section">
            <h3 class="section-title">Lifetime Top Referrers</h3>
            <div class="card" style="text-align: left; padding-bottom: 10px;">
                <p style="text-align: center;">Users with the most referrals of all time are ranked here. Keep inviting to climb the ranks!</p>
                <div id="leaderboard-list"></div>
            </div>
            <h3 class="section-title" style="margin-top: 40px;">Your Referrals</h3>
            <div class="card" style="text-align: left;">
                <p style="text-align: center;">Track the progress of the friends you've invited.</p>
                <div id="my-referrals-list"></div>
            </div>
        </section>
        
        <section id="convert-withdraw-content" class="content-section">
             <div class="card">
                 <h3 class="section-title" style="border: none; margin-bottom: 5px; text-align: center;">Convert & Withdraw</h3>
                 <div class="sub-card">
                     <h4>Convert to USDT</h4>
                     <div class="form-group">
                        <label for="convertSource">Convert From</label>
                        <select id="convertSource">
                            <option value="points">Points</option>
                            <option value="pgcoin">PG Coin</option>
                        </select>
                     </div>
                     <p id="convertRateInfo" class="conversion-info"></p>
                     <p>Your Balance: <strong id="convertSourceBalance">0</strong></p>
                     <div class="form-group">
                         <label for="amountToConvert">Amount to Convert</label>
                         <input type="number" id="amountToConvert" placeholder="">
                     </div>
                     <p class="info-text">You will receive: <strong id="usdtReceiveAmount">$0.00 USDT</strong></p>
                     <button id="convertBtn" class="form-button">Convert</button>
                 </div>

                 <div class="sub-card">
                     <h4>Withdraw USDT</h4>
                     <div class="info-text" style="text-align: left; margin-bottom: 20px; line-height: 1.5;">
                         <strong style="color: var(--text-light);">How to Withdraw:</strong><br>
                         To be eligible for withdrawal, you must invite a certain number of friends who actively use the app.
                         <br><br>
                         &bull; A <strong>Valid Referral</strong> is a user you invited who has earned at least 500 Points.
                         <br>
                         &bull; The number of required valid referrals increases with each withdrawal you make. Check your current requirement below. Keep inviting to unlock withdrawals!
                         <br>
                         &bull; <strong style="color: var(--success-color);">Level 7+ users have no referral requirements for withdrawal.</strong>
                     </div>
                      <p>Your USDT Balance: <strong id="withdrawUsdtBalance">0.00</strong></p>
                     <p id="referralCheck" class="info-text">Referral Check: <span style="color: #ffc107">Checking...</span></p>
                     <form id="withdrawalForm">
                         <div class="conversion-info" style="text-align: left;">
                            Minimums: <br>
                            &bull; $0.30 for Bkash <br>
                            &bull; $0.50 for Binance (Optimism)
                         </div>
                         <div class="form-group">
                            <label for="withdrawalMethod">Payment Method</label>
                            <select id="withdrawalMethod" required><option value="Bkash">Bkash</option><option value="Binance (Optimism)">Binance (Optimism)</option></select>
                         </div>
                         <div class="form-group">
                            <label for="accountDetails">Account Details</label>
                            <input type="text" id="accountDetails" placeholder="Your Bkash Number or Binance Address" required>
                         </div>
                         <div class="form-group">
                            <label for="withdrawalAmount">Amount (USDT)</label>
                            <input type="number" id="withdrawalAmount" placeholder="e.g., 0.5" required step="0.01">
                         </div>
                         <button type="submit" class="form-button" id="requestWithdrawalBtn" disabled>Request Withdrawal</button>
                     </form>
                 </div>
             </div>
        </section>

        <section id="history-content" class="content-section"><h3 class="section-title">Withdrawal History</h3><div id="history-list"></div></section>
        
    </main>
    
    <div id="successModalOverlay" class="success-modal-overlay"><div class="success-modal"><div class="success-modal-icon">âœ“</div><h3 id="successModalTitle">Success!</h3><p id="successModalMessage">Your request has been sent.</p></div></div>
    
    <div id="inboxModalOverlay" class="success-modal-overlay">
        <div class="inbox-modal"><h3>Inbox</h3><div id="inbox-message-list"><div class="loader"></div></div><button id="closeInboxBtn" class="form-button" style="margin-top: 15px;">Close</button></div>
    </div>
    
    <script src="https://www.youtube.com/iframe_api" async></script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, orderBy, limit, addDoc, serverTimestamp, doc, getDoc, setDoc, updateDoc, runTransaction, increment, arrayUnion } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCKMa4NdIowD_8NioUbrn4L7g5M9y5Tts0",
            authDomain: "movie-zone-931d7.firebaseapp.com",
            projectId: "movie-zone-931d7",
            storageBucket: "movie-zone-931d7.appspot.com",
            messagingSenderId: "1006880112063",
            appId: "1:1006880112063:web:4a4cf5079ea365a6ce750a",
            measurementId: "G-TH1YSE4D9C"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const tg = window.Telegram.WebApp;

        let currentUser = null;
        let player;
        let currentPlayingItem = null;
        let videoPlaybackInterval = null;
        let dailyTimerInterval = null;
        let timeSpentThisSession = 0;
        let accumulatedWatchTime = 0;
        let taskTimers = {};
        let isInterstitialAdVisible = false;

        const AD_VISIT_LIMIT = 10; 
        const VIDEO_WATCH_LIMIT = 30; 
        const REFERRAL_POINTS_THRESHOLD = 500;
        const REFERRAL_BONUS_POINTS = 1000;
        const REFERRAL_BONUS_PG_COIN = 0.5;
        const REFERRAL_BONUS_SPINS = 1;
        const POINTS_TO_USDT_RATE = 0.02 / 1000;
        const PG_COIN_TO_USDT_RATE = 0.02;
        const MIN_POINTS_TO_CONVERT = 5000;
        const MIN_PG_COIN_TO_CONVERT = 5;
        
        const dailyTasksConfig = [
            { id: 'daily_login', title: 'Daily Login Bonus', reward: 40, type: 'action' },
            { id: 'visit_channel', title: 'Visit Telegram Channel', reward: 10, type: 'action', url: 'https://t.me/newtube12' },
            { id: 'stay_5m', title: 'Stay for 5 minutes', reward: 10, type: 'time', requirement: 300 },
            { id: 'stay_15m', title: 'Stay for 15 minutes', reward: 20, type: 'time', requirement: 900 },
            { id: 'stay_30m', title: 'Stay for 30 minutes', reward: 35, type: 'time', requirement: 1800 },
        ];
        
        const userLevels = [
            { level: 1, name: "Newbie", requiredPoints: 0, requiredPgCoin: 0 },
            { level: 2, name: "Rookie", requiredPoints: 5000, requiredPgCoin: 0 },
            { level: 3, name: "Apprentice", requiredPoints: 15000, requiredPgCoin: 0 },
            { level: 4, name: "Journeyman", requiredPoints: 50000, requiredPgCoin: 8 },
            { level: 5, name: "Expert", requiredPoints: 70000, requiredPgCoin: 20 },
            { level: 6, name: "Master", requiredPoints: 150000, requiredPgCoin: 35 },
            { level: 7, name: "Grandmaster", requiredPoints: 320000, requiredPgCoin: 70 },
            { level: 8, name: "Legend", requiredPoints: 600000, requiredPgCoin: 200 }
        ];

        const levelBonuses = { 1: 0, 2: 0.02, 3: 0.05, 4: 0.08, 5: 0.15, 6: 0.20, 7: 0.30, 8: 0.40 };

        function getWithdrawalRequirements(withdrawalCount = 0) {
            const count = withdrawalCount || 0;
            if (count === 0) return { referrals: 2, tier: 1 };
            if (count === 1) return { referrals: 4, tier: 2 };
            if (count === 2) return { referrals: 7, tier: 3 };
            if (count === 3) return { referrals: 10, tier: 4 };
            return { referrals: 15, tier: 5 };
        }

        async function countValidReferrals(userId) {
            const myReferralsQuery = query(collection(db, "users"), where("referredBy", "==", userId));
            const snapshot = await getDocs(myReferralsQuery);
            let validCount = 0;
            if (!snapshot.empty) {
                snapshot.forEach(docSnap => {
                    const referee = docSnap.data();
                    const points = referee.lifetimePointsEarned || 0;
                    if (points >= REFERRAL_POINTS_THRESHOLD) {
                        validCount++;
                    }
                });
            }
            return validCount;
        }

        async function fetchAndUpdateCurrentUser() {
            if (!currentUser?.id) return;
            try {
                const userRef = doc(db, 'users', currentUser.id);
                const userSnap = await getDoc(userRef);
                if (userSnap.exists()) {
                    currentUser = { id: userSnap.id, ...userSnap.data() };
                    updateBalanceUI(currentUser.balance, currentUser.usdtBalance, currentUser.pgCoin);
                }
            } catch (error) { console.error("Error fetching current user:", error); }
        }
        
        async function checkAndResetDailies() {
            if (!currentUser) return;
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            let updates = {};

            const lastAdVisitDate = currentUser.lastAdVisitDate?.toDate();
            const lastAdVisitTime = lastAdVisitDate ? new Date(lastAdVisitDate.getFullYear(), lastAdVisitDate.getMonth(), lastAdVisitDate.getDate()).getTime() : 0;
            if (lastAdVisitTime < today) { updates.adVisitsToday = 0; }

            const lastDailyReset = currentUser.dailyTasks?.lastReset?.toDate();
            const lastDailyResetTime = lastDailyReset ? new Date(lastDailyReset.getFullYear(), lastDailyReset.getMonth(), lastDailyReset.getDate()).getTime() : 0;
            if (!lastDailyReset || lastDailyResetTime < today) {
                updates['dailyTasks.claimed'] = [];
                updates['dailyTasks.timeSpent'] = 0;
                updates['dailyTasks.lastReset'] = serverTimestamp();
            }

            const lastVideoReset = currentUser.videoProgress?.lastReset?.toDate();
            const lastVideoResetTime = lastVideoReset ? new Date(lastVideoReset.getFullYear(), lastVideoReset.getMonth(), lastVideoReset.getDate()).getTime() : 0;
            if(!currentUser.videoProgress || lastVideoResetTime < today) {
                updates['videoProgress.dailyWatchedCount'] = 0;
                updates['videoProgress.lastReset'] = serverTimestamp();
            }
            
            const lastLotteryReset = currentUser.lottery?.lastReset?.toDate();
            const lastLotteryResetTime = lastLotteryReset ? new Date(lastLotteryReset.getFullYear(), lastLotteryReset.getMonth(), lastLotteryReset.getDate()).getTime() : 0;
            if(!currentUser.lottery || lastLotteryResetTime < today) {
                 updates['lottery.freeSpinsUsed'] = 0;
                 updates['lottery.adSpinsUsed'] = 0;
                 updates['lottery.lastReset'] = serverTimestamp();
            }

            if (Object.keys(updates).length > 0) {
                try {
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, updates);
                    await fetchAndUpdateCurrentUser(); 
                } catch (error) { console.error("Error resetting limits:", error); }
            }
        }

        async function initializeUser(tgUser, referrerCode) {
            const userId = String(tgUser.id);
            const userRef = doc(db, 'users', userId);
            let userSnap = await getDoc(userRef);

            const fieldsToEnsure = {
                balance: 0, usdtBalance: 0, pgCoin: 0, lifetimePointsEarned: 0, lifetimePgCoinEarned: 0, referralPointsEarned: 0, referralPgCoinEarned: 0,
                referralCount: 0, completedTasks: [], adVisitsToday: 0, 
                dailyTasks: { claimed: [], timeSpent: 0, lastReset: serverTimestamp() },
                videoProgress: { dailyWatchedCount: 0, lastReset: serverTimestamp() },
                readMessages: [],
                withdrawalCount: 0,
                lottery: { freeSpinsUsed: 0, adSpinsUsed: 0, referralSpins: 0, lastReset: serverTimestamp() }
            };
            
            if (!userSnap.exists()) {
                const defaultUserData = {
                    ...fieldsToEnsure,
                    createdAt: serverTimestamp(),
                    telegramUsername: tgUser.username || 'N/A',
                };
                if (referrerCode && referrerCode !== userId) {
                    defaultUserData.referredBy = referrerCode;
                }
                await setDoc(userRef, defaultUserData);

                if (referrerCode && referrerCode !== userId) {
                    try {
                        const referrerRef = doc(db, 'users', referrerCode);
                        const referrerSnap = await getDoc(referrerRef);
                        if (referrerSnap.exists()) {
                             await updateDoc(referrerRef, { 
                                referralCount: increment(1),
                             });
                        }
                    } catch (e) { console.error("Could not update referrer count", e); }
                }
                userSnap = await getDoc(userRef);
            }
            
            let userData = userSnap.data();
            let updatesForOldUsers = {};

            if (!userData.referredBy && referrerCode && referrerCode !== userId) {
                 try {
                    const referrerRef = doc(db, 'users', referrerCode);
                    const referrerSnap = await getDoc(referrerRef);
                    if (referrerSnap.exists()) {
                        updatesForOldUsers.referredBy = referrerCode;
                        await updateDoc(referrerRef, { 
                            referralCount: increment(1),
                        });
                    }
                } catch(e) { console.error("Could not update referrer count for existing user", e); }
            }
            
            for (const key of ['balance', 'usdtBalance', 'pgCoin', 'lifetimePointsEarned', 'lifetimePgCoinEarned', 'referralCount', 'adVisitsToday', 'referralPointsEarned', 'referralPgCoinEarned']) {
                if (!userData.hasOwnProperty(key)) {
                    updatesForOldUsers[key] = fieldsToEnsure[key];
                }
            }
            if (!userData.dailyTasks) updatesForOldUsers.dailyTasks = fieldsToEnsure.dailyTasks;
            if (!Array.isArray(userData.completedTasks)) updatesForOldUsers.completedTasks = [];
            if (!userData.videoProgress) updatesForOldUsers.videoProgress = fieldsToEnsure.videoProgress;
            if (!Array.isArray(userData.readMessages)) updatesForOldUsers.readMessages = [];
            if (!userData.hasOwnProperty('referralBonusPaidOut')) updatesForOldUsers.referralBonusPaidOut = {}; // Changed to object
            if (userData.telegramUsername !== (tgUser.username || 'N/A')) updatesForOldUsers.telegramUsername = tgUser.username || 'N/A';
            if (!userData.hasOwnProperty('withdrawalCount')) updatesForOldUsers.withdrawalCount = 0;
            if (!userData.lottery) updatesForOldUsers.lottery = fieldsToEnsure.lottery;

            if (Object.keys(updatesForOldUsers).length > 0) {
                await updateDoc(userRef, updatesForOldUsers).catch(err => console.error("Error updating old user fields:", err));
            }

            const finalUserSnap = await getDoc(userRef);
            currentUser = { id: finalUserSnap.id, ...finalUserSnap.data() };
            
            await checkAndResetDailies();
            
            document.getElementById('userIdDisplay').textContent = `ID: ${currentUser.id}`;

            updateBalanceUI(currentUser.balance, currentUser.usdtBalance, currentUser.pgCoin);
            generateReferralLink(currentUser.id);
            checkForUnreadMessages();
            startDailyTimer();
        }
        
        function formatPoints(num) {
            const n = Math.floor(num || 0);
            if (n >= 1000000) return `${(n / 1000000).toFixed(1).replace(/\.0$/, '')}M`;
            if (n >= 10000) return `${(n / 1000).toFixed(1).replace(/\.0$/, '')}K`;
            return n;
        }

        function updateBalanceUI(balance, usdtBalance, pgCoinBalance) {
            const points = formatPoints(balance);
            const usdt = parseFloat(usdtBalance || 0).toFixed(2);
            const pgCoin = parseFloat(pgCoinBalance || 0).toFixed(3);
            document.getElementById('userBalanceDisplay').textContent = points;
            document.getElementById('userUSDTBalanceDisplay').textContent = usdt;
            document.getElementById('userPgCoinDisplay').textContent = pgCoin;
        }

        function generateReferralLink(userId) {
            const botUsername = "NewTube12_bot";
            const webAppShortName = "newtubecash";
            const referralLink = `https://t.me/${botUsername}/${webAppShortName}?startapp=${userId}`;
            document.getElementById('referralLinkInput').value = referralLink;
        }
        
        document.getElementById('copyReferralLinkBtn').addEventListener('click', () => {
            const copyButton = document.getElementById('copyReferralLinkBtn');
            navigator.clipboard.writeText(copyButton.previousElementSibling.value).then(() => {
                copyButton.textContent = 'Copied!';
                if (tg && tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
            });
        });

        async function grantReward(rewards) {
             if (!currentUser || (!rewards.points && !rewards.pgCoin)) return;

             if (rewards.points && rewards.points > 0) {
                let currentLevel = userLevels[0];
                const totalPoints = currentUser.lifetimePointsEarned || 0;
                const totalPgCoin = currentUser.lifetimePgCoinEarned || 0;
                for (let i = userLevels.length - 1; i >= 0; i--) {
                    const levelInfo = userLevels[i];
                    if (totalPoints >= levelInfo.requiredPoints && totalPgCoin >= levelInfo.requiredPgCoin) {
                        currentLevel = levelInfo;
                        break;
                    }
                }
                const bonusMultiplier = levelBonuses[currentLevel.level] || 0;
                const bonusPoints = Math.floor(rewards.points * bonusMultiplier);
                rewards.points += bonusPoints;
             }
             
             const userRef = doc(db, 'users', currentUser.id);
             const updates = {};
             if (rewards.points) {
                 updates.balance = increment(rewards.points);
                 updates.lifetimePointsEarned = increment(rewards.points);
             }
             if (rewards.pgCoin) {
                 updates.pgCoin = increment(rewards.pgCoin);
                 updates.lifetimePgCoinEarned = increment(rewards.pgCoin);
             }

             if (Object.keys(updates).length > 0) {
                 await updateDoc(userRef, updates);
                 await fetchAndUpdateCurrentUser();
             }
        }
        
        async function renderVideos(snapshot) {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = ''; 
            if (snapshot.empty) {
                grid.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No videos found.</p>';
                return;
            }
            snapshot.docs.forEach((docSnap) => {
                const video = docSnap.data();
                const item = document.createElement('article');
                item.className = 'movie-item';
                item.dataset.youtubeId = video.youtubeId;
                item.dataset.videoId = docSnap.id;
                
                item.originalContent = `
                    <div class="thumbnail-container">
                        <img src="${video.thumbnailUrl}" alt="${video.title}" loading="lazy">
                    </div>
                    <div class="movie-item-info">
                        <h4>${video.title}</h4>
                        <p class="movie-reward">Watch to Earn Points</p>
                    </div>`;
                item.innerHTML = item.originalContent;
                item.addEventListener('click', handleVideoClick);
                grid.appendChild(item);
            });
        }

        async function fetchContent() {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = '<div class="loader"></div>';
            try {
                const videosCollection = collection(db, 'videos');
                const q = query(videosCollection, orderBy('createdAt', 'desc'), limit(VIDEO_WATCH_LIMIT));
                const snapshot = await getDocs(q);
                await renderVideos(snapshot);
            } catch (error) { 
                console.error("Error fetching content:", error); 
                grid.innerHTML = '<p style="grid-column: 1 / -1;">Error loading content.</p>'; 
            }
        }
        
        async function handleVideoClick(event) {
            if (!currentUser) { alert("User data not loaded yet."); return; }

            const dailyWatchedCount = currentUser.videoProgress?.dailyWatchedCount || 0;
            if(dailyWatchedCount >= VIDEO_WATCH_LIMIT){
                alert(`You have reached your daily video watch limit of ${VIDEO_WATCH_LIMIT}.`);
                return;
            }

            if (currentPlayingItem) {
                clearInterval(videoPlaybackInterval);
                const originalContent = currentPlayingItem.originalContent;
                if(originalContent) currentPlayingItem.innerHTML = originalContent;
                if (player) { player.destroy(); player = null; }
            }
            const clickedItem = event.currentTarget;
            if (currentPlayingItem === clickedItem) {
                currentPlayingItem = null;
                return;
            }
            currentPlayingItem = clickedItem;
            const { youtubeId, videoId } = clickedItem.dataset;
            const playerDivId = `player-${youtubeId}-${Date.now()}`;
            
            clickedItem.innerHTML = `<div id="${playerDivId}" class="player-container"></div>`;
            
            accumulatedWatchTime = 0;

            player = new YT.Player(playerDivId, {
                height: '100%', width: '100%', videoId: youtubeId,
                playerVars: { 'autoplay': 1, 'controls': 1, 'rel': 0, 'fs': 1 },
                events: { 'onStateChange': (e) => {
                         if (e.data === YT.PlayerState.PLAYING && !videoPlaybackInterval) {
                            videoPlaybackInterval = setInterval(() => grantReward({ points: 2 }), 60 * 1000);
                        } else { clearInterval(videoPlaybackInterval); videoPlaybackInterval = null; }
                    }
                }
            });
        }
        
        function stopAndClearVideo() {
            clearInterval(videoPlaybackInterval);
            if (currentPlayingItem) {
                const originalContent = currentPlayingItem.originalContent;
                if(originalContent) currentPlayingItem.innerHTML = originalContent;
            }
            if (player) { try { player.destroy(); } catch (e) {} player = null; }
            currentPlayingItem = null; videoPlaybackInterval = null;
        }
        
        function setupAdsToEarn() {
            const adTaskListContainer = document.getElementById('ad-task-list');
            adTaskListContainer.innerHTML = '';
            const visitsToday = currentUser.adVisitsToday || 0;
            const visitsLeft = AD_VISIT_LIMIT - visitsToday;
            const isLimitReached = visitsLeft <= 0;
            const card = document.createElement('div');
            card.className = 'ad-task-card';
            card.innerHTML = `<div class="ad-task-card-info"><h4>Watch Ad & Earn</h4><p>Reward: 50 Points</p><p class="ad-visits-left">Today's Visits Left: ${visitsLeft > 0 ? visitsLeft : 0} / ${AD_VISIT_LIMIT}</p></div><button class="ad-task-button" ${isLimitReached ? 'disabled' : ''}>${isLimitReached ? 'Daily Limit Reached' : 'Watch Ad'}</button>`;
            adTaskListContainer.appendChild(card);
        }
        
        document.getElementById('ad-task-list').addEventListener('click', async (e) => {
            if (!e.target.matches('.ad-task-button') || e.target.disabled) return;
            const button = e.target;
            button.disabled = true; button.textContent = 'Loading Ad...';
            const grantAdReward = async () => {
                if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                try {
                    await grantReward({ points: 50 });
                    await updateDoc(doc(db, 'users', currentUser.id), { adVisitsToday: increment(1), lastAdVisitDate: serverTimestamp() });
                    await fetchAndUpdateCurrentUser();
                    setupAdsToEarn(); 
                    showSuccessModal("Congratulations!", "You've earned 50 points.");
                } catch (error) { console.error("Ad task reward error:", error); setupAdsToEarn(); }
            };
            try {
                await showRandomAdForTask();
                await grantAdReward();
            } catch (err) {
                alert('You need to watch the complete ad to earn points.');
                setupAdsToEarn();
            }
        });
        
        async function fetchTasks() {
            const taskListContainer = document.getElementById('task-list');
            const specialTaskListContainer = document.getElementById('special-task-list');
            taskListContainer.innerHTML = '<div class="loader"></div>';
            specialTaskListContainer.innerHTML = '<div class="loader"></div>';
            try {
                const tasksRef = collection(db, 'tasks');
                const q = query(tasksRef, orderBy("createdAt", "desc"));
                const snapshot = await getDocs(q);
                taskListContainer.innerHTML = '';
                specialTaskListContainer.innerHTML = '';

                if (snapshot.empty) {
                    const noTaskMsg = '<p style="text-align:center; grid-column: 1 / -1;">No tasks available right now.</p>';
                    taskListContainer.innerHTML = noTaskMsg;
                    specialTaskListContainer.innerHTML = noTaskMsg;
                    return;
                }

                const now = Date.now();
                let hasRegularTasks = false;
                let hasSpecialTasks = false;

                snapshot.forEach(docSnap => {
                    const task = docSnap.data();
                    const taskId = docSnap.id;
                    const card = document.createElement('div');
                    card.className = 'task-card';
                    const isCompleted = currentUser.completedTasks?.includes(taskId);
                    const completionCount = task.completionCount || 0;
                    const taskLimit = task.limit || 0;
                    const isLimitReached = (taskLimit > 0) && (completionCount >= taskLimit);
                    
                    let buttonText = 'Start Task'; let buttonDisabled = false; let buttonState = 'start';
                    if (isCompleted) { buttonText = 'Done'; buttonDisabled = true; buttonState = 'done'; }
                    else if (isLimitReached) { buttonText = 'Limit Reached'; buttonDisabled = true; buttonState = 'limit_reached'; }

                    const rewardPoints = task.rewardPoints || task.reward || 0;
                    const rewardPg = task.rewardPg || 0;

                    let rewardHtml = '';
                    if (rewardPoints > 0) rewardHtml += `<span class="task-reward-points">${rewardPoints} Points</span>`;
                    if (rewardPg > 0) rewardHtml += (rewardHtml ? ' + ' : '') + `<span class="task-reward-pg">${rewardPg} PG</span>`;

                    card.innerHTML = `
                        <div class="task-card-info">
                            <h4>${task.title}</h4>
                            <p>Reward: ${rewardHtml}</p>
                        </div>
                        <button class="task-button" data-task-id="${taskId}" data-task-url="${task.url}" data-reward-points="${rewardPoints}" data-reward-pg="${rewardPg}" data-visit-duration="${task.visitDurationSeconds || 0}" data-state="${buttonState}" ${buttonDisabled ? 'disabled' : ''}>
                            ${buttonText}
                        </button>`;

                    if (task.isSpecial && task.expiresAt && task.expiresAt.toMillis() > now) {
                        specialTaskListContainer.appendChild(card);
                        hasSpecialTasks = true;
                    } else if (!task.isSpecial) {
                        taskListContainer.appendChild(card);
                        hasRegularTasks = true;
                    }
                });

                if (!hasRegularTasks) taskListContainer.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No regular tasks available.</p>';
                if (!hasSpecialTasks) specialTaskListContainer.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No special tasks available now.</p>';

            } catch (error) {
                console.error("Error fetching tasks:", error);
                const errorMsg = '<p style="color:red; text-align:center; grid-column: 1 / -1;">Could not load tasks.</p>';
                taskListContainer.innerHTML = errorMsg;
                specialTaskListContainer.innerHTML = errorMsg;
            }
        }
        
        document.getElementById('task-list').addEventListener('click', handleTaskClick);
        document.getElementById('special-task-list').addEventListener('click', handleTaskClick);

        async function handleTaskClick(e) {
            if (!e.target.matches('.task-button') || e.target.disabled) return;
            const button = e.target;
            const { taskId, taskUrl, state } = button.dataset;
            const rewardPoints = Number(button.dataset.rewardPoints) || 0;
            const rewardPg = Number(button.dataset.rewardPg) || 0;
            const visitDuration = parseInt(button.dataset.visitDuration, 10) || 0;

            if (state === 'start') {
                if (!taskUrl) { alert('Task URL is missing.'); return; }
                if (visitDuration > 0) {
                    taskTimers[taskId] = Date.now();
                    button.textContent = `Claim after ${visitDuration}s`;
                    button.dataset.state = 'claim';
                } else {
                    button.textContent = 'Claim Reward';
                    button.dataset.state = 'claim';
                }
                tg.openLink(taskUrl);
            } else if (state === 'claim') {
                if (visitDuration > 0) {
                    const startTime = taskTimers[taskId];
                    if (!startTime || (Date.now() - startTime) / 1000 < visitDuration) {
                        alert(`You must visit the site for at least ${visitDuration} seconds. Please try again.`);
                        delete taskTimers[taskId];
                        button.textContent = 'Start Task'; button.dataset.state = 'start';
                        return;
                    }
                }
                button.disabled = true; button.textContent = 'Verifying...';
                try {
                    await runTransaction(db, async (transaction) => {
                        const userRef = doc(db, 'users', currentUser.id);
                        const taskRef = doc(db, 'tasks', taskId);
                        const userDoc = await transaction.get(userRef);
                        const taskDoc = await transaction.get(taskRef);
                        if (!userDoc.exists() || !taskDoc.exists()) throw "USER_OR_TASK_NOT_FOUND";
                        if (userDoc.data().completedTasks?.includes(taskId)) throw "ALREADY_COMPLETED";
                        const taskData = taskDoc.data();
                        if ((taskData.limit || 0) > 0 && (taskData.completionCount || 0) >= taskData.limit) throw "TASK_LIMIT_REACHED";
                        transaction.update(userRef, { completedTasks: arrayUnion(taskId) });
                        transaction.update(taskRef, { completionCount: increment(1) });
                    });
                    delete taskTimers[taskId];
                    await grantReward({ points: rewardPoints, pgCoin: rewardPg });
                    showSuccessModal("Reward Claimed!", `Reward added to your balance.`);
                    button.textContent = 'Done';
                } catch (error) {
                    const errorMessages = { "ALREADY_COMPLETED": "You have already completed this task.", "TASK_LIMIT_REACHED": "This task has reached its completion limit."};
                    alert(errorMessages[error] || 'Failed to claim reward.');
                    button.disabled = (error === "ALREADY_COMPLETED" || error === "TASK_LIMIT_REACHED");
                    button.textContent = button.disabled ? 'Done' : 'Claim Reward';
                }
            }
        }

        function showSuccessModal(title, message) {
            const modal = document.getElementById('successModalOverlay');
            document.getElementById('successModalTitle').textContent = title;
            document.getElementById('successModalMessage').textContent = message;
            modal.classList.add('show');
            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
            setTimeout(() => { modal.classList.remove('show'); }, 3000);
        }
        
        async function renderConvertWithdrawUI() {
            if (!currentUser) return;
            
            const referralCheckEl = document.getElementById('referralCheck');
            const requestBtn = document.getElementById('requestWithdrawalBtn');

            const usdtBalance = parseFloat(currentUser.usdtBalance || 0);
            document.getElementById('withdrawUsdtBalance').textContent = usdtBalance.toFixed(2);
            updateConvertUI();
            
            let currentLevel = userLevels[0];
            const totalPoints = currentUser.lifetimePointsEarned || 0;
            const totalPgCoin = currentUser.lifetimePgCoinEarned || 0;
            for (let i = userLevels.length - 1; i >= 0; i--) {
                const levelInfo = userLevels[i];
                if (totalPoints >= levelInfo.requiredPoints && totalPgCoin >= levelInfo.requiredPgCoin) {
                    currentLevel = levelInfo;
                    break;
                }
            }
            
            if (currentLevel.level >= 7) {
                referralCheckEl.innerHTML = `âœ… Level ${currentLevel.level}: Withdrawal requirements waived.`;
                requestBtn.disabled = false;
                return;
            }

            referralCheckEl.innerHTML = `Valid Referral Check: <span style="color: #ffc107">Checking...</span>`;
            requestBtn.disabled = true;

            try {
                const withdrawalCount = currentUser.withdrawalCount || 0;
                const requirements = getWithdrawalRequirements(withdrawalCount);
                const currentValidReferrals = await countValidReferrals(currentUser.id);
                const hasEnoughReferrals = currentValidReferrals >= requirements.referrals;

                referralCheckEl.innerHTML = `Valid Referrals (Tier ${requirements.tier}): ${hasEnoughReferrals ? 'âœ…' : 'âŒ'} <span style="color: ${hasEnoughReferrals ? 'var(--success-color)' : '#dc3545'};">${currentValidReferrals}/${requirements.referrals}</span>`;
                requestBtn.disabled = !hasEnoughReferrals;

            } catch (error) {
                console.error("Error checking withdrawal requirements:", error);
                referralCheckEl.innerHTML = `Valid Referral Check: <span style="color: #dc3545">Error</span>`;
                requestBtn.disabled = true;
            }
        }
        
        function updateConvertUI() {
            if (!currentUser) return;
            const source = document.getElementById('convertSource').value;
            const rateInfoEl = document.getElementById('convertRateInfo');
            const sourceBalanceEl = document.getElementById('convertSourceBalance');
            const amountInput = document.getElementById('amountToConvert');
            if (source === 'points') {
                rateInfoEl.innerHTML = `Rate: 1000 Points = $0.02 USDT<br>Minimum to convert: ${MIN_POINTS_TO_CONVERT} Points`;
                sourceBalanceEl.textContent = formatPoints(currentUser.balance || 0);
                amountInput.placeholder = `e.g., ${MIN_POINTS_TO_CONVERT}`;
            } else { // pgcoin
                rateInfoEl.innerHTML = `Rate: 1 PG Coin = $0.02 USDT<br>Minimum to convert: ${MIN_PG_COIN_TO_CONVERT} PG Coin`;
                sourceBalanceEl.textContent = (currentUser.pgCoin || 0).toFixed(3);
                amountInput.placeholder = `e.g., ${MIN_PG_COIN_TO_CONVERT}`;
            }
            amountInput.value = '';
            document.getElementById('usdtReceiveAmount').textContent = '$0.00 USDT';
        }

        document.getElementById('amountToConvert').addEventListener('input', (e) => {
            const amount = parseFloat(e.target.value) || 0;
            const source = document.getElementById('convertSource').value;
            let usdtValue = 0;
            if (source === 'points') usdtValue = amount * POINTS_TO_USDT_RATE;
            else usdtValue = amount * PG_COIN_TO_USDT_RATE;
            document.getElementById('usdtReceiveAmount').textContent = `$${usdtValue.toFixed(2)} USDT`;
        });

        document.getElementById('convertBtn').addEventListener('click', async () => {
            const source = document.getElementById('convertSource').value;
            const amountToConvert = parseFloat(document.getElementById('amountToConvert').value);
            const button = document.getElementById('convertBtn');
            let minAmount, balance, rate, fieldToDecrement;
            if (source === 'points') {
                minAmount = MIN_POINTS_TO_CONVERT; balance = currentUser.balance; rate = POINTS_TO_USDT_RATE; fieldToDecrement = 'balance';
            } else {
                minAmount = MIN_PG_COIN_TO_CONVERT; balance = currentUser.pgCoin; rate = PG_COIN_TO_USDT_RATE; fieldToDecrement = 'pgCoin';
            }
            if (isNaN(amountToConvert) || amountToConvert < minAmount) { alert(`Minimum conversion is ${minAmount} ${source}.`); return; }
            if (amountToConvert > balance) { alert(`Insufficient ${source} balance.`); return; }
            const usdtToReceive = amountToConvert * rate;
            button.disabled = true; button.textContent = 'Converting...';
            try {
                const userRef = doc(db, 'users', currentUser.id);
                await runTransaction(db, async (transaction) => {
                    const userDoc = await transaction.get(userRef);
                    if (!userDoc.exists() || userDoc.data()[fieldToDecrement] < amountToConvert) throw new Error("Insufficient balance.");
                    const updates = { usdtBalance: increment(usdtToReceive) };
                    updates[fieldToDecrement] = increment(-amountToConvert);
                    transaction.update(userRef, updates);
                });
                await fetchAndUpdateCurrentUser();
                renderConvertWithdrawUI();
                showSuccessModal("Success!", `${amountToConvert} ${source} converted to $${usdtToReceive.toFixed(2)} USDT.`);
            } catch (error) { alert(`Conversion failed: ${error.message}`);
            } finally { button.disabled = false; button.textContent = 'Convert'; }
        });

        document.getElementById('withdrawalForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const submitButton = e.target.querySelector('button[type="submit"]');
            submitButton.disabled = true; submitButton.textContent = 'Verifying...';
            const method = document.getElementById('withdrawalMethod').value;
            const amount = parseFloat(document.getElementById('withdrawalAmount').value);
            const minAmount = (method === 'Bkash') ? 0.30 : 0.50;
            try {
                let currentLevel = userLevels[0];
                const totalPoints = currentUser.lifetimePointsEarned || 0;
                const totalPgCoin = currentUser.lifetimePgCoinEarned || 0;
                for (let i = userLevels.length - 1; i >= 0; i--) {
                    const levelInfo = userLevels[i];
                    if (totalPoints >= levelInfo.requiredPoints && totalPgCoin >= levelInfo.requiredPgCoin) {
                        currentLevel = levelInfo;
                        break;
                    }
                }
                const isHighLevel = currentLevel.level >= 7;

                if (isNaN(amount) || amount < minAmount) throw new Error(`Minimum withdrawal for ${method} is $${minAmount.toFixed(2)}.`);
                if (amount > currentUser.usdtBalance) throw new Error("Insufficient USDT balance.");
                
                if (!isHighLevel) {
                    const withdrawalCount = currentUser.withdrawalCount || 0;
                    const requirements = getWithdrawalRequirements(withdrawalCount);
                    const currentValidReferrals = await countValidReferrals(currentUser.id);
                    if (currentValidReferrals < requirements.referrals) throw new Error(`You need ${requirements.referrals} valid referrals for your tier ${requirements.tier} withdrawal.`);
                }
                
                submitButton.textContent = 'Processing...';
                const requestData = { userId: currentUser.id, telegramUsername: currentUser.telegramUsername, usdAmount: amount, method, details: document.getElementById('accountDetails').value, status: 'pending', createdAt: serverTimestamp() };
                await runTransaction(db, async (transaction) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await transaction.get(userRef);
                    if (!userDoc.exists() || userDoc.data().usdtBalance < amount) throw new Error("Insufficient USDT balance.");
                    transaction.set(doc(collection(db, 'withdrawals')), requestData);
                    transaction.update(userRef, { usdtBalance: increment(-amount), withdrawalCount: increment(1) });
                });
                await fetchAndUpdateCurrentUser();
                e.target.reset();
                showSuccessModal("Successfully Sent!", "Your withdrawal request is pending. Check status in History.");
            } catch (error) {
                alert(`An error occurred: ${error.message || "Please try again."}`);
            } finally {
                submitButton.textContent = 'Request Withdrawal';
                await renderConvertWithdrawUI();
            }
        });

        async function displayWithdrawalHistory() {
            const historyContainer = document.getElementById('history-list');
            historyContainer.innerHTML = '<div class="loader"></div>';
            try {
                const q = query(collection(db, "withdrawals"), where("userId", "==", currentUser.id), orderBy("createdAt", "desc"), limit(50));
                const snapshot = await getDocs(q);
                historyContainer.innerHTML = '';
                if (snapshot.empty) { historyContainer.innerHTML = '<p style="text-align:center;">No withdrawal history found.</p>'; return; }
                snapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    const date = data.createdAt?.toDate().toLocaleDateString() || 'N/A';
                    const status = data.status || 'pending';
                    const amountText = `$${parseFloat(data.usdAmount || 0).toFixed(2)} USDT`;
                    item.innerHTML = `<div><strong>${amountText}</strong><br><small>${data.method} - ${date}</small></div><strong class="status-${status}">${status.charAt(0).toUpperCase() + status.slice(1)}</strong>`;
                    historyContainer.appendChild(item);
                });
            } catch (error) { console.error("Error fetching history:", error); historyContainer.innerHTML = '<p style="color:red;">Error loading history.</p>'; }
        }
        
        function renderReferralStats() {
            if (!currentUser) return;
            document.getElementById('referral-stats-count').textContent = currentUser.referralCount || 0;
            document.getElementById('referral-stats-points').textContent = formatPoints(currentUser.referralPointsEarned || 0);
            document.getElementById('referral-stats-spins').textContent = currentUser.lottery?.referralSpins || 0;
        }
        
        async function fetchLeaderboard() {
            const listContainer = document.getElementById('leaderboard-list');
            const myReferralsContainer = document.getElementById('my-referrals-list');
            listContainer.innerHTML = '<div class="loader"></div>';
            myReferralsContainer.innerHTML = '<div class="loader"></div>';
            try {
                const q = query(collection(db, "users"), where("referralCount", ">", 0), orderBy("referralCount", "desc"), limit(50));
                const snapshot = await getDocs(q);
                listContainer.innerHTML = '';
                if (snapshot.empty) { listContainer.innerHTML = '<p style="text-align:center;">Leaderboard is empty!</p>'; }
                else { let rank = 1; snapshot.forEach(docSnap => {
                        const user = docSnap.data(); const item = document.createElement('div'); item.className = 'leaderboard-item';
                        let rankDisplay;
                        if (rank === 1) rankDisplay = 'ðŸ¥‡'; else if (rank === 2) rankDisplay = 'ðŸ¥ˆ'; else if (rank === 3) rankDisplay = 'ðŸ¥‰'; else rankDisplay = `#${rank}`;
                        item.innerHTML = `<div class="rank">${rankDisplay}</div><div class="info"><strong>${user.telegramUsername || 'User...'}</strong></div><div class="count">${user.referralCount || 0} Referrals</div>`;
                        listContainer.appendChild(item); rank++;
                    }); }
            } catch (error) { listContainer.innerHTML = '<p style="color:red; text-align:center;">Could not load leaderboard.</p>'; }
            try {
                const q = query(collection(db, "users"), where("referredBy", "==", currentUser.id));
                const snapshot = await getDocs(q);
                myReferralsContainer.innerHTML = '';
                if (snapshot.empty) { myReferralsContainer.innerHTML = '<p style="text-align:center;">You haven\'t referred anyone yet.</p>'; }
                else { snapshot.forEach(docSnap => {
                        const referee = docSnap.data(); const refereeId = docSnap.id; const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        const lifetimePoints = referee.lifetimePointsEarned || 0;
                        const isBonusPaid = referee.referralBonusPaidOut?.[currentUser.id] === true;
                        let statusHtml;
                        if (isBonusPaid) { statusHtml = `<div class="count" style="color: var(--success-color);">Claimed</div>`;
                        } else if (lifetimePoints >= REFERRAL_POINTS_THRESHOLD) { statusHtml = `<button class="form-button claim-referral-btn" data-referee-id="${refereeId}">Claim</button>`;
                        } else { statusHtml = `<div class="count" style="color: var(--text-muted);">${formatPoints(lifetimePoints)}/${formatPoints(REFERRAL_POINTS_THRESHOLD)}</div>`; }
                        item.innerHTML = `<div class="info" style="margin-left:0;"><strong>${referee.telegramUsername || 'User...'}</strong><br><small>Points: ${formatPoints(lifetimePoints)}</small></div>${statusHtml}`;
                        myReferralsContainer.appendChild(item);
                    }); }
            } catch(error) { myReferralsContainer.innerHTML = '<p style="color:red; text-align:center;">Could not load your referrals.</p>'; }
        }

        async function claimReferralBonus(refereeId, button) {
            button.disabled = true; button.textContent = '...';
            const referrerRef = doc(db, 'users', currentUser.id);
            const refereeRef = doc(db, 'users', refereeId);
            try {
                await runTransaction(db, async (transaction) => {
                    const refereeSnap = await transaction.get(refereeRef);
                    const referrerSnap = await transaction.get(referrerRef);
                    if (!refereeSnap.exists() || !referrerSnap.exists()) throw new Error("Referee or Referrer not found.");
                    
                    const refereeData = refereeSnap.data();
                    if (refereeData.referralBonusPaidOut?.[currentUser.id] === true) throw new Error("Bonus already paid.");
                    if ((refereeData.lifetimePointsEarned || 0) < REFERRAL_POINTS_THRESHOLD) throw new Error("Referee has not reached the threshold.");
                    
                    const referrerData = referrerSnap.data();
                    let currentLevel = userLevels[0];
                    const totalPoints = referrerData.lifetimePointsEarned || 0;
                    const totalPgCoin = referrerData.lifetimePgCoinEarned || 0;
                    for (let i = userLevels.length - 1; i >= 0; i--) {
                        const levelInfo = userLevels[i];
                        if (totalPoints >= levelInfo.requiredPoints && totalPgCoin >= levelInfo.requiredPgCoin) {
                            currentLevel = levelInfo;
                            break;
                        }
                    }

                    const bonusMultiplier = levelBonuses[currentLevel.level] || 0;
                    const totalPointsToGrant = REFERRAL_BONUS_POINTS + Math.floor(REFERRAL_BONUS_POINTS * bonusMultiplier);

                    transaction.update(referrerRef, { 
                        balance: increment(totalPointsToGrant),
                        lifetimePointsEarned: increment(totalPointsToGrant),
                        pgCoin: increment(REFERRAL_BONUS_PG_COIN),
                        lifetimePgCoinEarned: increment(REFERRAL_BONUS_PG_COIN),
                        'lottery.referralSpins': increment(REFERRAL_BONUS_SPINS),
                        referralPointsEarned: increment(REFERRAL_BONUS_POINTS) 
                    });
                    transaction.update(refereeRef, { [`referralBonusPaidOut.${currentUser.id}`]: true });
                });
                showSuccessModal("Bonus Claimed!", `${REFERRAL_BONUS_POINTS} Points, ${REFERRAL_BONUS_PG_COIN} PG Coin, and ${REFERRAL_BONUS_SPINS} Spin added.`);
                await fetchAndUpdateCurrentUser();
                button.textContent = 'Claimed'; button.style.backgroundColor = 'var(--success-color)';
            } catch (error) {
                alert(`Error: ${error.message}`);
                button.disabled = false; button.textContent = `Claim`;
            }
        }
        
        document.getElementById('my-referrals-list').addEventListener('click', async (e) => {
            if (e.target.matches('.claim-referral-btn') && !e.target.disabled) {
                await claimReferralBonus(e.target.dataset.refereeId, e.target);
            }
        });
        
        function startDailyTimer() {
            if (dailyTimerInterval) clearInterval(dailyTimerInterval);
            dailyTimerInterval = setInterval(async () => {
                timeSpentThisSession++;
                if (timeSpentThisSession > 0 && timeSpentThisSession % 60 === 0) {
                    if (!currentUser?.id) return;
                    await updateDoc(doc(db, 'users', currentUser.id), { 'dailyTasks.timeSpent': increment(60) });
                    await fetchAndUpdateCurrentUser(); 
                }
                if (document.getElementById('task-content').classList.contains('active')) { renderDailyTasks(); }
            }, 1000);
        }

        function renderDailyTasks() {
            if (!currentUser) return;
            const container = document.getElementById('daily-task-list');
            container.innerHTML = '';
            const claimedTasks = currentUser.dailyTasks?.claimed || [];
            const timeSpent = (currentUser.dailyTasks?.timeSpent || 0) + timeSpentThisSession;
            dailyTasksConfig.forEach(task => {
                const card = document.createElement('div');
                card.className = 'daily-task-card';
                const isClaimed = claimedTasks.includes(task.id);
                let canClaim = false; let buttonText = 'Claim';
                if (task.type === 'time') {
                    if (timeSpent >= task.requirement) { canClaim = true; } 
                    else { const timeLeft = task.requirement - timeSpent; buttonText = `Wait ${Math.floor(timeLeft / 60)}m ${timeLeft % 60}s`; }
                } else if (task.type === 'action') { canClaim = true; buttonText = task.url ? 'Go & Claim' : 'Claim'; }
                if (isClaimed) { buttonText = 'Claimed'; }
                card.innerHTML = `<div class="daily-task-info"><h4>${task.title}</h4><p>Reward: ${task.reward} Points</p></div>
                    <button class="daily-task-button" data-task-id="${task.id}" data-task-type="${task.type}" data-task-url="${task.url || ''}" data-reward="${task.reward}" ${isClaimed || !canClaim ? 'disabled' : ''}>${buttonText}</button>`;
                container.appendChild(card);
            });
        }

        document.getElementById('daily-task-list').addEventListener('click', async (e) => {
            if (!e.target.matches('.daily-task-button') || e.target.disabled) return;
            const button = e.target;
            const { taskId, taskType, taskUrl, reward } = e.target.dataset;
            if (taskType === 'action' && taskUrl) { tg.openLink(taskUrl); }
            button.disabled = true; button.textContent = '...';
            try {
                await grantReward({ points: Number(reward) });
                await updateDoc(doc(db, 'users', currentUser.id), { 'dailyTasks.claimed': arrayUnion(taskId) });
                await fetchAndUpdateCurrentUser();
                renderDailyTasks();
                showSuccessModal("Reward Claimed!", `You earned ${reward} points.`);
            } catch (error) { alert("Failed to claim task."); button.disabled = false; renderDailyTasks(); }
        });

        // Profile Section Logic
        function renderProfile() {
            if (!currentUser) return;
            
            document.getElementById('profile-username').textContent = currentUser.telegramUsername || 'User';
            document.getElementById('profile-userid').textContent = `ID: ${currentUser.id}`;
            const totalPoints = currentUser.lifetimePointsEarned || 0;
            const totalPgCoin = currentUser.lifetimePgCoinEarned || 0;
            document.getElementById('profile-points').textContent = formatPoints(totalPoints);
            document.getElementById('profile-pg-coins').textContent = (currentUser.pgCoin || 0).toFixed(3);
            
            const avatarEl = document.getElementById('profile-avatar');
            const username = currentUser.telegramUsername || 'User';
            if (currentUser.profilePictureUrl) {
                avatarEl.style.backgroundImage = `url('${currentUser.profilePictureUrl}')`;
                avatarEl.textContent = '';
            } else {
                const initial = username.charAt(0).toUpperCase();
                let hash = 0;
                for (let i = 0; i < username.length; i++) {
                    hash = username.charCodeAt(i) + ((hash << 5) - hash);
                }
                const color = `hsl(${hash % 360}, 50%, 40%)`;
                avatarEl.style.backgroundColor = color;
                avatarEl.style.backgroundImage = 'none';
                avatarEl.textContent = initial;
            }

            let currentLevel = userLevels[0];
            for (let i = userLevels.length - 1; i >= 0; i--) {
                const levelInfo = userLevels[i];
                if (totalPoints >= levelInfo.requiredPoints && totalPgCoin >= levelInfo.requiredPgCoin) {
                    currentLevel = levelInfo;
                    break;
                }
            }
            document.getElementById('profile-level').textContent = `Level ${currentLevel.level} - ${currentLevel.name}`;
        }
        
        // Lottery Logic
        const lotteryResultDisplay = document.getElementById('lottery-result-display');
        const freeSpinButton = document.getElementById('free-spin-button');
        const adSpinButton = document.getElementById('ad-spin-button');
        const refSpinButton = document.getElementById('ref-spin-button');
        const lotteryInfo = document.getElementById('lottery-info');
        let isSpinning = false;

        function updateLotteryUI() {
            if (!currentUser) return;
            const lotteryData = currentUser.lottery || { freeSpinsUsed: 0, adSpinsUsed: 0, referralSpins: 0 };
            const freeSpinsLeft = 1 - (lotteryData.freeSpinsUsed || 0);
            const adSpinsLeft = 3 - (lotteryData.adSpinsUsed || 0);
            
            freeSpinButton.textContent = `Free Daily Spin (${freeSpinsLeft > 0 ? freeSpinsLeft : 0} left)`;
            freeSpinButton.disabled = freeSpinsLeft <= 0 || isSpinning;
            
            adSpinButton.textContent = `Spin with Ad (${adSpinsLeft > 0 ? adSpinsLeft : 0} left)`;
            adSpinButton.disabled = adSpinsLeft <= 0 || isSpinning;

            refSpinButton.textContent = `Spin with Referral (${lotteryData.referralSpins || 0} left)`;
            refSpinButton.disabled = (lotteryData.referralSpins || 0) <= 0 || isSpinning;
        }
        
        async function handleSpin(spinType) {
            if (isSpinning) return;
            isSpinning = true;
            updateLotteryUI();
            lotteryResultDisplay.className = 'tier-1';
            
            const animationInterval = setInterval(() => { lotteryResultDisplay.textContent = Math.floor(Math.random() * 9999); }, 50);

            setTimeout(async () => {
                clearInterval(animationInterval);
                const rand = Math.random() * 100;
                let number, tier, reward;
                if (rand < 93) { number = Math.floor(Math.random() * 90) + 10; tier = 1; reward = number; } 
                else if (rand < 97) { number = Math.floor(Math.random() * 500) + 100; tier = 2; reward = number; } 
                else if (rand < 98.5) { number = Math.floor(Math.random() * 400) + 600; tier = 3; reward = number; }
                else if (rand < 99.5) { number = Math.floor(Math.random() * 2000) + 1000; tier = 4; reward = number; }
                else if (rand < 99.9) { number = Math.floor(Math.random() * 3000) + 3000; tier = 5; reward = number; } 
                else { number = Math.floor(Math.random() * 90000) + 10000; tier = 6; reward = number; }

                lotteryResultDisplay.textContent = number;
                lotteryResultDisplay.className = `tier-${tier}`;
                
                await grantReward({ points: reward });
                showSuccessModal("You Won!", `You have won ${reward} Points!`);

                const userRef = doc(db, 'users', currentUser.id);
                if (spinType === 'free') await updateDoc(userRef, { 'lottery.freeSpinsUsed': increment(1) });
                else if (spinType === 'ad') await updateDoc(userRef, { 'lottery.adSpinsUsed': increment(1) });
                else if (spinType === 'referral') await updateDoc(userRef, { 'lottery.referralSpins': increment(-1) });
                
                await fetchAndUpdateCurrentUser();
                isSpinning = false;
                updateLotteryUI();
            }, 2000);
        }

        freeSpinButton.addEventListener('click', () => handleSpin('free'));
        refSpinButton.addEventListener('click', () => handleSpin('referral'));
        adSpinButton.addEventListener('click', async () => {
            isSpinning = true;
            updateLotteryUI();
            adSpinButton.textContent = 'Loading Ad...';
            try {
                await showRandomAdForTask();
                await handleSpin('ad');
            } catch (err) {
                alert('Ad failed to load. Please try again.');
                isSpinning = false;
                updateLotteryUI();
            }
        });

        const showMonetagAd = () => new Promise((res, rej) => typeof show_9442539 === 'function' ? show_9442539().then(res).catch(rej) : rej('Monetag SDK missing'));
        const showGigaPubAd = () => new Promise((res, rej) => typeof window.showGiga === 'function' ? window.showGiga("main").then(res).catch(rej) : rej('GigaPub SDK missing'));
        async function showRandomAdForTask() {
            isInterstitialAdVisible = true;
            const adNetworks = [showMonetagAd, showGigaPubAd];
            try {
                await adNetworks[Math.floor(Math.random() * adNetworks.length)]();
            } finally {
                isInterstitialAdVisible = false;
            }
        }

        async function checkForUnreadMessages() { /* ... unchanged ... */ }
        document.getElementById('inbox-container').addEventListener('click', async () => { /* ... unchanged ... */ });
        document.getElementById('closeInboxBtn').addEventListener('click', () => { /* ... unchanged ... */ });

        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', async (e) => {
                e.preventDefault();
                stopAndClearVideo();
                document.querySelectorAll('.nav-link, .content-section').forEach(el => el.classList.remove('active'));
                link.classList.add('active');
                const targetId = link.dataset.tabTarget;
                const target = document.querySelector(targetId);
                if(target) target.classList.add('active');
                
                document.getElementById('side-menu').classList.remove('is-open');
                document.getElementById('menu-overlay').classList.remove('is-open');

                switch(targetId) {
                    case '#home-content': await fetchContent(); break;
                    case '#profile-content': renderProfile(); break;
                    case '#ads-to-earn-content': setupAdsToEarn(); break;
                    case '#task-content': await fetchTasks(); renderDailyTasks(); break;
                    case '#lottery-content': updateLotteryUI(); break;
                    case '#referral-content': renderReferralStats(); break;
                    case '#leaderboard-content': await fetchLeaderboard(); break;
                    case '#convert-withdraw-content': await renderConvertWithdrawUI(); break;
                    case '#history-content': await displayWithdrawalHistory(); break;
                }
            });
        });
        
        document.getElementById('ref-spin-button').addEventListener('click', () => {
            if (currentUser.lottery?.referralSpins > 0) {
                 handleSpin('referral');
            } else {
                 document.querySelector('.nav-link[data-tab-target="#referral-content"]').click();
            }
        });

        function manageAdTimers() {
            try {
                const adexiumWidget = new AdexiumWidget({ wid: '12c05dba-2642-46f2-950f-cee6575119c9', adFormat: 'interstitial' });
                
                setInterval(() => {
                    if (isInterstitialAdVisible) {
                        console.log("An ad is already visible, skipping timed Adexium ad.");
                        return;
                    }
                    console.log("Attempting to show timed Adexium ad.");
                    isInterstitialAdVisible = true;
                    // We must assume a `show()` method exists that returns a promise, similar to other ad networks.
                    if (typeof adexiumWidget.show === 'function') {
                        adexiumWidget.show()
                            .catch(err => console.error("Timed Adexium ad failed to show:", err))
                            .finally(() => { 
                                isInterstitialAdVisible = false;
                                console.log("Adexium ad flow finished."); 
                            });
                    } else {
                        console.warn("Adexium widget does not have a manual .show() method. Cannot trigger timed ad.");
                        isInterstitialAdVisible = false;
                        // Fallback to autoMode if show() doesn't exist to not break functionality completely.
                        adexiumWidget.autoMode(); 
                    }
                }, 3 * 60 * 1000); // 3 minutes
            } catch (e) {
                console.error("Failed to initialize Adexium for timed display:", e);
            }
        }

        async function main() {
            try {
                if (!tg.initDataUnsafe?.user) {
                    document.body.innerHTML = `<div class="card" style="margin-top: 50px;"><h3>Error</h3><p>This app can only be launched from Telegram.</p></div>`; return;
                }
                tg.ready(); tg.expand();
                await initializeUser(tg.initDataUnsafe.user, tg.initDataUnsafe.start_param);
                document.querySelector('.nav-link[data-tab-target="#home-content"]').click();
                
                manageAdTimers();

                const menuToggleBtn = document.getElementById('menu-toggle-button');
                const closeMenuBtn = document.getElementById('close-menu-btn');
                const sideMenu = document.getElementById('side-menu');
                const menuOverlay = document.getElementById('menu-overlay');
                const toggleMenu = () => { sideMenu.classList.toggle('is-open'); menuOverlay.classList.toggle('is-open'); };
                [menuToggleBtn, closeMenuBtn, menuOverlay].forEach(el => el.addEventListener('click', toggleMenu));
                
                const userIdContainer = document.getElementById('userIdContainer');
                userIdContainer.addEventListener('click', () => {
                    if (currentUser && currentUser.id) navigator.clipboard.writeText(currentUser.id).then(() => {
                        const btn = userIdContainer.querySelector('button'); btn.title = 'Copied!';
                        if (tg && tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                        setTimeout(() => { btn.title = 'Copy User ID'; }, 2000);
                    });
                });
                
                document.querySelectorAll('.task-category-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelectorAll('.task-category-btn, .task-category-container').forEach(el => el.classList.remove('active'));
                        button.classList.add('active');
                        document.getElementById(`${button.dataset.taskCategory}-container`).classList.add('active');
                    });
                });

                document.getElementById('convertSource').addEventListener('change', updateConvertUI);

            } catch (error) {
                console.error("Initialization failed:", error);
                document.body.innerHTML = `<div class="card" style="margin-top: 50px;"><h3>Application Error</h3><p>Could not initialize. Please restart.</p><p style="font-size: 0.8em; color: #888;">Error: ${error.message}</p></div>`;
            }
        }
        main();
    </script>

    <!-- Adsterra Social Bar Ad -->
    <script type='text/javascript' src='//ghettoformed.com/06/02/5f/06025f0d45975648f726adcf793432dc.js'></script>
</body>
</html>