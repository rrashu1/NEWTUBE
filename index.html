

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEWTUBE - Watch & Earn</title>
    <script src="https://telegram.org/js/telegram-web-app.js?56"></script>
    
    <!-- Adexium Ads SDK -->
    <script type="text/javascript" src="https://cdn.tgads.space/assets/js/adexium-widget.min.js"></script>
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const adexiumWidget = new AdexiumWidget({wid: '12c05dba-2642-46f2-950f-cee6575119c9', adFormat: 'interstitial'});
                adexiumWidget.autoMode();
            } catch (e) {
                console.error("Adexium SDK failed to initialize:", e);
            }
        });
    </script>
    
    <!-- Other Ad Libraries -->
    <script src='//libtl.com/sdk.js' data-zone='9442539' data-sdk='show_9442539'></script>
    <script src="https://ad.gigapub.tech/script?id=846"></script>
    <!-- Adextra Ad Script -->
    <script async src="https://partner.adextra.io/jt/fa6b30e404e1046793d70db4a424966f97960abe.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Poppins:wght@400;600;700&family=Roboto+Mono:wght@700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        :root {
            --primary-accent-color: #4A90E2; 
            --primary-accent-hover-color: #357ABD; 
            --dark-bg: #f8f9fa; /* UPDATED: Light grey Background */
            --card-bg: #ffffff;
            --header-bg: #ffffff;
            --text-light: #212529;
            --text-muted: #6c757d;
            --border-color: #dee2e6;
            --success-color: #28a745;
            --disabled-color: #6c757d;
            --pg-coin-color: #ff9900;
        }
        body { 
            background-color: var(--dark-bg); 
            color: var(--text-light); 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            margin: 0; 
            padding: 70px 0 90px;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }
        .main-header { 
            background-color: var(--header-bg); 
            padding: 10px 15px; 
            border-bottom: 1px solid var(--border-color); 
            position: fixed; top: 0; left: 0; right: 0; z-index: 1000; 
            display: flex; justify-content: space-between; align-items: center; 
            height: 50px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .header-left { display: flex; align-items: center; gap: 10px; }
        .site-branding { display: flex; flex-direction: column; align-items: flex-start; }
        .site-title { font-size: 1.4em; color: var(--primary-accent-color); font-weight: 700; margin: 0; line-height: 1; }
        .user-id-display { font-size: 0.65em; color: var(--text-muted); font-family: 'Roboto Mono', monospace; cursor: pointer; display: flex; align-items: center; gap: 4px; padding: 2px 4px; border-radius: 4px; transition: background-color .2s;}
        .user-id-display:hover { background-color: #e9ecef; }
        .user-id-display .copy-icon { width: 12px; height: 12px; }
        .header-right { display: flex; align-items: center; gap: 5px; }
        
        .header-icon-btn { position: relative; cursor: pointer; background: none; border: none; color: var(--text-light); padding: 5px; }
        .header-icon-btn svg { width: 26px; height: 26px; }
        
        .referral-button-vfx {
            background-color: var(--success-color);
            color: #ffffff; /* Keep icon white */
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            animation: referral-glow 2s infinite ease-in-out;
        }
        @keyframes referral-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.6); }
            50% { box-shadow: 0 0 12px rgba(40, 167, 69, 1), 0 0 18px rgba(40, 167, 69, 0.9); }
        }

        .balance-display { background-color: rgba(0,0,0,0.05); color: var(--text-light); padding: 6px 12px; border-radius: 20px; font-weight: 600; font-size: 0.85em; }
        .balance-display .pg-label { color: var(--pg-coin-color); }

        .bottom-nav {
            position: fixed; bottom: 0; left: 0; right: 0;
            background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 8px 0;
            z-index: 1000;
        }
        .bottom-nav-item {
            display: flex; flex-direction: column; align-items: center;
            gap: 4px; color: var(--text-muted); text-decoration: none;
            font-size: 0.75rem; font-weight: 500;
            padding: 5px 10px; border-radius: 8px;
            transition: color 0.2s, background-color 0.2s;
        }
        .bottom-nav-item svg { width: 24px; height: 24px; }
        .bottom-nav-item:hover { color: var(--primary-accent-color); }
        .bottom-nav-item.active { color: var(--primary-accent-color); }

        .content-section { display: none; padding-top: 25px; } 
        .content-section.active { display: block; animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .section-title { font-size: 1.6em; margin-bottom: 25px; padding-bottom: 10px; color: var(--text-light); border-bottom: 2px solid var(--border-color); font-weight: 600; }
        .sub-section-title { font-size: 1.2em; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-top: 40px; margin-bottom: 20px; font-weight: 500; }
        .search-container { display: flex; gap: 10px; margin-bottom: 20px; }
        .search-container input { flex-grow: 1; padding: 12px; box-sizing: border-box; border-radius: 8px; border: 1px solid var(--border-color); background-color: #fff; color: var(--text-light); font-size: 1em; }
        .search-container button { padding: 12px 18px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: #ffffff; font-weight: bold; cursor: pointer; }
        .search-container button#clearSearchBtn { background-color: #6c757d; }
        .item-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
        
        .movie-item, .ad-task-card, .task-card, .ad-package-card, .user-ad-item { background-color: var(--card-bg); border-radius: 12px; overflow: hidden; display: flex; flex-direction: column; border: 1px solid var(--border-color); transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.05); }
        .movie-item { cursor: pointer; } 
        .movie-item:hover{ transform: scale(1.03); box-shadow: 0 8px 25px rgba(0,0,0,0.1); }
        .thumbnail-container { width: 100%; aspect-ratio: 16/9; background-color: #e9ecef; position: relative; }
        .thumbnail-container img { width: 100%; height: 100%; object-fit: cover; }
        .player-container { width: 100%; aspect-ratio: 16/9; background: #000; }
        .player-container iframe { width: 100%; height: 100%; border: none; }
        .movie-item-info, .ad-task-card-info { padding: 15px; flex-grow: 1; text-align:center;}
        .movie-item-info h4, .ad-task-card h4, .ad-package-card h4, .user-ad-item h4 { margin: 0 0 8px; font-size: 1.1em; line-height: 1.3; }
        .movie-reward { color: var(--pg-coin-color); font-weight: bold; font-size: 0.9em; margin: 0; }
        .ad-visits-left { color: var(--success-color); font-weight: bold; font-size: 0.9em; margin: 0; }
        
        .ad-task-card p { margin: 8px 0 15px; color: var(--text-muted); font-weight: bold; }
        .task-reward-pg { color: var(--pg-coin-color); }
        .task-reward-usdt { color: var(--success-color); }
        .ad-task-button { width: 100%; padding: 12px; border: none; border-radius: 0 0 10px 10px; font-weight: bold; cursor: pointer; background-color: var(--primary-accent-color); color: #ffffff; transition: background-color .2s; margin-top: auto; font-size: 1em;}
        .task-button, .daily-task-button { width: auto; flex-shrink: 0; padding: 10px 20px; font-size: 0.9em; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; background-color: var(--primary-accent-color); color: #ffffff; transition: background-color .2s; margin-top: 0; }
        .task-button:disabled, .ad-task-button:disabled, .daily-task-button:disabled { background-color: var(--disabled-color); color: #fff; cursor: not-allowed; }
        
        .card { max-width: 500px; margin: 20px auto; background-color: var(--card-bg); padding: 30px; border-radius: 12px; border: 1px solid var(--border-color); text-align: center; }
        .card-icon { width: 50px; height: 50px; margin: 0 auto 15px; color: var(--primary-accent-color); }
        .card h3 { margin-top: 0; font-size: 1.4em; } .card p { color: var(--text-muted); line-height: 1.6; }
        .form-group { margin-bottom: 20px; text-align: left; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-muted); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; box-sizing: border-box; border-radius: 8px; border: 1px solid var(--border-color); background-color: #fff; color: var(--text-light); font-size: 1em; }
        .form-button { width: 100%; padding: 14px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: #ffffff; font-weight: bold; font-size: 1em; cursor: pointer; transition: background-color 0.2s; }
        .form-button:hover:not(:disabled) { background-color: var(--primary-accent-hover-color); }
        .form-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
        
        .referral-link-wrapper { display: flex; gap: 10px; margin-top: 20px; }
        .referral-link-wrapper input { flex-grow: 1; text-align: center; }
        .referral-link-wrapper button { width: auto; flex-shrink: 0; padding: 0 15px; }
        
        .loader { border: 4px solid var(--border-color); border-top: 4px solid var(--primary-accent-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 50px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal-overlay.show { display: flex; }
        .modal-content { background-color: var(--card-bg); color: var(--text-light); padding: 30px 40px; border-radius: 15px; text-align: center; transform: scale(0.9); opacity: 0; animation: modal-pop-in 0.3s forwards; max-width: 90%; width: 450px; border: 1px solid var(--border-color); }
        @keyframes modal-pop-in { to { transform: scale(1); opacity: 1; } }
        .success-modal-icon { width: 70px; height: 70px; border-radius: 50%; background-color: var(--success-color); display: flex; justify-content: center; align-items: center; font-size: 40px; font-weight: bold; color: white; margin: 0 auto 20px; animation: icon-pop-in 0.5s 0.2s backwards; }
        @keyframes icon-pop-in { 0% { transform: scale(0); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
        .modal-content h3 { margin: 0 0 10px; font-size: 1.6em; }
        .modal-content p { margin: 0; color: var(--text-muted); font-size: 1em; white-space: pre-wrap;}
        .history-modal, .task-modal, .welcome-modal, .task-confirm-modal { background-color: var(--card-bg); color: var(--text-light); padding: 20px; border-radius: 15px; text-align: left; width: 90%; max-width: 500px; max-height: 90vh; display: flex; flex-direction: column; }
        .history-modal h3, .task-modal h3, .welcome-modal h3, .task-confirm-modal h3 { text-align: center; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        #combined-history-list, .task-modal .modal-body, .welcome-modal .modal-body, .task-confirm-modal .modal-body { overflow-y: auto; flex-grow: 1; margin-bottom: 15px; }
        .task-confirm-modal .modal-body { text-align: center; }
        .task-confirm-modal-buttons { display: flex; gap: 10px; margin-top: 20px; }
        .task-confirm-modal-buttons button { flex: 1; }
        
        .sub-card { background-color: #e9ecef; padding: 20px; border-radius: 10px; margin-bottom: 25px; }
        .info-text { font-size: 0.9em; color: var(--text-muted); margin-top: 10px; line-height: 1.5; }
        
        .task-card, .daily-reward-card { background-color: var(--card-bg); border-radius: 8px; display: flex; flex-direction: row; justify-content: space-between; align-items: center; padding: 15px; transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; border: 1px solid var(--border-color); }
        .task-card:hover, .daily-reward-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(74, 144, 226, 0.15); }
        #ad-task-list.item-grid, #task-list.item-grid, #my-ads-list.item-grid, #daily-rewards-container { grid-template-columns: 1fr; gap: 15px; display: grid;} 
        .task-card-info, .daily-reward-card-info { padding: 0; flex-grow: 1; text-align: left; }
        .task-card-info h4, .daily-reward-card-info h4 { margin: 0 0 5px; font-size: 1em;}
        .task-card-info p, .daily-reward-card-info p { margin: 5px 0 0; font-size: 0.9em; }

        #referral-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .profile-stat-item { background-color: var(--dark-bg); padding: 20px; border-radius: 10px; border: 1px solid var(--border-color); }
        .profile-stat-item h4 { margin: 0 0 8px; font-size: 1em; color: var(--text-muted); font-weight: 500;}
        .profile-stat-item p { margin: 0; font-size: 1.5em; font-weight: bold; word-break: break-all; }
        .profile-stat-item .usdt-val { color: var(--success-color); }
        .profile-stat-item .pg-val { color: var(--pg-coin-color); }
        .profile-stat-item .ref-val { color: var(--primary-accent-color); }

        #withdraw-type-selector { display: flex; gap: 10px; margin-bottom: 25px; }
        #withdraw-type-selector button { flex: 1; padding: 12px; font-size: 1em; font-weight: 600; border: 2px solid var(--border-color); background-color: transparent; color: var(--text-muted); border-radius: 8px; cursor: pointer; }
        #withdraw-type-selector button.active { background-color: var(--primary-accent-color); border-color: var(--primary-accent-color); color: #ffffff; }
        
        .history-list-container { display: flex; flex-direction: column; gap: 0; }
        .history-date-header { padding: 15px 5px 5px; color: var(--text-muted); font-weight: 600; font-size: 0.9em; }
        .history-item { display: flex; justify-content: space-between; align-items: center; padding: 15px 5px; border-bottom: 1px solid var(--border-color); }
        .history-list-container .history-item:last-child { border-bottom: none; }
        .history-item-left strong, .history-item-right strong { font-size: 1em; font-weight: 500; color: var(--text-light); }
        .history-item-left small, .history-item-right small { font-size: 0.85em; color: var(--text-muted); display: block; margin-top: 4px; }
        .history-item-right { text-align: right; }
        .history-item-right .status-success { color: var(--success-color); font-weight: 600; text-transform: capitalize; }
        .history-item-right .status-pending { color: #ffc107; font-weight: 600; text-transform: capitalize; }
        .history-item-right .status-failed, .history-item-right .status-rejected { color: #dc3545; font-weight: 600; text-transform: capitalize; }
        
        #home-content .mining-body { font-family: 'Roboto Mono', monospace; display: flex; justify-content: center; align-items: center; color: var(--text-light); background: var(--card-bg); padding: 20px 0; border-radius: 20px; border: 1px solid var(--border-color); }
        .mining-container-new { width: 90%; max-width: 450px; background: rgba(255, 255, 255, 0.6); border: 1px solid rgba(74, 144, 226, 0.3); border-radius: 15px; padding: 30px; box-shadow: 0 0 25px rgba(74, 144, 226, 0.2); text-align: center; }
        .mining-container-new h1 { font-family: 'Orbitron', sans-serif; color: var(--primary-accent-color); font-size: 2.5rem; margin-bottom: 15px; }
        .mining-stats { display: flex; justify-content: space-around; margin-bottom: 30px; padding: 10px 0; border-top: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); }
        .mining-stat-item { font-size: 0.9rem; color: var(--text-muted); }
        .mining-stat-item span { display: block; font-size: 1.2rem; font-weight: bold; color: var(--primary-accent-color); }
        .mining-display { margin-bottom: 30px; }
        .mining-display p { font-size: 1rem; color: var(--text-muted); }
        #balance-container { font-family: 'Roboto Mono', monospace; font-size: 3rem; font-weight: 700; color: var(--text-light); margin: 10px 0; word-wrap: break-word; transition: color 0.5s ease; }
        #balance-container #balance { font-size: 3rem; }
        #balance-container span.pg-label { font-size: 1.5rem; color: var(--primary-accent-color); }
        .mining-controls #mining-button { font-family: 'Orbitron', sans-serif; width: 100%; padding: 15px; font-size: 1.2rem; font-weight: bold; color: #fff; background: linear-gradient(45deg, #007bff, #00aaff); border: none; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 0 15px rgba(0, 170, 255, 0.5); }
        .mining-controls #mining-button:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 0 25px rgba(0, 170, 255, 0.8); }
        .mining-controls #mining-button:disabled { background: #adb5bd; color: #fff; cursor: not-allowed; box-shadow: none; }
        #status-message { margin-top: 20px; font-size: 1rem; color: var(--text-muted); height: 20px; }
        
        /* --- Lottery Styles --- */
        .lottery-promo-header { background: linear-gradient(45deg, #ff9900, #ff5f6d); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-fill-color: transparent; font-family: 'Poppins', sans-serif; font-weight: 700; font-size: 1.5em; text-align: center; margin-bottom: 10px; text-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .lottery-promo-subheader { font-family: 'Inter', sans-serif; text-align: center; color: var(--text-muted); font-size: 1em; line-height: 1.6; margin-bottom: 30px; }
        .lottery-container-wrapper { display: flex; justify-content: center; align-items: center; }
        .lottery-container { background-color: var(--card-bg); padding: 30px 40px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); text-align: center; width: 100%; max-width: 400px; border: 1px solid var(--border-color); }
        .lottery-container h1 { font-size: 2.2em; margin-bottom: 10px; color: var(--primary-accent-color); }
        .lottery-container .promo-text { font-size: 1em; color: var(--text-muted); margin-top: 0; margin-bottom: 25px; font-weight: 500; }
        #lottery-result { background-color: var(--dark-bg); border-radius: 10px; padding: 20px; margin: 25px 0; min-height: 70px; display: flex; justify-content: center; align-items: center; font-size: 1.6em; font-weight: bold; transition: all 0.3s ease; border: 1px solid var(--border-color); }
        #lottery-result .value { color: var(--success-color); margin-left: 10px; }
        #spinButton { background: linear-gradient(45deg, #fc4a1a, #f7b733); color: white; border: none; padding: 15px 40px; font-size: 1.4em; font-weight: bold; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); width: 100%; margin-top: 10px; }
        #spinButton:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 20px rgba(252, 74, 26, 0.4); }
        #spinButton[data-action="watch_ad"] { background: linear-gradient(45deg, var(--success-color), #20c997); }
        #spinButton:disabled { background: var(--disabled-color); cursor: not-allowed; opacity: 0.7; box-shadow: none; }

        /* --- NEW STYLES for Add Task+ --- */
        .ad-package-card { padding: 15px; text-align: center; cursor: pointer; border: 2px solid var(--border-color); transition: all 0.2s ease-in-out; }
        .ad-package-card h4 { font-size: 1.1em; margin-bottom: 5px; }
        .ad-package-card p { margin: 0; font-weight: 600; color: var(--primary-accent-color); }
        .ad-package-card.selected { border-color: var(--primary-accent-color); background-color: #e7f3ff; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(74, 144, 226, 0.2); }
        .user-ad-item { padding: 20px; text-align: left; }
        .user-ad-item .progress-text { font-weight: bold; color: var(--primary-accent-color); margin-top: 10px; display: block; }
        .user-ad-item .status-text { font-weight: 600; margin-top: 5px; display: block; }
        .user-ad-item .status-text.completed { color: var(--success-color); }
        .user-ad-item .status-text.active { color: var(--pg-coin-color); }
        #ad-package-grid { grid-template-columns: repeat(3, 1fr); gap: 15px; }
        @media (max-width: 600px) { #ad-package-grid { grid-template-columns: repeat(2, 1fr); } }
        
        /* Daily Rewards Styles */
        #daily-rewards-container { margin-top: 30px; }
        .daily-reward-card-info .progress-bar { height: 6px; background-color: #e9ecef; border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .daily-reward-card-info .progress-bar-inner { height: 100%; width: 0%; background-color: var(--primary-accent-color); border-radius: 3px; transition: width 0.3s; }
        .daily-reward-card-info .progress-text { font-size: 0.8em; color: var(--text-muted); font-weight: 500; }
        .welcome-modal .modal-body ul { padding-left: 20px; }
        .welcome-modal .modal-body li { margin-bottom: 10px; }
        #welcome-agree-container { margin-top: 20px; display: flex; align-items: center; gap: 10px; }
    </style>
</head>
<body>

    <header class="main-header">
        <div class="header-left">
            <div class="site-branding">
                <h1 class="site-title">NEWTUBE</h1>
                <div class="user-id-display" id="header-user-id">
                    <span>ID: Loading...</span>
                    <svg class="copy-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                </div>
            </div>
            <button class="header-icon-btn" id="history-btn" title="History">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M0 0h24v24H0z" fill="none"/>
                    <path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
                </svg>
            </button>
        </div>
        <div class="header-right">
            <div class="balance-display">$: <span id="userUSDTBalanceDisplay">0.0000</span></div>
            <div class="balance-display"><span class="pg-label">PG:</span> <span id="userPgCoinDisplay">0.000</span></div>
             <button class="header-icon-btn bottom-nav-item referral-button-vfx" data-tab-target="#referral-content" title="Referral Program">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
            </button>
        </div>
    </header>

    <main class="container">
        <!-- Home Section with NEW Mining UI -->
        <section id="home-content" class="content-section active">
             <div class="mining-body" style="margin-bottom: 30px;">
                <div class="mining-container-new">
                    <h1>PG Coin Mining</h1>
                    <div class="mining-stats">
                        <div class="mining-stat-item">
                            Hash Power
                            <span id="miningHashPower">10 H/s</span>
                        </div>
                        <div class="mining-stat-item">
                            Daily Rate
                            <span id="miningDailyRate">0.5 PG</span>
                        </div>
                    </div>
                    <div class="mining-display">
                        <p>Your Total Balance</p>
                        <div id="balance-container">
                            <span id="balance">0.000</span>
                            <span class="pg-label">PG</span>
                        </div>
                    </div>
                    <div class="mining-controls">
                        <button id="mining-button">Start Mining</button>
                        <p id="status-message">Press 'Start' to begin mining.</p>
                    </div>
                </div>
            </div>

            <!-- Daily Login Bonus (Moved Here) -->
            <div id="daily-login-task-container" style="margin-bottom: 30px;"></div>

            <!-- New Daily Rewards & Earn Section -->
            <h3 class="section-title" style="margin-top: 40px;">Daily Rewards & Earn</h3>
            <div id="daily-rewards-container">
                <!-- Daily reward tasks will be dynamically inserted here -->
            </div>
        </section>
        
        <section id="ads-content" class="content-section">
             <h3 class="section-title">Watch Ads, Earn Rewards</h3>
             <div id="ad-task-list" class="item-grid"></div>
             <!-- Adextra Banner Ad Block -->
             <div id="fa6b30e404e1046793d70db4a424966f97960abe" style="margin-top: 25px;"></div>
        </section>

        <section id="video-content" class="content-section">
            <div id="adsterra-social-bar-container" style="display:none;">
                <!-- Adsterra Social Bar will be injected here -->
            </div>
            <h3 class="section-title">Trending Videos</h3>
            <div class="search-container">
                <input type="search" id="videoSearchInput" placeholder="Search for videos...">
                <button id="videoSearchBtn">Search</button>
                <button id="clearSearchBtn" style="display:none;">Clear</button>
            </div>
            <div class="item-grid" id="video-grid"></div>
        </section>

        <section id="referral-content" class="content-section">
            <div class="card">
                <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                <h3>Referral Program</h3>
                <p style="text-align: left; line-height: 1.8;">
                    Invite friends to get amazing rewards!
                    <br><br>
                    <strong>Your Rewards:</strong><br>
                    &nbsp;&nbsp;&nbsp;- <strong>For each referral:</strong> Get 1 free Lottery Spin.<br>
                    &nbsp;&nbsp;&nbsp;- <strong>Lifetime Commission:</strong> Earn 3% from all PG Coin your friends earn, forever!
                </p>
                <div class="referral-link-wrapper"><input type="text" id="referralLinkInput" readonly value="Generating link..."><button id="copyReferralLinkBtn" class="form-button">Copy</button></div>
                
                <div id="referral-stats-grid" style="margin-top: 30px;">
                    <div class="profile-stat-item">
                        <h4>User ID</h4>
                        <p id="referral-userid" style="font-size: 1.1em; color: var(--text-muted); cursor: pointer;">Loading...</p>
                    </div>
                    <div class="profile-stat-item">
                        <h4>Lifetime Referrals</h4>
                        <p id="referral-lifetime-referrals" class="ref-val">0</p>
                    </div>
                    <div class="profile-stat-item">
                        <h4>USDT Balance</h4>
                        <p id="referral-usdt-balance" class="usdt-val">0.0000</p>
                    </div>
                     <div class="profile-stat-item">
                        <h4>Commission Earned (PG)</h4>
                        <p id="referral-commission-pg" class="pg-val">0.000</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="task-content" class="content-section">
            <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-bottom: 20px;">
                <h3 class="sub-section-title" style="margin: 0; border: none; padding: 0; font-size: 1.1em;">Available Tasks</h3>
                <button id="show-create-task-btn" class="task-button">Add Task +</button>
            </div>
            
            <h3 class="section-title">Complete Tasks to Earn</h3>
            <div id="task-list" class="item-grid"></div>

             <!-- My Ads Section -->
             <div id="my-ads-section-container">
                <h3 class="sub-section-title">My Advertisements</h3>
                <div id="my-ads-list" class="item-grid"></div>
            </div>
        </section>
        
        <section id="lottery-content" class="content-section">
            <h2 class="lottery-promo-header">🎉 Win 1000 PG Coins in the Lottery! 🎉</h2>
            <p class="lottery-promo-subheader">Refer your friends to get more spins – the more you spin, the higher your chances! 🍀<br>Lucky winners can grab 1K PG Coins instantly!</p>
            <p class="info-text" style="text-align: center; margin-bottom: 30px;">For sponsor, advertisement, promotion, or any issues, contact directly at: <a href="https://t.me/NEWTUBE12_admin" target="_blank" style="color: var(--primary-accent-color);">@NEWTUBE12_admin</a></p>

            <div class="lottery-container-wrapper">
                 <div class="lottery-container">
                    <h1>PG Coin Spin</h1>
                    <p class="promo-text">You have <strong id="spin-count" style="color: var(--primary-accent-color); font-size: 1.2em;">0</strong> spins remaining.</p>
                    <div id="lottery-result">
                        <span>Spin to test your luck!</span>
                    </div>
                    <button id="spinButton" data-action="none">SPIN NOW</button>
                </div>
            </div>
        </section>

        <section id="withdraw-content" class="content-section">
             <div class="card" style="max-width: none;">
                 <h3 class="section-title" style="border: none; margin-bottom: 20px; text-align: center;">Withdraw</h3>
                 <div id="withdrawal-forms-container">
                     <div id="withdraw-type-selector">
                         <button id="withdraw-type-usdt" class="active">Withdraw USDT</button>
                         <button id="withdraw-type-pg">Withdraw PG Coin</button>
                     </div>
                     <div id="usdt-withdraw-form">
                         <p>Your USDT Balance: <strong id="withdrawUsdtBalance">0.0000</strong></p>
                         <form id="usdtWithdrawalForm">
                             <div class="form-group">
                                <label for="usdtWithdrawalMethod">Payment Method</label>
                                <select id="usdtWithdrawalMethod" required>
                                    <option value="Bkash">Bkash (Min: $0.20, Fee: $0.03)</option>
                                    <option value="Binance">Binance ID (Min: $0.50, Fee: $0.05)</option>
                                </select>
                             </div>
                             <div class="form-group">
                                <label for="usdtAccountDetails">Account Details</label>
                                <input type="text" id="usdtAccountDetails" placeholder="Your Bkash Number or Binance ID" required>
                             </div>
                             <div class="form-group">
                                <label for="usdtWithdrawalAmount">Amount (USDT)</label>
                                <input type="number" id="usdtWithdrawalAmount" placeholder="e.g., 0.20" required step="0.01">
                             </div>
                             <p class="info-text" style="text-align: center;">1 Dollar = 120 Taka (BDT)</p>
                             <button type="submit" class="form-button">Request USDT Withdrawal</button>
                         </form>
                     </div>
                     <div id="pg-withdraw-form" style="display: none;">
                         <p>Your PG Coin Balance: <strong id="withdrawPgCoinBalance">0.000</strong></p>
                         <form id="pgWithdrawalForm">
                             <div class="form-group">
                                <label for="pgWithdrawalMethod">Payment Method</label>
                                <select id="pgWithdrawalMethod" required>
                                    <option value="Bkash">Bkash (Min: 10 PG, Fee: 2 PG)</option>
                                    <option value="Binance">Binance ID (Min: 50 PG, Fee: 5 PG)</option>
                                </select>
                             </div>
                             <div class="form-group">
                                <label for="pgAccountDetails">Account Details</label>
                                <input type="text" id="pgAccountDetails" placeholder="Your Bkash Number or Binance ID" required>
                             </div>
                             <div class="form-group">
                                <label for="pgWithdrawalAmount">Amount (PG Coin)</label>
                                <input type="number" id="pgWithdrawalAmount" placeholder="e.g., 10" required step="0.001">
                             </div>
                             <p class="info-text" style="text-align: center;">1 Dollar = 120 Taka (BDT)</p>
                             <button type="submit" class="form-button">Request PG Coin Withdrawal</button>
                         </form>
                     </div>
                 </div>
             </div>
        </section>
        
    </main>

    <nav class="bottom-nav">
        <a href="#" class="bottom-nav-item active" data-tab-target="#home-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
            Home
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#ads-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM8 11H6V9h2v2zm4 0h-2V9h2v2zm4 0h-2V9h2v2z"/></svg>
            Ads
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#video-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M10 16.5v-9l6 4.5-6 4.5zM20 4.44v15.12c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V4.44c0-1.1.9-2 2-2h12c1.1 0 2 .9 2 2z"/></svg>
            Video
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#task-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M22 7h-9v-2h9v2zm0 4h-9v-2h9v2zm0 4h-9v-2h9v2zm-11-8H4v6h7V7zM3 5h9v14H3V5z"/></svg>
            Tasks
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#lottery-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3s-3 1.34-3 3c0 .35.07.69.18 1H6c-1.11 0-1.99.89-1.99 2L4 20c0 1.11.89 2 2 2h12c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 18H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2zm-8-4H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2z"/></svg>
            Lottery
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#withdraw-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21 8H3V6h18v2zm0 6H3v-2h18v2zM5 18h14v-2H5v2zM3 20h18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2z"/></svg>
            Withdraw
        </a>
    </nav>
    
    <div id="successModalOverlay" class="modal-overlay"><div class="modal-content"><div class="success-modal-icon">✓</div><h3 id="successModalTitle">Success!</h3><p id="successModalMessage">Your request has been sent.</p></div></div>
    
    <!-- History Modal -->
    <div id="historyModalOverlay" class="modal-overlay">
        <div class="history-modal"><h3>History</h3><div id="combined-history-list" class="history-list-container"></div><button id="closeHistoryBtn" class="form-button" style="margin-top: 15px;">Close</button></div>
    </div>
    
    <!-- Create Task Modal -->
    <div id="createTaskModalOverlay" class="modal-overlay">
        <div class="task-modal">
            <h3>Create New Task Advertisement</h3>
            <div class="modal-body">
                <p class="info-text" style="text-align: center; margin-bottom: 20px;">
                    Easily promote your social media at a low cost! Get real users for your Facebook, YouTube, TikTok, Telegram channels or bots.<br><br>
                    Purchase tasks using your USDT balance. Your task will be shown to thousands of our active users.<br>
                    <strong>For manual deposits or promotions, contact admin: <a href="https://t.me/NEWTUBE12_admin" target="_blank" style="color: var(--primary-accent-color);">@NEWTUBE12_admin</a></strong>
                </p>
                <form id="create-task-form">
                    <div class="form-group">
                        <label>1. Select a Package</label>
                        <div id="ad-package-grid" class="item-grid">
                            <!-- Packages will be injected here by JS -->
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="task-title-input">2. Task Title</label>
                        <input type="text" id="task-title-input" placeholder="e.g., Join My Telegram Channel" required>
                    </div>
                    <div class="form-group">
                        <label for="task-url-input">3. Task URL</label>
                        <input type="url" id="task-url-input" placeholder="https://t.me/your_channel" required>
                    </div>
                    <button type="submit" class="form-button">Create Task</button>
                </form>
            </div>
            <button id="closeTaskModalBtn" class="form-button" style="margin-top: 15px; background-color: var(--text-muted);">Close</button>
        </div>
    </div>

    <!-- Welcome Modal for New Users -->
    <div id="welcomeModalOverlay" class="modal-overlay">
        <div class="welcome-modal">
            <h3>Welcome to NEWTUBE!</h3>
            <div class="modal-body">
                <p>Please read our guidelines before you start earning:</p>
                <ul>
                    <li><strong>One Account Only:</strong> Using multiple accounts is strictly forbidden and will result in a permanent ban.</li>
                    <li><strong>No VPNs:</strong> Do not use a VPN or any IP-masking software. Violators will be suspended.</li>
                    <li><strong>How to Earn:</strong> You can earn by watching videos, completing tasks, mining PG Coin, and finishing your daily rewards.</li>
                    <li><strong>Honesty:</strong> Please complete all tasks honestly. We aim to build a fair and rewarding community for everyone.</li>
                    <li><strong>Create Ads:</strong> To create your own task or advertisement, please contact the admin directly.</li>
                </ul>
                <div id="welcome-agree-container">
                    <input type="checkbox" id="welcome-agree-checkbox">
                    <label for="welcome-agree-checkbox">I have read and agree to the rules.</label>
                </div>
            </div>
            <button id="welcomeConfirmBtn" class="form-button" disabled>Confirm & Start</button>
        </div>
    </div>

    <!-- Task Confirmation Modal -->
    <div id="taskConfirmModalOverlay" class="modal-overlay">
        <div class="task-confirm-modal">
            <h3>Confirm Task Completion</h3>
            <div class="modal-body">
                <p>Have you completed the task correctly? If not, please go back and complete it now.</p>
                <p class="info-text">Note: Your submission may be reviewed by an administrator. Failure to complete tasks honestly can result in account suspension.</p>
                <div class="task-confirm-modal-buttons">
                    <button id="taskConfirmGoBackBtn" class="form-button" style="background-color: var(--text-muted);">Go Back to Task</button>
                    <button id="taskConfirmSubmitBtn" class="form-button">Yes, I Completed It</button>
                </div>
            </div>
        </div>
    </div>


    <script src="https://www.youtube.com/iframe_api" async></script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, orderBy, limit, addDoc, serverTimestamp, doc, getDoc, setDoc, updateDoc, runTransaction, increment, arrayUnion, Timestamp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCKMa4NdIowD_8NioUbrn4L7g5M9y5Tts0",
            authDomain: "movie-zone-931d7.firebaseapp.com",
            databaseURL: "https://movie-zone-931d7-default-rtdb.firebaseio.com",
            projectId: "movie-zone-931d7",
            storageBucket: "movie-zone-931d7.appspot.com",
            messagingSenderId: "1006880112063",
            appId: "1:1006880112063:web:4a4cf5079ea365a6ce750a",
            measurementId: "G-TH1YSE4D9C"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const tg = window.Telegram.WebApp;

        let currentUser = null;
        let player;
        let currentPlayingItem = null;
        let videoWatchTimer = null;
        let lastRewardedWatchSecond = 0;
        let miningTimerInterval = null;
        let miningDisplayUpdateInterval = null;
        let isSubmittingWithdrawal = false; 
        let withdrawalUISetup = false;
        let selectedAdPackage = null;
        let dailyBrowseTimer = null;

        // Ads Section Constants
        const AD_TASK_DAILY_LIMIT = 5;
        const AD_TASK_REWARDS = {
            'task1': { type: 'pgCoin', amount: 0.04 },
            'task2': { type: 'pgCoin', amount: 0.04 },
            'task3': { type: 'usdt', amount: 0.0005 }
        };

        const DAILY_LOGIN_PG_REWARD = 0.02;
        const USER_CREATED_TASK_REWARD_PG = 0.06;

        // Mining Constants
        const BASE_HASH_POWER = 10;
        const MINING_SESSION_DURATION_SECONDS = 6 * 60 * 60; 
        const MINING_SESSION_REWARD_PG_PER_10HS = 0.125;
        
        // Video Section Reward Constants (NEW)
        const VIDEO_REWARD_PER_MINUTE_PG = 0.013;
        const MAX_DAILY_VIDEO_REWARD_SECONDS = 5 * 60 * 60; // 5 hours

        // UPDATE 4: New Ad Packages
        const adPackages = [
            { id: 1, tasks: 100, price: 0.30 }, { id: 2, tasks: 200, price: 0.50 },
            { id: 3, tasks: 500, price: 1.10 }, { id: 4, tasks: 1000, price: 2.00 },
            { id: 5, tasks: 2000, price: 3.50 }, { id: 6, tasks: 5000, price: 7.00 }
        ];

        // BAN SYSTEM: Function to display ban message
        function showBanScreen() {
            document.body.innerHTML = `
                <div style="display: flex; justify-content: center; align-items: center; height: 100vh; padding: 20px; text-align: center;">
                    <div class="card">
                        <h3>Account Banned</h3>
                        <p style="color: #ffc107;">Your account has been banned due to a violation of our terms of service. Please contact support for assistance.</p>
                    </div>
                </div>
            `;
        }
        
        async function cleanupAndGetUser(userId) {
            const userRef = doc(db, 'users', userId);
            const userSnap = await getDoc(userRef);
            if (!userSnap.exists()) return null;

            const userData = userSnap.data();
            const allBoosts = userData.tempHashBoosts || [];
            const now = new Date();
            const validBoosts = allBoosts.filter(boost => boost.expiresAt.toDate() > now);

            if (allBoosts.length > validBoosts.length) {
                await updateDoc(userRef, { tempHashBoosts: validBoosts });
            }
            
            return { id: userSnap.id, ...userData, tempHashBoosts: validBoosts };
        }

        async function fetchAndUpdateCurrentUser() {
            if (!currentUser?.id) return;
            try {
                const updatedUser = await cleanupAndGetUser(currentUser.id);
                if (updatedUser) {
                    currentUser = updatedUser;
                    updateBalanceUI(currentUser.usdtBalance, currentUser.pgCoin);
                    updateMiningPowerUI();
                }
            } catch (error) { console.error("Error fetching/cleaning current user:", error); }
        }
        
        async function checkAndResetDailies() {
            if (!currentUser) return;
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            const lastDailyReset = currentUser.lastDailyReset?.toDate();
            const lastDailyResetTime = lastDailyReset ? new Date(lastDailyReset.getFullYear(), lastDailyReset.getMonth(), lastDailyReset.getDate()).getTime() : 0;
            
            if (!lastDailyReset || lastDailyResetTime < today) {
                const updates = { 
                    'lastDailyReset': serverTimestamp(), 
                    'dailyReferralCount': 0,
                    'dailyTasksCompletedCount': 0,
                    'dailyRewardsClaimed': [],
                    'dailyBrowseVisit1Completed': false,
                    'dailyBrowseVisit2Completed': false,
                    'dailyAdViews_1': 0, // Reset new ad counters
                    'dailyAdViews_2': 0,
                    'dailyAdViews_3': 0,
                    'totalVideoWatchSecondsToday': 0 // Reset video watch time
                };
                try {
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, updates);
                    await fetchAndUpdateCurrentUser(); 
                } catch (error) { console.error("Error resetting daily limits:", error); }
            }
        }

        async function grantCommission(rewardPg) {
            if (!currentUser.referredBy || !rewardPg || rewardPg <= 0) return;
            const referrerId = currentUser.referredBy;
            const commissionAmount = rewardPg * 0.03;

            if (commissionAmount > 0) {
                try {
                    const referrerRef = doc(db, 'users', referrerId);
                    await updateDoc(referrerRef, {
                        pgCoin: increment(commissionAmount),
                        lifetimeCommissionPg: increment(commissionAmount)
                    });
                     await addDoc(collection(db, 'transactions'), {
                        userId: referrerId,
                        type: 'Commission',
                        details: `3% commission from user ${currentUser.id}`,
                        pgAmount: commissionAmount,
                        status: 'Completed',
                        createdAt: serverTimestamp()
                    });
                } catch (error) { console.error(`Failed to grant commission to ${referrerId}:`, error); }
            }
        }

        async function initializeUser(tgUser, referrerCode) {
            const userId = String(tgUser.id);
            const userRef = doc(db, 'users', userId);
            let userSnap = await getDoc(userRef);
            let isNewUser = false;

            if (!userSnap.exists()) {
                isNewUser = true;
                const defaultUserData = {
                    usdtBalance: 0, pgCoin: 0, lifetimePgCoinEarned: 0, referralCount: 0,
                    lifetimeCommissionPg: 0, lifetimeCommissionUsdt: 0,
                    completedTasks: [], 
                    lastDailyReset: serverTimestamp(), lastDailyLoginClaim: null,
                    withdrawalCount: 0, 
                    createdAt: serverTimestamp(), telegramUsername: tgUser.username || 'N/A',
                    miningStartTime: null, isBanned: false,
                    tempHashBoosts: [], 
                    lotterySpins: 1, totalSpinsUsed: 0,
                    lastDailyAdSpin: null,
                    isActivated: false,
                    dailyReferralCount: 0, dailyTasksCompletedCount: 0, 
                    dailyRewardsClaimed: [], dailyBrowseVisit1Completed: false, 
                    dailyBrowseVisit2Completed: false,
                    dailyAdViews_1: 0, dailyAdViews_2: 0, dailyAdViews_3: 0,
                    totalVideoWatchSecondsToday: 0
                };
                if (referrerCode && referrerCode !== userId) {
                    defaultUserData.referredBy = referrerCode;
                }
                await setDoc(userRef, defaultUserData);
                userSnap = await getDoc(userRef);
            }
            
            const userData = userSnap.data();
            if (userData?.isBanned === true) { showBanScreen(); return null; }
            
            // Migration for existing users
            const updates = {};
            if (userData.isActivated === undefined) updates.isActivated = true;
            if (userData.dailyReferralCount === undefined) updates.dailyReferralCount = 0;
            if (userData.dailyTasksCompletedCount === undefined) updates.dailyTasksCompletedCount = 0;
            if (userData.dailyRewardsClaimed === undefined) updates.dailyRewardsClaimed = [];
            if (userData.dailyAdViews_1 === undefined) {
                updates.dailyAdViews_1 = 0;
                updates.dailyAdViews_2 = 0;
                updates.dailyAdViews_3 = 0;
            }
            if (userData.totalVideoWatchSecondsToday === undefined) updates.totalVideoWatchSecondsToday = 0;


            if (Object.keys(updates).length > 0) {
                await updateDoc(userRef, updates);
            }
            
            currentUser = { id: userSnap.id };
            await fetchAndUpdateCurrentUser(); 
            
            await checkAndResetDailies();
            generateReferralLink(currentUser.id);
            await initializeMiningState();
            
            return { isNewUser, isActivated: currentUser.isActivated };
        }

        function updateBalanceUI(usdtBalance, pgCoinBalance) {
            const usdt = parseFloat(usdtBalance || 0).toFixed(4);
            const pgCoin = parseFloat(pgCoinBalance || 0).toFixed(3);
            document.getElementById('userUSDTBalanceDisplay').textContent = usdt;
            document.getElementById('userPgCoinDisplay').textContent = pgCoin;
            if (document.getElementById('balance') && !miningDisplayUpdateInterval) { // Only update if not actively mining
                document.getElementById('balance').textContent = pgCoin;
            }
        }
        
        function getCurrentHashPower() {
            let power = BASE_HASH_POWER;
            if ((currentUser.dailyReferralCount || 0) >= 5 && !currentUser.dailyRewardsClaimed?.includes('ref_5_speed')) {
                 power *= 2; // Temporary boost until claimed
            }
            const totalBonusPower = (currentUser?.tempHashBoosts || []).reduce((sum, boost) => sum + (boost.power || 0), 0);
            return power + totalBonusPower;
        }

        function updateMiningPowerUI() {
            const currentPower = getCurrentHashPower();
            const dailyRate = (currentPower / BASE_HASH_POWER) * (MINING_SESSION_REWARD_PG_PER_10HS * 4);
            document.getElementById('miningHashPower').textContent = `${currentPower.toFixed(2)} H/s`;
            document.getElementById('miningDailyRate').textContent = `${dailyRate.toFixed(3)} PG`;
        }

        function generateReferralLink(userId) {
            const botUsername = "NewTube12_bot";
            const webAppShortName = "newtubecash";
            const referralLink = `https://t.me/${botUsername}/${webAppShortName}?startapp=${userId}`;
            document.getElementById('referralLinkInput').value = referralLink;
        }
        
        document.getElementById('copyReferralLinkBtn').addEventListener('click', () => {
            const copyButton = document.getElementById('copyReferralLinkBtn');
            navigator.clipboard.writeText(copyButton.previousElementSibling.value).then(() => {
                copyButton.textContent = 'Copied!';
                if (tg && tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
            });
        });
        
        async function grantReward(rewards, transactionInfo = {}) {
             if (!currentUser) return;
             const userRef = doc(db, 'users', currentUser.id);
             const updates = {};
             
             if (rewards.pgCoin && rewards.pgCoin > 0) {
                 updates.pgCoin = increment(rewards.pgCoin);
                 updates.lifetimePgCoinEarned = increment(rewards.pgCoin);
                 await grantCommission(rewards.pgCoin);
             }
             if (rewards.usdt && rewards.usdt > 0) {
                 updates.usdtBalance = increment(rewards.usdt);
             }
             if (rewards.spins && rewards.spins > 0) {
                 updates.lotterySpins = increment(rewards.spins);
             }
             if (Object.keys(updates).length > 0) {
                 await updateDoc(userRef, updates);
             }
             
             if (transactionInfo.type) {
                 const transactionData = {
                    userId: currentUser.id,
                    type: transactionInfo.type,
                    details: transactionInfo.details || '',
                    status: 'Completed',
                    createdAt: serverTimestamp()
                };
                if (rewards.pgCoin) transactionData.pgAmount = rewards.pgCoin;
                if (rewards.usdt) transactionData.usdAmount = rewards.usdt;
                await addDoc(collection(db, 'transactions'), transactionData);
             }
        }
        
        async function fetchContent() {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = '<div class="loader"></div>';
            try {
                const q = query(collection(db, 'videos'), orderBy('createdAt', 'desc'), limit(30));
                const snapshot = await getDocs(q);
                await renderVideos(snapshot);
            } catch (error) { 
                console.error("Error fetching content:", error); 
                grid.innerHTML = '<p style="grid-column: 1 / -1;">Error loading content.</p>'; 
            }
        }
        
        async function renderVideos(snapshot) {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = ''; 
            if (snapshot.empty) { grid.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No videos found.</p>'; return; }
            snapshot.docs.forEach((docSnap) => {
                const video = docSnap.data();
                const item = document.createElement('article');
                item.className = 'movie-item';
                item.dataset.youtubeId = video.youtubeId;
                item.dataset.videoId = docSnap.id;
                item.originalContent = `<div class="thumbnail-container"><img src="${video.thumbnailUrl}" alt="${video.title}" loading="lazy"></div><div class="movie-item-info"><h4>${video.title}</h4><p class="movie-reward">Watch to Earn PG Coin</p></div>`;
                item.innerHTML = item.originalContent;
                item.addEventListener('click', handleVideoClick);
                grid.appendChild(item);
            });
        }
        
        function handleVideoClick(event) {
            if (currentPlayingItem) {
                if(currentPlayingItem.originalContent) currentPlayingItem.innerHTML = currentPlayingItem.originalContent;
                if (player) { player.destroy(); player = null; }
            }
            const clickedItem = event.currentTarget;
            if (currentPlayingItem === clickedItem) { currentPlayingItem = null; return; }
            currentPlayingItem = clickedItem;
            const { youtubeId } = clickedItem.dataset;
            const playerDivId = `player-${youtubeId}-${Date.now()}`;
            clickedItem.innerHTML = `<div id="${playerDivId}" class="player-container"></div>`;
            player = new YT.Player(playerDivId, {
                height: '100%', width: '100%', videoId: youtubeId,
                playerVars: { 'autoplay': 1, 'controls': 1, 'rel': 0, 'fs': 1 },
                events: { 'onStateChange': onPlayerStateChange }
            });
        }

        // UPDATE 6: New Video Watch Reward Logic
        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.PLAYING) {
                if (videoWatchTimer) clearInterval(videoWatchTimer);
                videoWatchTimer = setInterval(async () => {
                    if (!currentUser) return;
                    let watchTimeToday = currentUser.totalVideoWatchSecondsToday || 0;
                    if (watchTimeToday >= MAX_DAILY_VIDEO_REWARD_SECONDS) {
                        clearInterval(videoWatchTimer);
                        return;
                    }
                    watchTimeToday++;
                    currentUser.totalVideoWatchSecondsToday = watchTimeToday; // Update local state

                    const currentMinute = Math.floor(watchTimeToday / 60);
                    const lastRewardedMinute = Math.floor(lastRewardedWatchSecond / 60);

                    if (currentMinute > lastRewardedMinute) {
                        lastRewardedWatchSecond = watchTimeToday;
                        await grantReward({ pgCoin: VIDEO_REWARD_PER_MINUTE_PG }, { type: 'Video Watch' });
                        await updateDoc(doc(db, 'users', currentUser.id), {
                           totalVideoWatchSecondsToday: increment(1)
                        });
                        showSuccessModal("Video Reward!", `You earned ${VIDEO_REWARD_PER_MINUTE_PG} PG for watching!`);
                    }
                }, 1000);
            } else {
                if (videoWatchTimer) clearInterval(videoWatchTimer);
            }
        }
        
        function stopVideoSectionActivity() {
            if(videoWatchTimer) clearInterval(videoWatchTimer);
            videoWatchTimer = null;
            if (currentPlayingItem?.originalContent) currentPlayingItem.innerHTML = currentPlayingItem.originalContent;
            if (player) { try { player.destroy(); } catch (e) {} player = null; }
            currentPlayingItem = null;
            
            // UPDATE 3: Hide Adsterra social bar
            document.getElementById('adsterra-social-bar-container').style.display = 'none';
        }

        // UPDATE 2: New Ads Section Logic
        function setupAdsToEarn() {
            const container = document.getElementById('ad-task-list');
            container.innerHTML = '';
            if (!currentUser) return;

            const adTasks = [
                { id: 'task1', title: 'Watch Ad & Earn PG', reward: AD_TASK_REWARDS.task1, viewsToday: currentUser.dailyAdViews_1 || 0 },
                { id: 'task2', title: 'Watch Ad & Earn PG', reward: AD_TASK_REWARDS.task2, viewsToday: currentUser.dailyAdViews_2 || 0 },
                { id: 'task3', title: 'Watch Ad & Earn USDT', reward: AD_TASK_REWARDS.task3, viewsToday: currentUser.dailyAdViews_3 || 0 },
            ];

            adTasks.forEach(task => {
                const isCompleted = task.viewsToday >= AD_TASK_DAILY_LIMIT;
                const rewardText = task.reward.type === 'pgCoin' 
                    ? `<span class="task-reward-pg">${task.reward.amount} PG</span>` 
                    : `<span class="task-reward-usdt">${task.reward.amount} USDT</span>`;

                const card = document.createElement('div');
                card.className = 'ad-task-card';
                card.innerHTML = `
                    <div class="ad-task-card-info">
                        <h4>${task.title}</h4>
                        <p>Reward: ${rewardText}</p>
                        <p class="ad-visits-left">Views Left: ${AD_TASK_DAILY_LIMIT - task.viewsToday} / ${AD_TASK_DAILY_LIMIT}</p>
                    </div>
                    <button class="ad-task-button" data-ad-task-id="${task.id}" ${isCompleted ? 'disabled' : ''}>
                        ${isCompleted ? 'Completed' : 'Watch Ad'}
                    </button>`;
                container.appendChild(card);
            });
        }
        
        document.getElementById('ad-task-list').addEventListener('click', async (e) => {
            const button = e.target.closest('.ad-task-button');
            if (!button || button.disabled) return;
            
            const taskId = button.dataset.adTaskId;
            button.disabled = true;
            button.textContent = 'Loading Ad...';

            try {
                await showRandomAdForTask();
                if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                
                let countdown = 10;
                button.textContent = `Please Wait ${countdown}s`;
                const timer = setInterval(async () => {
                    countdown--;
                    button.textContent = `Please Wait ${countdown}s`;
                    if (countdown <= 0) {
                        clearInterval(timer);
                        const rewardInfo = AD_TASK_REWARDS[taskId];
                        const updateField = `dailyAdViews_${taskId.replace('task', '')}`;
                        
                        await grantReward(
                            { [rewardInfo.type]: rewardInfo.amount },
                            { type: 'Ad Watch', details: `Completed ad task ${taskId}` }
                        );
                        await updateDoc(doc(db, 'users', currentUser.id), { [updateField]: increment(1) });
                        
                        showSuccessModal("Reward Claimed!", `Your reward has been added to your balance.`);
                        await fetchAndUpdateCurrentUser();
                        setupAdsToEarn();
                    }
                }, 1000);
            } catch (err) {
                alert('Ad failed to load or was closed. Please try again.');
                await fetchAndUpdateCurrentUser();
                setupAdsToEarn();
            }
        });
        
        async function renderDailyLoginTask() {
            const container = document.getElementById('daily-login-task-container');
            if (!container || !currentUser) return;
            container.innerHTML = '';

            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            const lastClaim = currentUser.lastDailyLoginClaim?.toDate();
            const lastClaimTime = lastClaim ? new Date(lastClaim.getFullYear(), lastClaim.getMonth(), lastClaim.getDate()).getTime() : 0;
            const isClaimedToday = lastClaimTime >= today;

            const card = document.createElement('div');
            card.className = 'task-card';
            card.innerHTML = `<div class="task-card-info"><h4>Daily Login Bonus</h4><p>Reward: <span class="task-reward-pg">${DAILY_LOGIN_PG_REWARD} PG</span></p></div><button class="daily-task-button" id="dailyLoginClaimBtn" ${isClaimedToday ? 'disabled' : ''}>${isClaimedToday ? 'Claimed Today' : 'Claim'}</button>`;
            container.appendChild(card);
            if (!isClaimedToday) document.getElementById('dailyLoginClaimBtn').addEventListener('click', claimDailyLoginBonus);
        }

        async function claimDailyLoginBonus() {
            const button = document.getElementById('dailyLoginClaimBtn');
            if (button) { button.disabled = true; button.textContent = '...'; }
            
            tg.openLink('https://t.me/newtube12');
            
            try {
                await grantReward({ pgCoin: DAILY_LOGIN_PG_REWARD }, { type: 'Daily Login' });
                await updateDoc(doc(db, 'users', currentUser.id), { lastDailyLoginClaim: serverTimestamp() });
                showSuccessModal("Reward Claimed!", `You earned ${DAILY_LOGIN_PG_REWARD} PG for your daily login.`);
                await fetchAndUpdateCurrentUser();
                renderDailyLoginTask(); 
            } catch (error) { 
                alert('Failed to claim daily login bonus.'); 
                if (button) { button.disabled = false; button.textContent = 'Claim'; }
            }
        }

        async function fetchTasks() {
            const taskListContainer = document.getElementById('task-list');
            taskListContainer.innerHTML = '<div class="loader"></div>';
            if (!currentUser) return;
            try {
                const q = query(collection(db, 'tasks'), where("isApproved", "==", true), orderBy("createdAt", "desc"));
                const snapshot = await getDocs(q);
                taskListContainer.innerHTML = '';
                
                let tasksRendered = 0;
                snapshot.forEach(docSnap => {
                    const task = docSnap.data();
                    const isCompleted = currentUser.completedTasks?.includes(docSnap.id);
                    if (task.creatorId === currentUser.id || isCompleted) return;
                    const isLimitReached = (task.limit || 0) > 0 && (task.completionCount || 0) >= task.limit;
                    if (isLimitReached) return; 

                    const card = document.createElement('div');
                    card.className = 'task-card';
                    card.innerHTML = `<div class="task-card-info"><h4>${task.title}</h4><p>Reward: <span class="task-reward-pg">${task.rewardPg || 0} PG</span></p></div><button class="task-button" data-task-id="${docSnap.id}" data-task-url="${task.url}" data-reward-pg="${task.rewardPg || 0}" data-state="start">Go</button>`;
                    taskListContainer.appendChild(card);
                    tasksRendered++;
                });

                if (tasksRendered === 0) {
                    taskListContainer.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No new tasks available for you right now.</p>';
                }

            } catch (error) {
                console.error("Error fetching tasks. IMPORTANT: Check Firestore indexes. Error:", error);
                taskListContainer.innerHTML = '<p style="color:red; text-align:center; grid-column: 1 / -1;">Could not load tasks. Please try again later.</p>';
            }
        }
        
        // UPDATE 5: New Task Completion Flow
        document.getElementById('task-list').addEventListener('click', async (e) => {
            const button = e.target.closest('.task-button');
            if (!button || button.disabled) return;
            
            const { taskId, taskUrl, state } = button.dataset;

            if (state === 'start') {
                tg.openLink(taskUrl);
                button.disabled = true;
                let countdown = 8;
                button.textContent = `Claim in ${countdown}s`;
                const timer = setInterval(() => {
                    countdown--;
                    button.textContent = `Claim in ${countdown}s`;
                    if (countdown <= 0) {
                        clearInterval(timer);
                        button.disabled = false;
                        button.textContent = 'Claim Reward';
                        button.dataset.state = 'claim';
                    }
                }, 1000);
            } else if (state === 'claim') {
                showTaskConfirmationModal(taskId, taskUrl, button);
            }
        });
        
        function showTaskConfirmationModal(taskId, taskUrl, buttonElement) {
            const modal = document.getElementById('taskConfirmModalOverlay');
            const goBackButton = document.getElementById('taskConfirmGoBackBtn');
            const submitButton = document.getElementById('taskConfirmSubmitBtn');

            // Using .onclick to easily remove previous listeners
            goBackButton.onclick = () => {
                tg.openLink(taskUrl);
                modal.classList.remove('show');
            };
            
            submitButton.onclick = async () => {
                modal.classList.remove('show');
                await processTaskClaim(taskId, buttonElement);
            };

            modal.classList.add('show');
        }

        async function processTaskClaim(taskId, button) {
            const taskCard = button.closest('.task-card');
            button.disabled = true;
            button.textContent = 'Verifying...';
            try {
                await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const taskRef = doc(db, 'tasks', taskId);
                    const userDoc = await t.get(userRef);
                    const taskDoc = await t.get(taskRef);
                    if (!userDoc.exists() || !taskDoc.exists()) throw "USER_OR_TASK_NOT_FOUND";
                    if (userDoc.data().completedTasks?.includes(taskId)) throw "ALREADY_COMPLETED";
                    const taskData = taskDoc.data();
                    if ((taskData.limit || 0) > 0 && (taskData.completionCount || 0) >= taskData.limit) throw "TASK_LIMIT_REACHED";
                    
                    t.update(userRef, { completedTasks: arrayUnion(taskId), dailyTasksCompletedCount: increment(1) });
                    t.update(taskRef, { completionCount: increment(1) });
                });
                
                await grantReward({ pgCoin: Number(button.dataset.rewardPg) || 0 }, { type: 'Task Completion'});
                showSuccessModal("Reward Claimed!", `Reward added to your balance.`);
                if (taskCard) taskCard.remove();
                await fetchAndUpdateCurrentUser();

            } catch (error) {
                const errorMessages = { "ALREADY_COMPLETED": "You have already completed this task.", "TASK_LIMIT_REACHED": "This task has reached its completion limit."};
                alert(errorMessages[error] || 'Failed to claim reward.');
                if (error === "ALREADY_COMPLETED" || error === "TASK_LIMIT_REACHED") {
                     if (taskCard) taskCard.remove();
                } else {
                    button.disabled = false; button.textContent = 'Claim Reward';
                }
            }
        }
        
        function renderTaskPackages() {
            const grid = document.getElementById('ad-package-grid');
            grid.innerHTML = '';
            adPackages.forEach(pkg => {
                const card = document.createElement('div');
                card.className = 'ad-package-card';
                card.dataset.packageId = pkg.id;
                card.innerHTML = `<h4>${pkg.tasks} Tasks</h4><p>${pkg.price.toFixed(2)} USDT</p>`;
                grid.appendChild(card);
            });
        }
        
        document.getElementById('ad-package-grid').addEventListener('click', (e) => {
            const card = e.target.closest('.ad-package-card');
            if (!card) return;
            document.querySelectorAll('#ad-package-grid .ad-package-card').forEach(c => c.classList.remove('selected'));
            card.classList.add('selected');
            const packageId = parseInt(card.dataset.packageId, 10);
            selectedAdPackage = adPackages.find(p => p.id === packageId);
        });

        async function renderMyAds() {
            const container = document.getElementById('my-ads-list');
            container.innerHTML = '<div class="loader"></div>';
            if (!currentUser) return;
            try {
                const q = query(collection(db, 'tasks'), where("creatorId", "==", currentUser.id), orderBy("createdAt", "desc"));
                const snapshot = await getDocs(q);
                if (snapshot.empty) { container.innerHTML = '<p style="text-align:center;">You have not created any task advertisements yet.</p>'; return; }
                container.innerHTML = '';
                snapshot.forEach(docSnap => {
                    const ad = docSnap.data();
                    const isCompleted = (ad.completionCount || 0) >= (ad.limit || 0);
                    const card = document.createElement('div');
                    card.className = 'user-ad-item';
                    card.innerHTML = `
                        <h4>${ad.title}</h4>
                        <p class="info-text" style="word-break: break-all;">URL: ${ad.url}</p>
                        <p class="progress-text">Progress: ${(ad.completionCount || 0)} / ${ad.limit}</p>
                        <p class="status-text ${isCompleted ? 'completed' : 'active'}">Status: ${isCompleted ? 'Completed ✅' : 'Active'}</p>
                    `;
                    container.appendChild(card);
                });
            } catch (error) {
                console.error("Error fetching my ads:", error);
                container.innerHTML = '<p style="text-align:center; color: red;">Could not load your ads.</p>';
            }
        }

        document.getElementById('create-task-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const submitBtn = e.target.querySelector('button[type="submit"]');
            if (!selectedAdPackage) { alert('Please select a task package.'); return; }
            const title = document.getElementById('task-title-input').value.trim();
            const url = document.getElementById('task-url-input').value.trim();
            if (!title || !url) { alert('Please provide both a title and a URL for your task.'); return; }
            if ((currentUser.usdtBalance || 0) < selectedAdPackage.price) { alert('Insufficient USDT balance to purchase this package.'); return; }
            
            submitBtn.disabled = true; submitBtn.textContent = 'Processing...';
            try {
                await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await t.get(userRef);
                    if (!userDoc.exists() || (userDoc.data().usdtBalance || 0) < selectedAdPackage.price) throw new Error("Insufficient balance.");
                    t.update(userRef, { usdtBalance: increment(-selectedAdPackage.price) });
                    const newTaskData = { title, url, rewardPg: USER_CREATED_TASK_REWARD_PG, limit: selectedAdPackage.tasks, completionCount: 0, creatorId: currentUser.id, isApproved: true, createdAt: serverTimestamp() };
                    t.set(doc(collection(db, 'tasks')), newTaskData);
                });
                showSuccessModal("Task Created!", "Your new task is now live for other users to complete.");
                e.target.reset();
                document.querySelectorAll('#ad-package-grid .ad-package-card.selected').forEach(c => c.classList.remove('selected'));
                selectedAdPackage = null;
                document.getElementById('createTaskModalOverlay').classList.remove('show');
                await fetchAndUpdateCurrentUser();
                await renderMyAds();
            } catch (error) {
                console.error("Error creating task:", error);
                alert(`Failed to create task: ${error.message}`);
            } finally {
                submitBtn.disabled = false; submitBtn.textContent = 'Create Task';
            }
        });

        function showSuccessModal(title, message) {
            const modal = document.getElementById('successModalOverlay');
            document.getElementById('successModalTitle').textContent = title;
            document.getElementById('successModalMessage').innerHTML = message;
            modal.classList.add('show');
            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
            setTimeout(() => { modal.classList.remove('show'); }, 4000);
        }
        
        async function renderWithdrawUI() {
            if (!currentUser) return;
            document.getElementById('withdrawUsdtBalance').textContent = (currentUser.usdtBalance || 0).toFixed(4);
            document.getElementById('withdrawPgCoinBalance').textContent = (currentUser.pgCoin || 0).toFixed(3);
        }
        
        document.getElementById('usdtWithdrawalForm').addEventListener('submit', (e) => { e.preventDefault(); handleWithdrawal('usdt', e.target); });
        document.getElementById('pgWithdrawalForm').addEventListener('submit', (e) => { e.preventDefault(); handleWithdrawal('pg', e.target); });

        async function handleWithdrawal(type, form) {
            if (isSubmittingWithdrawal) return;
            isSubmittingWithdrawal = true;
            const submitButton = form.querySelector('button[type="submit"]');
            submitButton.disabled = true; submitButton.textContent = 'Processing...';
            try {
                const method = form.querySelector('select').value;
                const details = form.querySelector('input[type="text"]').value;
                const amount = parseFloat(form.querySelector('input[type="number"]').value);

                let minAmount, fee, balanceField, finalAmountField;
                if (type === 'usdt') {
                    balanceField = 'usdtBalance'; finalAmountField = 'usdAmount'; 
                    minAmount = (method === 'Bkash') ? 0.20 : 0.50;
                    fee = (method === 'Bkash') ? 0.03 : 0.05;
                } else {
                    balanceField = 'pgCoin'; finalAmountField = 'pgAmount';
                    minAmount = (method === 'Bkash') ? 10 : 50;
                    fee = (method === 'Bkash') ? 2 : 5;
                }
                if (isNaN(amount) || amount < minAmount) throw new Error(`Minimum withdrawal is ${minAmount} ${type.toUpperCase()}.`);
                if (amount > (currentUser[balanceField] || 0)) throw new Error(`Insufficient ${type.toUpperCase()} balance.`);

                await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await t.get(userRef);
                    if (!userDoc.exists() || (userDoc.data()[balanceField] || 0) < amount) throw new Error(`Insufficient balance.`);
                    
                    const requestData = { userId: currentUser.id, telegramUsername: currentUser.telegramUsername, method, details, status: 'pending', createdAt: serverTimestamp(), withdrawType: type, fee, totalDeducted: amount };
                    requestData[finalAmountField] = amount - fee;
                    
                    t.set(doc(collection(db, 'withdrawals')), requestData);
                    t.update(userRef, { [balanceField]: increment(-amount), withdrawalCount: increment(1) });
                });

                await fetchAndUpdateCurrentUser();
                form.reset();
                showSuccessModal("Request Sent!", "Your withdrawal request is pending. Check status in the History tab.");
            } catch (error) { 
                alert(`Error: ${error.message}`); 
            } finally { 
                isSubmittingWithdrawal = false;
                submitButton.disabled = false; 
                submitButton.textContent = `Request ${type.toUpperCase()} Withdrawal`; 
                renderWithdrawUI(); 
            }
        }
        
        async function showCombinedHistory() {
            const historyContainer = document.getElementById('combined-history-list');
            const modal = document.getElementById('historyModalOverlay');
            modal.classList.add('show');
            historyContainer.innerHTML = '<div class="loader"></div>';
            try {
                const withdrawalsQuery = query(collection(db, "withdrawals"), where("userId", "==", currentUser.id), limit(25));
                const transactionsQuery = query(collection(db, "transactions"), where("userId", "==", currentUser.id), limit(25));
                const [withdrawalsSnapshot, transactionsSnapshot] = await Promise.all([getDocs(withdrawalsQuery), getDocs(transactionsQuery)]);
                let combinedList = [];
                withdrawalsSnapshot.forEach(docSnap => combinedList.push({ ...docSnap.data(), transactionType: 'Withdrawal', timestamp: docSnap.data().createdAt }));
                transactionsSnapshot.forEach(docSnap => combinedList.push({ ...docSnap.data(), transactionType: docSnap.data().type, timestamp: docSnap.data().createdAt }));
                combinedList.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));

                if (combinedList.length === 0) { historyContainer.innerHTML = '<p style="text-align:center;">No history found.</p>'; return; }
                historyContainer.innerHTML = '';
                let lastDate = null;
                const BDT_PER_USDT = 120, BDT_PER_PG = 2; 

                combinedList.forEach(data => {
                    if (!data.timestamp) return; 
                    const date = data.timestamp.toDate();
                    const formattedDate = date.toLocaleDateString('en-CA').replace(/-/g, '.');
                    const formattedTime = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                    if (formattedDate !== lastDate) {
                        const dateHeader = document.createElement('div');
                        dateHeader.className = 'history-date-header'; dateHeader.textContent = formattedDate;
                        historyContainer.appendChild(dateHeader); lastDate = formattedDate;
                    }
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    let sign = '+', bdtAmount = 0;
                    if (data.transactionType === 'Withdrawal') { sign = '-'; bdtAmount = data.withdrawType === 'pg' ? (data.totalDeducted || 0) * BDT_PER_PG : (data.totalDeducted || 0) * BDT_PER_USDT; } 
                    else if (data.pgAmount) { bdtAmount = (data.pgAmount || 0) * BDT_PER_PG; } 
                    else if (data.usdAmount) { bdtAmount = (data.usdAmount || 0) * BDT_PER_USDT; }
                    
                    let status = data.status || 'Success', statusClass = status.toLowerCase();
                    if (['approved', 'completed', 'successful'].includes(statusClass)) { status = 'Success'; statusClass = 'success'; }
                    item.innerHTML = `
                        <div class="history-item-left"><strong>${data.transactionType || 'Transaction'}</strong><small>${formattedTime}</small></div>
                        <div class="history-item-right"><strong>${sign}৳${bdtAmount.toFixed(1)}</strong><small class="status-${statusClass}">${status}</small></div>`;
                    historyContainer.appendChild(item);
                });
            } catch (error) {
                console.error("Error fetching combined history:", error);
                historyContainer.innerHTML = '<p style="color:red;text-align:center;">Error loading history.</p>';
            }
        }
        
        function renderReferralStats() {
            if (!currentUser) return;
            document.getElementById('referral-userid').textContent = currentUser.id;
            document.getElementById('referral-lifetime-referrals').textContent = currentUser.referralCount || 0;
            document.getElementById('referral-usdt-balance').textContent = (currentUser.usdtBalance || 0).toFixed(4);
            document.getElementById('referral-commission-pg').textContent = (currentUser.lifetimeCommissionPg || 0).toFixed(3);
        }
        
        // --- AD PROVIDER FUNCTIONS ---
        const showMonetagAd = () => new Promise((res, rej) => typeof show_9442539 === 'function' ? show_9442539().then(res).catch(rej) : rej('Monetag SDK missing'));
        const showGigaPubAd = () => new Promise((res, rej) => typeof window.showGiga === 'function' ? window.showGiga("main").then(res).catch(rej) : rej('GigaPub SDK missing'));
        const showAdextraAd = () => new Promise((res, rej) => typeof p_adextra === 'function' ? p_adextra({ onSuccess: res, onError: (e) => rej(new Error("Adextra ad failed: " + e))}) : rej('Adextra SDK missing'));

        async function showRandomAdForTask() {
            // UPDATE 2: Add Adextra to the random pool
            const adProviders = [showMonetagAd, showGigaPubAd, showAdextraAd];
            const randomAdProvider = adProviders[Math.floor(Math.random() * adProviders.length)];
            try { await randomAdProvider(); } 
            catch(err) { console.warn("An ad provider failed, trying another one...", err);
                const otherProviders = adProviders.filter(p => p !== randomAdProvider);
                if (otherProviders.length > 0) {
                    const fallbackProvider = otherProviders[Math.floor(Math.random() * otherProviders.length)];
                    try { await fallbackProvider(); } catch(fallbackErr) { console.error("Fallback ad provider also failed:", fallbackErr); throw fallbackErr; }
                } else { throw err; }
            }
        }
        
        document.getElementById('history-btn').addEventListener('click', showCombinedHistory);
        document.getElementById('closeHistoryBtn').addEventListener('click', () => document.getElementById('historyModalOverlay').classList.remove('show'));
        document.getElementById('show-create-task-btn').addEventListener('click', () => document.getElementById('createTaskModalOverlay').classList.add('show'));
        document.getElementById('closeTaskModalBtn').addEventListener('click', () => document.getElementById('createTaskModalOverlay').classList.remove('show'));


        document.querySelectorAll('.bottom-nav-item, .header-icon-btn').forEach(link => {
            if(!link.dataset.tabTarget) return;
            link.addEventListener('click', async (e) => {
                e.preventDefault();
                const targetId = link.dataset.tabTarget;
                if (!currentUser || document.querySelector(targetId)?.classList.contains('active')) return;
                
                stopVideoSectionActivity();
                document.querySelectorAll('.bottom-nav-item.active, .header-icon-btn.active, .content-section.active').forEach(el => el.classList.remove('active'));
                
                document.querySelectorAll(`[data-tab-target="${targetId}"]`).forEach(l => l.classList.add('active'));
                document.querySelector(targetId).classList.add('active');

                switch(targetId) {
                    case '#home-content': 
                        updateMiningPowerUI(); 
                        await renderDailyLoginTask();
                        await renderDailyRewardTasks();
                        break;
                    case '#ads-content': setupAdsToEarn(); break;
                    case '#video-content': 
                        await fetchContent();
                        lastRewardedWatchSecond = currentUser.totalVideoWatchSecondsToday || 0;
                        // UPDATE 3: Show Adsterra social bar
                        const adsterraContainer = document.getElementById('adsterra-social-bar-container');
                        adsterraContainer.style.display = 'block';
                        if (!adsterraContainer.querySelector('script')) {
                            const script = document.createElement('script');
                            script.type = 'text/javascript';
                            script.src = '//suggestbingo.com/55/02/5c/55025c7818ef24365e262ed0d416a7a0.js';
                            adsterraContainer.appendChild(script);
                        }
                        break;
                    case '#referral-content': renderReferralStats(); break;
                    case '#task-content': 
                        renderTaskPackages();
                        await renderMyAds(); 
                        await fetchTasks();
                        break;
                    case '#lottery-content': await renderLotteryUI(); break;
                    case '#withdraw-content': 
                        await renderWithdrawUI();
                        if (!withdrawalUISetup) { setupWithdrawalTypeSwitcher(); withdrawalUISetup = true; }
                        break;
                }
            });
        });
        
        function setupWithdrawalTypeSwitcher() {
            const usdtBtn = document.getElementById('withdraw-type-usdt'), pgBtn = document.getElementById('withdraw-type-pg');
            const usdtForm = document.getElementById('usdt-withdraw-form'), pgForm = document.getElementById('pg-withdraw-form');
            usdtBtn.addEventListener('click', () => { usdtBtn.classList.add('active'); pgBtn.classList.remove('active'); usdtForm.style.display = 'block'; pgForm.style.display = 'none'; });
            pgBtn.addEventListener('click', () => { pgBtn.classList.add('active'); usdtBtn.classList.remove('active'); pgForm.style.display = 'block'; usdtForm.style.display = 'none'; });
        }
        
        const startMiningButton = document.getElementById('mining-button');
        const statusMessageEl = document.getElementById('status-message');
        const balanceEl = document.getElementById('balance');

        function formatSecondsToHHMMSS(seconds) {
            const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
            const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
            const s = String(Math.floor(seconds % 60)).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }
        
        async function initializeMiningState() {
            if (!currentUser) return;
            if (miningTimerInterval) clearInterval(miningTimerInterval);
            if (miningDisplayUpdateInterval) clearInterval(miningDisplayUpdateInterval);

            const miningStartTime = currentUser.miningStartTime?.toDate().getTime();
            if (miningStartTime) {
                const now = Date.now();
                const sessionEndTime = miningStartTime + MINING_SESSION_DURATION_SECONDS * 1000;
                if (now >= sessionEndTime) {
                    await stopMiningSession(true); 
                } else {
                    setMiningUIState('mining');
                    miningTimerInterval = setInterval(updateMiningUI, 1000);
                    miningDisplayUpdateInterval = setInterval(updateMiningDisplay, 100);
                }
            } else {
                setMiningUIState('ready');
            }
        }

        function updateMiningUI() { // Updates time remaining
            if (!currentUser || !currentUser.miningStartTime) { stopMiningSession(false); return; }
            const miningStartTime = currentUser.miningStartTime.toDate().getTime();
            const now = Date.now();
            const sessionEndTime = miningStartTime + MINING_SESSION_DURATION_SECONDS * 1000;
            const timeLeftSeconds = Math.max(0, Math.round((sessionEndTime - now) / 1000));
            statusMessageEl.textContent = `Time Remaining: ${formatSecondsToHHMMSS(timeLeftSeconds)}`;
            if (timeLeftSeconds <= 0) stopMiningSession(true);
        }
        
        function updateMiningDisplay() { // Updates balance VFX
            if (!currentUser || !currentUser.miningStartTime) return;
            const miningStartTime = currentUser.miningStartTime.toDate().getTime();
            const elapsedSeconds = (Date.now() - miningStartTime) / 1000;
            const sessionProgress = Math.min(1, elapsedSeconds / MINING_SESSION_DURATION_SECONDS);
            const totalRewardForSession = (getCurrentHashPower() / BASE_HASH_POWER) * MINING_SESSION_REWARD_PG_PER_10HS;
            const minedSoFar = totalRewardForSession * sessionProgress;
            const displayBalance = (currentUser.pgCoin || 0) + minedSoFar;
            balanceEl.textContent = displayBalance.toFixed(6); // Higher precision for live effect
        }

        function setMiningUIState(state) {
            if (state === 'mining') {
                startMiningButton.disabled = true;
                startMiningButton.textContent = 'Mining...';
            } else {
                startMiningButton.disabled = false;
                startMiningButton.textContent = 'Start Mining';
                statusMessageEl.textContent = 'Press \'Start\' to begin mining.';
                balanceEl.textContent = (currentUser?.pgCoin || 0).toFixed(3);
            }
        }

        async function startMiningSession() {
            startMiningButton.disabled = true; startMiningButton.textContent = 'Loading Ad...';
            try {
                await showRandomAdForTask();
                const userRef = doc(db, 'users', currentUser.id);
                await updateDoc(userRef, { miningStartTime: serverTimestamp() });
                await fetchAndUpdateCurrentUser();
                setMiningUIState('mining');
                miningTimerInterval = setInterval(updateMiningUI, 1000);
                miningDisplayUpdateInterval = setInterval(updateMiningDisplay, 100);
            } catch (err) {
                alert('Ad failed to load. Please try again to start mining.');
                setMiningUIState('ready');
            }
        }

        async function stopMiningSession(grantRewardOnStop) {
            clearInterval(miningTimerInterval); miningTimerInterval = null;
            clearInterval(miningDisplayUpdateInterval); miningDisplayUpdateInterval = null;
            const userRef = doc(db, 'users', currentUser.id);
            
            if (grantRewardOnStop && currentUser.miningStartTime) {
                const reward = (getCurrentHashPower() / BASE_HASH_POWER) * MINING_SESSION_REWARD_PG_PER_10HS;
                await grantReward({pgCoin: reward}, {type: 'Mining'});
                await updateDoc(userRef, { miningStartTime: null });
                showSuccessModal("Session Complete!", `You mined ${reward.toFixed(4)} PG Coin.`);
            } else if (currentUser && currentUser.miningStartTime) {
                await updateDoc(userRef, { miningStartTime: null });
            }
            await fetchAndUpdateCurrentUser();
            setMiningUIState('ready');
        }
        
        startMiningButton.addEventListener('click', startMiningSession);

        // --- Lottery Functions ---
        function calculatePrize() {
            const prizeTypeRand = Math.random();
            if (prizeTypeRand < 0.5) { return { type: 'pg', amount: Math.random() * (0.5 - 0.001) + 0.001 }; } 
            else { return { type: 'usdt', amount: Math.random() * (0.01 - 0.0001) + 0.0001 }; }
        }

        async function renderLotteryUI() {
            if (!currentUser) return;
            const spinButton = document.getElementById('spinButton'), spinCountEl = document.getElementById('spin-count');
            const spins = currentUser.lotterySpins || 0;
            spinCountEl.textContent = spins;
            const lastSpinAd = currentUser.lastDailyAdSpin?.toDate();
            const hasClaimedDailyAdSpin = lastSpinAd ? lastSpinAd.getTime() > (Date.now() - 24*60*60*1000) : false;

            if (spins > 0) { spinButton.textContent = 'SPIN NOW'; spinButton.dataset.action = 'spin'; spinButton.disabled = false; } 
            else if (!hasClaimedDailyAdSpin) { spinButton.textContent = 'Watch Ad for 1 Spin'; spinButton.dataset.action = 'watch_ad'; spinButton.disabled = false; } 
            else { spinButton.textContent = 'No Spins Left'; spinButton.dataset.action = 'none'; spinButton.disabled = true; }
        }

        async function handleLotterySpin() {
            const spinButton = document.getElementById('spinButton'), resultDiv = document.getElementById('lottery-result');
            if (!currentUser || (currentUser.lotterySpins || 0) < 1) { alert("You don't have any spins!"); return; }
            spinButton.disabled = true;

            try {
                await updateDoc(doc(db, 'users', currentUser.id), { lotterySpins: increment(-1), totalSpinsUsed: increment(1) });
                await fetchAndUpdateCurrentUser(); 
                const finalPrize = calculatePrize();
                const currencyLabel = finalPrize.type.toUpperCase(), precision = finalPrize.type === 'pg' ? 4 : 6;
                let animationInterval = setInterval(() => {
                    const r = calculatePrize();
                    resultDiv.innerHTML = `<span class="value">${r.amount.toFixed(r.type === 'pg' ? 4 : 6)} ${r.type.toUpperCase()}</span>`;
                }, 75); 
                setTimeout(async () => {
                    clearInterval(animationInterval);
                    resultDiv.innerHTML = `You Won: <span class="value">${finalPrize.amount.toFixed(precision)} ${currencyLabel}</span>`;
                    await grantReward(finalPrize.type === 'pg' ? { pgCoin: finalPrize.amount } : { usdt: finalPrize.amount }, { type: 'Lottery Win' });
                    await fetchAndUpdateCurrentUser();
                    await renderLotteryUI();
                }, 2000);
            } catch (error) { console.error("Error during spin:", error); alert("An error occurred. Please try again."); spinButton.disabled = false; }
        }
        
        // UPDATE 1: New Lottery Ad Spin Logic
        async function handleDailyAdSpin() {
            const button = document.getElementById('spinButton');
            button.disabled = true; 
            button.textContent = 'Loading Ad...';
            try {
                await showRandomAdForTask();
                let countdown = 14;
                button.textContent = `Please Wait ${countdown}s`;
                const timer = setInterval(async () => {
                    countdown--;
                    button.textContent = `Please Wait ${countdown}s`;
                    if (countdown <= 0) {
                        clearInterval(timer);
                        button.textContent = 'Claiming...';
                        await updateDoc(doc(db, 'users', currentUser.id), { lotterySpins: increment(1), lastDailyAdSpin: serverTimestamp() });
                        await fetchAndUpdateCurrentUser();
                        showSuccessModal("Spin Awarded!", "You've earned 1 free spin for watching an ad.");
                        await renderLotteryUI();
                    }
                }, 1000);
            } catch (error) { 
                alert('Ad failed to load or was closed. Please try again.'); 
                await renderLotteryUI();
            } 
        }

        document.getElementById('spinButton').addEventListener('click', async () => {
            const action = document.getElementById('spinButton').dataset.action;
            if (action === 'spin') await handleLotterySpin();
            else if (action === 'watch_ad') await handleDailyAdSpin();
        });

        function setupUserIdDisplay(userId) {
            const userIdContainer = document.getElementById('header-user-id');
            userIdContainer.querySelector('span').textContent = `ID: ${userId}`;
            userIdContainer.addEventListener('click', () => {
                navigator.clipboard.writeText(userId).then(() => {
                    if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                    showSuccessModal("Copied!", `User ID ${userId} copied to clipboard.`);
                });
            });
        }
        
        // --- NEW Daily Rewards Functions ---
        async function renderDailyRewardTasks() {
            if (!currentUser) return;
            const container = document.getElementById('daily-rewards-container');
            container.innerHTML = '';

            const tasks = [
                { id: 'ref_1', req: 1, type: 'referral', rewardText: '0.002 USDT', reward: { usdt: 0.002 } },
                { id: 'ref_2', req: 2, type: 'referral', rewardText: '1 Lottery Spin', reward: { spins: 1 } },
                { id: 'ref_3', req: 3, type: 'referral', rewardText: '0.3 PG Coin', reward: { pgCoin: 0.3 } },
                { id: 'ref_5', req: 5, type: 'referral', rewardText: '2x Mining Speed (24h)', reward: { boost: { power: BASE_HASH_POWER, durationHours: 24 } } },
                { id: 'ref_10', req: 10, type: 'referral', rewardText: '5 Spins + 0.01 USDT', reward: { spins: 5, usdt: 0.01 } },
                { id: 'task_5', req: 5, type: 'task_completion', rewardText: '0.09 PG Coin', reward: { pgCoin: 0.09 } },
                { id: 'browse_1', req: 1, type: 'browse', rewardText: '0.02 PG Coin', reward: { pgCoin: 0.02 } },
                { id: 'browse_2', req: 1, type: 'browse', rewardText: '0.0005 USDT', reward: { usdt: 0.0005 } },
            ];

            const claimed = currentUser.dailyRewardsClaimed || [];
            const dailyRefCount = currentUser.dailyReferralCount || 0;
            const dailyTaskCount = currentUser.dailyTasksCompletedCount || 0;

            tasks.forEach(task => {
                let progress = 0, isComplete = false, isClaimed = claimed.includes(task.id);
                let buttonState = isClaimed ? 'disabled' : '';
                let buttonText = isClaimed ? 'Claimed' : 'Claim';
                let description = '';

                if (task.type === 'referral') {
                    progress = Math.min(dailyRefCount, task.req); isComplete = dailyRefCount >= task.req;
                    description = `Refer ${task.req} friends today. (${progress}/${task.req})`;
                } else if (task.type === 'task_completion') {
                    progress = Math.min(dailyTaskCount, task.req); isComplete = dailyTaskCount >= task.req;
                    description = `Complete ${task.req} tasks today. (${progress}/${task.req})`;
                } else if (task.type === 'browse') {
                    const browseField = task.id === 'browse_1' ? 'dailyBrowseVisit1Completed' : 'dailyBrowseVisit2Completed';
                    isComplete = currentUser[browseField] === true;
                    description = `Visit a website for 15s. (${isComplete ? '1/1' : '0/1'})`;
                    buttonText = isClaimed ? 'Claimed' : (isComplete ? 'Claim' : 'Go');
                }

                if (!isComplete && !isClaimed && task.type !== 'browse') {
                    buttonState = 'disabled';
                }
                
                const card = document.createElement('div');
                card.className = 'daily-reward-card';
                card.innerHTML = `
                    <div class="daily-reward-card-info">
                        <h4>Reward: ${task.rewardText}</h4>
                        <p class="progress-text">${description}</p>
                        <div class="progress-bar"><div class="progress-bar-inner" style="width: ${isComplete ? 100 : (progress/task.req)*100}%"></div></div>
                    </div>
                    <button class="daily-task-button" data-task-id="${task.id}" ${buttonState}>${buttonText}</button>`;
                container.appendChild(card);
            });
        }
        
        document.getElementById('daily-rewards-container').addEventListener('click', async (e) => {
            if (!e.target.matches('.daily-task-button') || e.target.disabled) return;
            const button = e.target;
            const taskId = button.dataset.taskId;

            if (taskId.startsWith('browse_')) {
                const isBrowse1 = taskId === 'browse_1';
                const browseField = isBrowse1 ? 'dailyBrowseVisit1Completed' : 'dailyBrowseVisit2Completed';
                
                if (currentUser[browseField]) { // Is complete, now claim
                    await claimDailyReward(taskId, button);
                } else { // Needs to visit
                    button.disabled = true;
                    const originalText = button.textContent;
                    let countdown = 15;
                    button.textContent = `Wait ${countdown}s`;
                    dailyBrowseTimer = setInterval(() => {
                        countdown--;
                        button.textContent = `Wait ${countdown}s`;
                        if (countdown <= 0) {
                            clearInterval(dailyBrowseTimer);
                            button.textContent = 'Claim';
                            button.disabled = false;
                            updateDoc(doc(db, 'users', currentUser.id), { [browseField]: true });
                            currentUser[browseField] = true; // Update local state
                        }
                    }, 1000);
                    tg.openLink('https://suggestbingo.com/qr4ys636p?key=0098a30fe6a07c76104029fc8045e1bd');
                }
            } else { // For referral and task completion rewards
                await claimDailyReward(taskId, button);
            }
        });

        async function claimDailyReward(taskId, button) {
             button.disabled = true; button.textContent = '...';
             try {
                // Find task reward object again (to avoid storing complex objects in data attributes)
                const taskDefs = [
                    { id: 'ref_1', reward: { usdt: 0.002 } }, { id: 'ref_2', reward: { spins: 1 } }, { id: 'ref_3', reward: { pgCoin: 0.3 } },
                    { id: 'ref_5', reward: { boost: { power: BASE_HASH_POWER, durationHours: 24 } } },
                    { id: 'ref_10', reward: { spins: 5, usdt: 0.01 } }, { id: 'task_5', reward: { pgCoin: 0.09 } },
                    { id: 'browse_1', reward: { pgCoin: 0.02 } }, { id: 'browse_2', reward: { usdt: 0.0005 } },
                ];
                const task = taskDefs.find(t => t.id === taskId);
                if (!task) throw new Error("Task definition not found.");

                const userRef = doc(db, 'users', currentUser.id);

                if (task.reward.boost) {
                    const expiryDate = new Date(Date.now() + task.reward.boost.durationHours * 60 * 60 * 1000);
                    await updateDoc(userRef, { tempHashBoosts: arrayUnion({ power: task.reward.boost.power, expiresAt: Timestamp.fromDate(expiryDate) }), dailyRewardsClaimed: arrayUnion(taskId) });
                    showSuccessModal("Boost Activated!", `You've activated a ${task.reward.boost.power} H/s boost for 24 hours.`);
                } else {
                    await grantReward(task.reward, { type: 'Daily Reward', details: `Claimed ${taskId}` });
                    await updateDoc(userRef, { dailyRewardsClaimed: arrayUnion(taskId) });
                    showSuccessModal("Reward Claimed!", `Your reward has been added to your balance.`);
                }

                await fetchAndUpdateCurrentUser();
                await renderDailyRewardTasks();
             } catch(err) {
                alert("Failed to claim reward. " + err.message);
                button.disabled = false; button.textContent = 'Claim';
             }
        }
        
        // --- NEW Welcome Popup Functions ---
        function showWelcomePopup() {
            const overlay = document.getElementById('welcomeModalOverlay');
            const checkbox = document.getElementById('welcome-agree-checkbox');
            const confirmBtn = document.getElementById('welcomeConfirmBtn');
            
            overlay.classList.add('show');

            checkbox.addEventListener('change', () => {
                confirmBtn.disabled = !checkbox.checked;
            });

            confirmBtn.addEventListener('click', async () => {
                confirmBtn.disabled = true; confirmBtn.textContent = "Processing...";
                
                try {
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, { isActivated: true });

                    // Now, reward the referrer if one exists
                    if (currentUser.referredBy) {
                        const referrerRef = doc(db, 'users', currentUser.referredBy);
                        await runTransaction(db, async (t) => {
                            const referrerDoc = await t.get(referrerRef);
                            if (referrerDoc.exists()) {
                                t.update(referrerRef, {
                                    lotterySpins: increment(1),
                                    referralCount: increment(1),
                                    dailyReferralCount: increment(1) // also increment daily counter
                                });
                            }
                        });
                    }
                    overlay.classList.remove('show');
                } catch (error) {
                    console.error("Error activating account:", error);
                    alert("Could not confirm. Please try again.");
                    confirmBtn.disabled = false; confirmBtn.textContent = "Confirm & Start";
                }
            });
        }


        async function main() {
            try {
                if (!tg.initDataUnsafe?.user) { document.body.innerHTML = `<div class="card" style="margin-top: 50px;"><h3>Error</h3><p>This app can only be launched from Telegram.</p></div>`; return; }
                tg.ready(); tg.expand();
                
                const initStatus = await initializeUser(tg.initDataUnsafe.user, tg.initDataUnsafe.start_param);
                if (!initStatus) return; // User is banned

                setupUserIdDisplay(currentUser.id);

                document.getElementById('referral-userid').addEventListener('click', () => {
                    if (currentUser?.id) navigator.clipboard.writeText(currentUser.id).then(() => {
                        if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                        showSuccessModal("Copied!", `User ID ${currentUser.id} copied to clipboard.`);
                    });
                });
                
                if (!initStatus.isActivated) {
                    showWelcomePopup();
                }

                await renderDailyLoginTask();
                await renderDailyRewardTasks();

            } catch (error) {
                console.error("Initialization failed:", error);
                document.body.innerHTML = `<div class="card" style="margin-top: 50px;"><h3>Application Error</h3><p>Could not initialize. Please restart.</p><p style="font-size: 0.8em; color: #888;">Error: ${error.message}</p></div>`;
            }
        }
        main();
    </script>

</body>
</html>
```