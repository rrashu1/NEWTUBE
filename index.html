
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEWTUBE - Watch & Earn</title>
    <script src="https://telegram.org/js/telegram-web-app.js?56"></script>
    
    <!-- Adexium Ads SDK -->
    <script type="text/javascript" src="https://cdn.tgads.space/assets/js/adexium-widget.min.js"></script>
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const adexiumWidget = new AdexiumWidget({wid: '12c05dba-2642-46f2-950f-cee6575119c9', adFormat: 'interstitial'});
                adexiumWidget.autoMode();
            } catch (e) {
                console.error("Adexium SDK failed to initialize:", e);
            }
        });
    </script>
    
    <!-- Other Ad Libraries -->
    <script src='//libtl.com/sdk.js' data-zone='9442539' data-sdk='show_9442539'></script>
    <script src="https://ad.gigapub.tech/script?id=846"></script>
    <!-- Adextra Ad Script -->
    <script async src="https://partner.adextra.io/jt/fa6b30e404e1046793d70db4a424966f97960abe.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Poppins:wght@400;600;700&family=Roboto+Mono:wght@700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        :root {
            --primary-accent-color: #E50914; /* UPDATED: Netflix Red */
            --primary-accent-hover-color: #B20710; /* UPDATED: Darker Red */
            --dark-bg: #141414; /* UPDATED: Almost Black */
            --card-bg: #1F1F1F; /* UPDATED: Dark Grey */
            --header-bg: #1F1F1F; /* UPDATED: Dark Grey */
            --text-light: #FFFFFF; /* UPDATED: White */
            --text-muted: #A0A0A0; /* UPDATED: Light Grey */
            --border-color: #303030; /* UPDATED: Darker Grey */
            --success-color: #28a745;
            --disabled-color: #404040; /* UPDATED */
            --pg-coin-color: #ff9900;
        }
        body { 
            background-color: var(--dark-bg); 
            color: var(--text-light); 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            margin: 0; 
            padding: 70px 0 90px;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }
        .main-header { 
            background-color: var(--header-bg); 
            padding: 10px 15px; 
            border-bottom: 1px solid var(--border-color); 
            position: fixed; top: 0; left: 0; right: 0; z-index: 1000; 
            display: flex; justify-content: space-between; align-items: center; 
            height: 50px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .header-left { display: flex; align-items: center; gap: 10px; }
        .site-branding { display: flex; flex-direction: column; align-items: flex-start; }
        .site-title { font-size: 1.4em; color: var(--primary-accent-color); font-weight: 700; margin: 0; line-height: 1; }
        .user-id-display { font-size: 0.65em; color: var(--text-muted); font-family: 'Roboto Mono', monospace; cursor: pointer; display: flex; align-items: center; gap: 4px; padding: 2px 4px; border-radius: 4px; transition: background-color .2s;}
        .user-id-display:hover { background-color: #303030; }
        .user-id-display .copy-icon { width: 12px; height: 12px; }
        .header-right { display: flex; align-items: center; gap: 5px; }
        
        .header-icon-btn { position: relative; cursor: pointer; background: none; border: none; color: var(--text-light); padding: 5px; }
        .header-icon-btn svg { width: 26px; height: 26px; }
        
        .referral-button-vfx {
            background-color: var(--success-color);
            color: #ffffff;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            animation: referral-glow 2s infinite ease-in-out;
        }
        @keyframes referral-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.6); }
            50% { box-shadow: 0 0 12px rgba(40, 167, 69, 1), 0 0 18px rgba(40, 167, 69, 0.9); }
        }

        .balance-display { background-color: rgba(255,255,255,0.08); color: var(--text-light); padding: 6px 12px; border-radius: 20px; font-weight: 600; font-size: 0.85em; }
        .balance-display .pg-label { color: var(--pg-coin-color); }

        .bottom-nav {
            position: fixed; bottom: 0; left: 0; right: 0;
            background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 8px 0;
            z-index: 1000;
        }
        .bottom-nav-item {
            display: flex; flex-direction: column; align-items: center;
            gap: 4px; color: var(--text-muted); text-decoration: none;
            font-size: 0.75rem; font-weight: 500;
            padding: 5px 10px; border-radius: 8px;
            transition: color 0.2s, background-color 0.2s;
        }
        .bottom-nav-item svg { width: 24px; height: 24px; }
        .bottom-nav-item:hover { color: var(--primary-accent-color); }
        .bottom-nav-item.active { color: var(--primary-accent-color); }

        .content-section { display: none; padding-top: 25px; } 
        .content-section.active { display: block; animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .section-title { font-size: 1.6em; margin-bottom: 25px; padding-bottom: 10px; color: var(--text-light); border-bottom: 2px solid var(--border-color); font-weight: 600; }
        .sub-section-title { font-size: 1.2em; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-top: 40px; margin-bottom: 20px; font-weight: 500; }
        .search-container { display: flex; gap: 10px; margin-bottom: 20px; }
        .search-container input { flex-grow: 1; padding: 12px; box-sizing: border-box; border-radius: 8px; border: 1px solid #444; background-color: #333; color: var(--text-light); font-size: 1em; }
        .search-container button { padding: 12px 18px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: #ffffff; font-weight: bold; cursor: pointer; }
        .search-container button#clearSearchBtn { background-color: #6c757d; }
        .item-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; }
        
        .movie-item, .ad-task-card, .task-card, .ad-package-card, .user-ad-item, .withdraw-package-card { background-color: var(--card-bg); border-radius: 12px; overflow: hidden; display: flex; flex-direction: column; border: 1px solid var(--border-color); transition: transform 0.2s, box-shadow 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .movie-item { cursor: pointer; } 
        .movie-item:hover{ transform: scale(1.03); box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
        .thumbnail-container { width: 100%; aspect-ratio: 16/9; background-color: #333; position: relative; }
        .thumbnail-container img { width: 100%; height: 100%; object-fit: cover; }
        .player-container { width: 100%; aspect-ratio: 16/9; background: #000; }
        .player-container iframe { width: 100%; height: 100%; border: none; }
        .movie-item-info, .ad-task-card-info { padding: 15px; flex-grow: 1; text-align:center;}
        .movie-item-info h4, .ad-task-card h4, .ad-package-card h4, .user-ad-item h4, .withdraw-package-card h4 { margin: 0 0 8px; font-size: 1.1em; line-height: 1.3; }
        .movie-reward { color: var(--pg-coin-color); font-weight: bold; font-size: 0.9em; margin: 0; }
        
        .ad-task-card p { margin: 8px 0 15px; color: var(--text-muted); font-weight: bold; }
        .task-reward-pg { color: var(--pg-coin-color); }
        .task-reward-usdt { color: var(--success-color); }
        .ad-task-button { width: 100%; padding: 12px; border: none; border-radius: 0 0 10px 10px; font-weight: bold; cursor: pointer; background-color: var(--primary-accent-color); color: #ffffff; transition: background-color .2s; margin-top: auto; font-size: 1em;}
        .task-button, .daily-task-button { width: auto; flex-shrink: 0; padding: 10px 20px; font-size: 0.9em; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; background-color: var(--primary-accent-color); color: #ffffff; transition: background-color .2s; margin-top: 0; }
        .task-button:disabled, .ad-task-button:disabled, .daily-task-button:disabled { background-color: var(--disabled-color); color: #aaa; cursor: not-allowed; }
        
        .card { max-width: 500px; margin: 20px auto; background-color: var(--card-bg); padding: 30px; border-radius: 12px; border: 1px solid var(--border-color); text-align: center; }
        .card-icon { width: 50px; height: 50px; margin: 0 auto 15px; color: var(--primary-accent-color); }
        .card h3 { margin-top: 0; font-size: 1.4em; } .card p { color: var(--text-muted); line-height: 1.6; }
        .form-group { margin-bottom: 20px; text-align: left; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-muted); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; box-sizing: border-box; border-radius: 8px; border: 1px solid #444; background-color: #333; color: var(--text-light); font-size: 1em; }
        .form-button { width: 100%; padding: 14px; border: none; border-radius: 8px; background-color: var(--primary-accent-color); color: #ffffff; font-weight: bold; font-size: 1em; cursor: pointer; transition: background-color 0.2s; }
        .form-button:hover:not(:disabled) { background-color: var(--primary-accent-hover-color); }
        .form-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; color: #aaa; }
        
        .referral-link-wrapper { display: flex; gap: 10px; margin-top: 20px; }
        .referral-link-wrapper input { flex-grow: 1; text-align: center; }
        .referral-link-wrapper button { width: auto; flex-shrink: 0; padding: 0 15px; }
        
        .loader { border: 4px solid var(--border-color); border-top: 4px solid var(--primary-accent-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 50px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal-overlay.show { display: flex; }
        .modal-content { background-color: var(--card-bg); color: var(--text-light); padding: 30px 40px; border-radius: 15px; text-align: center; transform: scale(0.9); opacity: 0; animation: modal-pop-in 0.3s forwards; max-width: 90%; width: 450px; border: 1px solid var(--border-color); }
        @keyframes modal-pop-in { to { transform: scale(1); opacity: 1; } }
        .success-modal-icon { width: 70px; height: 70px; border-radius: 50%; background-color: var(--success-color); display: flex; justify-content: center; align-items: center; font-size: 40px; font-weight: bold; color: white; margin: 0 auto 20px; animation: icon-pop-in 0.5s 0.2s backwards; }
        @keyframes icon-pop-in { 0% { transform: scale(0); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
        .modal-content h3 { margin: 0 0 10px; font-size: 1.6em; }
        .modal-content p { margin: 0; color: var(--text-muted); font-size: 1em; white-space: pre-wrap;}
        .history-modal, .task-modal, .welcome-modal, .task-confirm-modal, .notice-modal { background-color: var(--card-bg); color: var(--text-light); padding: 20px; border-radius: 15px; text-align: left; width: 90%; max-height: 90vh; display: flex; flex-direction: column; }
        .notice-modal { max-width: 400px; }
        .history-modal, .task-modal, .welcome-modal, .task-confirm-modal { max-width: 500px; }

        .history-modal h3, .task-modal h3, .welcome-modal h3, .task-confirm-modal h3, .notice-modal h3 { text-align: center; margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        #combined-history-list, .task-modal .modal-body, .welcome-modal .modal-body, .task-confirm-modal .modal-body, .notice-modal .modal-body { overflow-y: auto; flex-grow: 1; margin-bottom: 15px; }
        .task-confirm-modal .modal-body { text-align: center; }
        .task-confirm-modal-buttons { display: flex; gap: 10px; margin-top: 20px; }
        .task-confirm-modal-buttons button { flex: 1; }
        .notice-modal .modal-body ul { padding-left: 20px; list-style-type: '✓ '; }
        .notice-modal .modal-body li { margin-bottom: 10px; line-height: 1.6; }
        
        .sub-card { background-color: #2a2a2a; padding: 20px; border-radius: 10px; margin-bottom: 25px; }
        .info-text { font-size: 0.9em; color: var(--text-muted); margin-top: 10px; line-height: 1.5; }
        
        .task-card, .daily-reward-card { background-color: var(--card-bg); border-radius: 8px; display: flex; flex-direction: row; justify-content: space-between; align-items: center; padding: 15px; transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; border: 1px solid var(--border-color); }
        .task-card:hover, .daily-reward-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(229, 9, 20, 0.15); }
        #ad-task-list.item-grid, #task-list.item-grid, #my-ads-list.item-grid, #daily-tasks-grid { grid-template-columns: 1fr; gap: 15px; display: grid;} 
        .task-card-info, .daily-reward-card-info { padding: 0; flex-grow: 1; text-align: left; }
        .task-card-info h4, .daily-reward-card-info h4 { margin: 0 0 5px; font-size: 1em;}
        .task-card-info p, .daily-reward-card-info p { margin: 5px 0 0; font-size: 0.9em; }

        @keyframes task-pulse {
            0% { box-shadow: 0 4px 12px rgba(229, 9, 20, 0.15); }
            50% { box-shadow: 0 6px 18px rgba(229, 9, 20, 0.25); }
            100% { box-shadow: 0 4px 12px rgba(229, 9, 20, 0.15); }
        }

        #referral-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .profile-stat-item { background-color: var(--dark-bg); padding: 20px; border-radius: 10px; border: 1px solid var(--border-color); }
        .profile-stat-item h4 { margin: 0 0 8px; font-size: 1em; color: var(--text-muted); font-weight: 500;}
        .profile-stat-item p { margin: 0; font-size: 1.5em; font-weight: bold; word-break: break-all; }
        .profile-stat-item .usdt-val { color: var(--success-color); }
        .profile-stat-item .pg-val { color: var(--pg-coin-color); }
        .profile-stat-item .ref-val { color: var(--primary-accent-color); }

        .history-list-container { display: flex; flex-direction: column; gap: 0; }
        .history-date-header { padding: 15px 5px 5px; color: var(--text-muted); font-weight: 600; font-size: 0.9em; }
        .history-item { display: flex; justify-content: space-between; align-items: center; padding: 15px 5px; border-bottom: 1px solid var(--border-color); }
        .history-list-container .history-item:last-child { border-bottom: none; }
        .history-item-left strong { font-size: 1em; font-weight: 500; color: var(--text-light); }
        .history-item-left small { font-size: 0.85em; color: var(--text-muted); display: block; margin-top: 4px; }
        .history-item-right { text-align: right; }
        .history-item-right strong { font-size: 1em; font-weight: bold; }
        .history-item-right small { font-size: 0.85em; display: block; margin-top: 4px; text-transform: capitalize; }
        .history-item-right .amount-positive { color: var(--success-color); }
        .history-item-right .amount-negative { color: #dc3545; }
        .history-item-right .status-success { color: var(--success-color); font-weight: 600; }
        .history-item-right .status-pending { color: #ffc107; font-weight: 600; }
        .history-item-right .status-failed, .history-item-right .status-rejected { color: #dc3545; font-weight: 600; }
        
        .ad-package-card { padding: 15px; text-align: center; cursor: pointer; border: 2px solid var(--border-color); transition: all 0.2s ease-in-out; }
        .ad-package-card h4 { font-size: 1.1em; margin-bottom: 5px; }
        .ad-package-card p { margin: 0; font-weight: 600; color: var(--primary-accent-color); }
        .ad-package-card.selected { border-color: var(--primary-accent-color); background-color: #4d1c20; transform: translateY(-3px); box-shadow: 0 4px 12px rgba(229, 9, 20, 0.2); }
        .user-ad-item { padding: 20px; text-align: left; }
        .user-ad-item .progress-text { font-weight: bold; color: var(--primary-accent-color); margin-top: 10px; display: block; }
        .user-ad-item .status-text { font-weight: 600; margin-top: 5px; display: block; }
        .user-ad-item .status-text.completed { color: var(--success-color); }
        .user-ad-item .status-text.active { color: var(--pg-coin-color); }
        #ad-package-grid { grid-template-columns: repeat(3, 1fr); gap: 15px; }
        @media (max-width: 600px) { #ad-package-grid { grid-template-columns: repeat(2, 1fr); } }
        
        #withdraw-package-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 15px; }
        .withdraw-package-card { padding: 20px 15px; text-align: center; cursor: pointer; }
        .withdraw-package-card h4 { font-size: 1.3em; margin: 0; font-weight: 700; color: var(--pg-coin-color); }
        .withdraw-package-card p { margin: 5px 0 0; color: var(--text-muted); font-size: 0.9em; }
        .withdraw-package-card:hover { transform: translateY(-3px); border-color: var(--primary-accent-color); }
        .withdraw-package-card:disabled, .withdraw-package-card.disabled { background-color: var(--disabled-color); cursor: not-allowed; opacity: 0.6; }
        .withdraw-package-card:disabled:hover, .withdraw-package-card.disabled:hover { transform: none; border-color: var(--border-color); }

        .daily-reward-card-info .progress-bar { height: 6px; background-color: #333; border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .daily-reward-card-info .progress-bar-inner { height: 100%; width: 0%; background-color: var(--primary-accent-color); border-radius: 3px; transition: width 0.3s; }
        .daily-reward-card-info .progress-text { font-size: 0.8em; color: var(--text-muted); font-weight: 500; }
        .welcome-modal .modal-body ul { padding-left: 20px; }
        .welcome-modal .modal-body li { margin-bottom: 10px; }
        #welcome-agree-container { margin-top: 20px; display: flex; align-items: center; gap: 10px; }

        #video-claim-box, #task-claim-box, #daily-claim-box {
            position: fixed;
            bottom: 100px;
            right: 15px;
            background-color: rgba(31, 31, 31, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 10px 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            text-align: center;
            z-index: 1001;
            transform: scale(0);
            transition: transform 0.3s ease-in-out;
        }
        #video-claim-box.visible, #task-claim-box.visible, #daily-claim-box.visible { transform: scale(1); }
        #video-claim-box.pulsate { animation: pulsate-animation 1.5s infinite; }
        #task-claim-box.pulsate { animation: pulsate-animation-red 1.5s infinite; }
        #daily-claim-box.pulsate { animation: pulsate-animation-green 1.5s infinite; }

        @keyframes pulsate-animation {
            0% { transform: scale(1); box-shadow: 0 5px 15px rgba(40, 167, 69, 0.2); }
            50% { transform: scale(1.05); box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4); }
            100% { transform: scale(1); box-shadow: 0 5px 15px rgba(40, 167, 69, 0.2); }
        }
        @keyframes pulsate-animation-red {
            0% { transform: scale(1); box-shadow: 0 5px 15px rgba(229, 9, 20, 0.2); }
            50% { transform: scale(1.02); box-shadow: 0 8px 25px rgba(229, 9, 20, 0.4); }
            100% { transform: scale(1); box-shadow: 0 5px 15px rgba(229, 9, 20, 0.2); }
        }
        @keyframes pulsate-animation-green {
            0% { transform: scale(1); box-shadow: 0 5px 15px rgba(40, 167, 69, 0.2); }
            50% { transform: scale(1.02); box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4); }
            100% { transform: scale(1); box-shadow: 0 5px 15px rgba(40, 167, 69, 0.2); }
        }

        #video-claim-box #video-unclaimed-balance-box, 
        #task-claim-box #task-unclaimed-balance-box,
        #daily-claim-box #daily-unclaimed-balance-box { 
            font-size: 1em; font-weight: 700; color: var(--pg-coin-color); display: block; margin-bottom: 8px; 
        }
        #video-claim-button-box, 
        #task-claim-button-box,
        #daily-claim-button-box { 
            width: 100%; padding: 6px 12px; font-size: 0.9em; 
        }

        .coin-vfx {
            position: absolute;
            background-color: var(--pg-coin-color);
            width: 10px;
            height: 10px;
            border-radius: 50%;
            opacity: 0.8;
            animation: fly-to-box 0.7s ease-in-out forwards;
        }
        @keyframes fly-to-box {
            0% { transform: translate(0, 0) scale(1); opacity: 0.8; }
            100% { transform: translate(var(--end-x), var(--end-y)) scale(0); opacity: 0; }
        }

    </style>
</head>
<body>

    <header class="main-header">
        <div class="header-left">
            <div class="site-branding">
                <h1 class="site-title">NEWTUBE</h1>
                <div class="user-id-display" id="header-user-id">
                    <span>ID: Loading...</span>
                    <svg class="copy-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                </div>
            </div>
            <button class="header-icon-btn" id="history-btn" title="History">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M0 0h24v24H0z" fill="none"/>
                    <path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
                </svg>
            </button>
        </div>
        <div class="header-right">
            <div class="balance-display">$: <span id="userUSDTBalanceDisplay">0.0000</span></div>
            <div class="balance-display"><span class="pg-label">PG:</span> <span id="userPgCoinDisplay">0.000</span></div>
             <button class="header-icon-btn bottom-nav-item referral-button-vfx" data-tab-target="#profile-content" title="Profile & Referral">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
            </button>
        </div>
    </header>

    <main class="container">
        <!-- Profile / Referral Section -->
        <section id="profile-content" class="content-section active">
            <div class="card">
                <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                <h3>Referral Program</h3>
                <p style="text-align: left; line-height: 1.8;">
                    Invite friends to get amazing rewards!
                    <br><br>
                    <strong>Your Rewards:</strong><br>
                    &nbsp;&nbsp;&nbsp;- <strong>Lifetime Commission:</strong> Earn 10% from all PG Coin your friends earn, forever!
                </p>
                <div class="referral-link-wrapper"><input type="text" id="referralLinkInput" readonly value="Generating link..."><button id="copyReferralLinkBtn" class="form-button">Copy</button></div>
                
                <div id="referral-stats-grid" style="margin-top: 30px;">
                    <div class="profile-stat-item">
                        <h4>User ID</h4>
                        <p id="referral-userid" style="font-size: 1.1em; color: var(--text-muted); cursor: pointer;">Loading...</p>
                    </div>
                    <div class="profile-stat-item">
                        <h4>Lifetime Referrals</h4>
                        <p id="referral-lifetime-referrals" class="ref-val">0</p>
                    </div>
                    <div class="profile-stat-item">
                        <h4>USDT Balance</h4>
                        <p id="referral-usdt-balance" class="usdt-val">0.0000</p>
                    </div>
                     <div class="profile-stat-item">
                        <h4>Commission Earned (PG)</h4>
                        <p id="referral-commission-pg" class="pg-val">0.000</p>
                    </div>
                </div>
            </div>
            
            <!-- Daily Tasks Section -->
            <div id="daily-tasks-section" style="margin-top: 30px;">
                <h3 class="sub-section-title">Daily Rewards</h3>
                <div id="daily-tasks-grid" class="item-grid">
                    <!-- Daily tasks will be rendered here by JS -->
                </div>
            </div>
        </section>
        
        <section id="ads-content" class="content-section">
             <h3 class="section-title">Watch Ads, Earn Rewards</h3>
             <div id="ad-task-list" class="item-grid"></div>
             <!-- Adextra Banner Ad Block -->
             <div id="fa6b30e404e1046793d70db4a424966f97960abe" style="margin-top: 25px;"></div>
        </section>

        <section id="video-content" class="content-section">
            <div id="adsterra-social-bar-container" style="display:none;"></div>
            <h3 class="section-title">Trending Videos</h3>
            <div class="search-container">
                <input type="search" id="videoSearchInput" placeholder="Search for videos...">
                <button id="videoSearchBtn">Search</button>
                <button id="clearSearchBtn" style="display:none;">Clear</button>
            </div>
            <div class="item-grid" id="video-grid"></div>
        </section>
        
        <section id="task-content" class="content-section">
            <h3 class="section-title">Complete Tasks to Earn</h3>
            
            <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-bottom: 20px;">
                <h3 class="sub-section-title" style="margin: 0; border: none; padding: 0; font-size: 1.1em;">Available Tasks</h3>
                <button id="show-create-task-btn" class="task-button">Add Task +</button>
            </div>
            
            <div id="task-list" class="item-grid"></div>

             <!-- My Ads Section -->
             <div id="my-ads-section-container">
                <h3 class="sub-section-title">My Advertisements</h3>
                <div id="my-ads-list" class="item-grid"></div>
            </div>
        </section>
        
        <section id="withdraw-content" class="content-section">
             <div class="card" style="max-width: none;">
                <p class="info-text" style="text-align: center; margin-bottom: 25px;">
                    For any promotion or payment-related issues, please contact our support: 
                    <a href="https://t.me/newtube12_Admin" target="_blank" style="color: var(--primary-accent-color); font-weight: bold;">@newtube12_Admin</a>
                </p>
                <h3 class="section-title" style="border: none; margin-bottom: 10px; text-align: center;">Withdraw PG Coin</h3>
                <p>Your PG Coin Balance: <strong id="withdrawPgCoinBalance">0.000</strong></p>
                <p class="info-text" style="text-align: center; margin-bottom: 25px;">
                    Select a package to withdraw. Withdrawals are processed within 1-5 hours.
                    <br><strong style="color: var(--pg-coin-color);">Note: You must have at least 2 new referrals since your last withdrawal.</strong>
                </p>
                
                <form id="pgWithdrawalDetailsForm" style="margin-bottom: 30px;">
                     <div class="form-group">
                        <label for="pgWithdrawalMethod">1. Select Payment Method</label>
                        <select id="pgWithdrawalMethod" required>
                            <option value="Bkash">Bkash</option>
                            <option value="Binance">Binance ID</option>
                        </select>
                     </div>
                     <div class="form-group">
                        <label for="pgAccountDetails">2. Enter Account Details</label>
                        <input type="text" id="pgAccountDetails" placeholder="Your Bkash Number or Binance ID" required>
                     </div>
                </form>

                <h4 style="text-align: left; margin-bottom: 15px; font-size: 1.1em; color: var(--text-muted);">3. Choose an amount to withdraw</h4>
                <div id="withdraw-package-grid" class="item-grid">
                    <!-- JS will generate boxes here -->
                </div>
                <p class="info-text" style="text-align: center; margin-top: 20px; font-weight: bold;">1 PG coin = 2 Taka (BDT)</p>
             </div>
        </section>

        <section id="about-content" class="content-section">
            <div class="card" style="max-width: none; text-align: left;">
                <h3 style="text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 10px;">About NEWTUBE</h3>
        
                <div class="sub-card" style="margin-top: 20px;">
                    <h4>1. How to Complete Tasks</h4>
                    <p class="info-text">Navigate to the "Tasks" tab. You will see a list of available tasks. Click the "Go" button, which will take you to a social media page (like Telegram, YouTube, etc.). Complete the required action (e.g., join channel, subscribe). Return to our app, wait for the timer, and then click "Claim Reward". Your reward will be added to the Task Loot Box.</p>
                </div>
        
                <div class="sub-card">
                    <h4>2. How to Earn from Videos</h4>
                    <p class="info-text">Go to the "Video" tab. Simply click on any video to start watching. You will earn PG Coins for every second you watch. The coins you earn are automatically collected in your Video Loot Box at the bottom right of the screen.</p>
                </div>
                
                <div class="sub-card">
                    <h4>3. Daily & Referral Rewards</h4>
                    <p class="info-text">On the "Profile" tab, you'll find daily tasks like visiting channels or referring new friends. Invite friends with your unique referral link to earn significant daily bonuses. Plus, you will earn a <strong>10% lifetime commission</strong> on all PG Coins your friends earn!</p>
                </div>
        
                <div class="sub-card">
                    <h4>4. How to Withdraw</h4>
                    <p class="info-text">Visit the "Withdraw" tab. First, select your payment method (Bkash or Binance) and enter your account number or ID. Then, choose a withdrawal package. <strong>Important:</strong> To make a withdrawal, you must have at least <strong>2 new referrals</strong> since your last withdrawal. Requests are processed within 1-5 hours.</p>
                </div>
        
                <div class="sub-card">
                    <h4>5. The Loot Box System Explained</h4>
                    <p class="info-text">To make earning fun and prevent spam, rewards from Videos, Tasks, and Daily Activities are first collected in "Loot Boxes". These are small pop-ups at the bottom-right corner. Once a loot box collects a certain amount of PG Coins (e.g., 1.0 PG for videos), the "Claim" button becomes active. Click it to transfer the coins to your main balance. This keeps the system fair and engaging.</p>
                </div>
                
                <div class="sub-card">
                    <h4>6. Our Policy & Promise</h4>
                    <p class="info-text" style="line-height: 1.8;">
                        This platform was launched in December 2024. Our goal is to provide a place where you can earn a modest, halal income through honest work. There is no place for cheating or fraud here.
                        <br><br>
                        - Using a VPN or bots is strictly forbidden and will lead to a permanent ban.
                        <br>
                        - Submitting fake or incomplete tasks will result in account suspension.
                        <br><br>
                        This app won't make you rich, but it offers a chance to earn real money through simple, organic tasks. Please work honestly and enjoy your earnings.
                    </p>
                </div>
        
            </div>
        </section>
        
    </main>

    <nav class="bottom-nav">
        <a href="#" class="bottom-nav-item active" data-tab-target="#profile-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
            Profile
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#ads-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM8 11H6V9h2v2zm4 0h-2V9h2v2zm4 0h-2V9h2v2z"/></svg>
            Ads
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#video-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M10 16.5v-9l6 4.5-6 4.5zM20 4.44v15.12c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V4.44c0-1.1.9-2 2-2h12c1.1 0 2 .9 2 2z"/></svg>
            Video
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#task-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M22 7h-9v-2h9v2zm0 4h-9v-2h9v2zm0 4h-9v-2h9v2zm-11-8H4v6h7V7zM3 5h9v14H3V5z"/></svg>
            Tasks
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#withdraw-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M21 8H3V6h18v2zm0 6H3v-2h18v2zM5 18h14v-2H5v2zM3 20h18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2H3c-1.1 0-2 .9 2 2v12c0 1.1.9 2 2z"/></svg>
            Withdraw
        </a>
        <a href="#" class="bottom-nav-item" data-tab-target="#about-content">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
            About
        </a>
    </nav>
    
    <!-- Video Claim Box -->
    <div id="video-claim-box">
        <span id="video-unclaimed-balance-box">0.000 / 1.000 PG</span>
        <button id="video-claim-button-box" class="form-button" disabled>Claim</button>
    </div>
    <!-- Task Claim Box -->
    <div id="task-claim-box">
        <span id="task-unclaimed-balance-box">0.000 / 5.000 PG</span>
        <button id="task-claim-button-box" class="form-button" disabled>Claim</button>
    </div>
    <!-- Daily Rewards Claim Box -->
    <div id="daily-claim-box">
        <span id="daily-unclaimed-balance-box">0.000 / 3.000 PG</span>
        <button id="daily-claim-button-box" class="form-button" disabled>Claim</button>
    </div>


    <div id="successModalOverlay" class="modal-overlay"><div class="modal-content"><div class="success-modal-icon">✓</div><h3 id="successModalTitle">Success!</h3><p id="successModalMessage">Your request has been sent.</p></div></div>
    
    <div id="historyModalOverlay" class="modal-overlay">
        <div class="history-modal"><h3>History</h3><div id="combined-history-list" class="history-list-container"></div><button id="closeHistoryBtn" class="form-button" style="margin-top: 15px;">Close</button></div>
    </div>
    
    <div id="createTaskModalOverlay" class="modal-overlay">
        <div class="task-modal">
            <h3>Create New Task Advertisement</h3>
            <div class="modal-body">
                <p class="info-text" style="text-align: center; margin-bottom: 20px;">
                    Easily promote your social media at a low cost! Get real users for your Facebook, YouTube, TikTok, Telegram channels or bots.<br><br>
                    Purchase tasks using your USDT balance. Your task will be shown to thousands of our active users.<br>
                    <strong>For manual deposits or promotions, contact admin: <a href="https://t.me/NEWTUBE12_admin" target="_blank" style="color: var(--primary-accent-color);">@NEWTUBE12_admin</a></strong>
                </p>
                <form id="create-task-form">
                    <div class="form-group">
                        <label>1. Select a Package</label>
                        <div id="ad-package-grid" class="item-grid"></div>
                    </div>
                    <div class="form-group">
                        <label for="task-title-input">2. Task Title</label>
                        <input type="text" id="task-title-input" placeholder="e.g., Join My Telegram Channel" required>
                    </div>
                    <div class="form-group">
                        <label for="task-url-input">3. Task URL</label>
                        <input type="url" id="task-url-input" placeholder="https://t.me/your_channel" required>
                    </div>
                    <button type="submit" class="form-button">Create Task</button>
                </form>
            </div>
            <button id="closeTaskModalBtn" class="form-button" style="margin-top: 15px; background-color: var(--text-muted);">Close</button>
        </div>
    </div>

    <!-- 24-Hour Notice Modal -->
    <div id="noticeModalOverlay" class="modal-overlay">
        <div class="notice-modal">
            <h3>Welcome to NEWTUBE! 🤗</h3>
            <div class="modal-body">
                <p>Here’s what you can do on our platform:</p>
                <ul>
                    <li>Run your own advertisements starting from just 60 Taka.</li>
                    <li>Earn PG Coins by watching videos and withdraw your earnings instantly.</li>
                    <li>Receive a 10% lifetime commission for every friend you refer.</li>
                    <li>Withdrawals are processed within 1-5 hours.</li>
                    <li>Using a VPN is strictly prohibited. You will not receive any payment if you do.</li>
                    <li>Submitting fake or incomplete tasks will lead to account suspension.</li>
                    <li>Please work honestly, share with friends to earn more, and enjoy your halal income.</li>
                </ul>
            </div>
            <button id="noticeConfirmBtn" class="form-button">I Understand</button>
        </div>
    </div>


    <div id="taskConfirmModalOverlay" class="modal-overlay">
        <div class="task-confirm-modal">
            <h3>Confirm Task Completion</h3>
            <div class="modal-body">
                <p>Have you completed the task correctly? If not, please go back and complete it now.</p>
                <p class="info-text">Note: Your submission may be reviewed by an administrator. Failure to complete tasks honestly can result in account suspension.</p>
                <div class="task-confirm-modal-buttons">
                    <button id="taskConfirmGoBackBtn" class="form-button" style="background-color: var(--text-muted);">Go Back to Task</button>
                    <button id="taskConfirmSubmitBtn" class="form-button">Yes, I Completed It</button>
                </div>
            </div>
        </div>
    </div>

    <div id="withdrawConfirmModalOverlay" class="modal-overlay">
        <div class="task-confirm-modal">
            <h3>Confirm Withdrawal</h3>
            <div class="modal-body">
                <p id="withdrawConfirmText">Are you sure you want to withdraw X PG?</p>
                <p class="info-text">The amount will be sent to the account details you provided. This action cannot be undone.</p>
                <div class="task-confirm-modal-buttons">
                    <button id="withdrawConfirmCancelBtn" class="form-button" style="background-color: var(--text-muted);">Cancel</button>
                    <button id="withdrawConfirmSubmitBtn" class="form-button">Confirm & Withdraw</button>
                </div>
            </div>
        </div>
    </div>


    <script src="https://www.youtube.com/iframe_api" async></script>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, orderBy, limit, addDoc, serverTimestamp, doc, getDoc, setDoc, updateDoc, runTransaction, increment, arrayUnion, Timestamp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCKMa4NdIowD_8NioUbrn4L7g5M9y5Tts0",
            authDomain: "movie-zone-931d7.firebaseapp.com",
            databaseURL: "https://movie-zone-931d7-default-rtdb.firebaseio.com",
            projectId: "movie-zone-931d7",
            storageBucket: "movie-zone-931d7.appspot.com",
            messagingSenderId: "1006880112063",
            appId: "1:1006880112063:web:4a4cf5079ea365a6ce750a",
            measurementId: "G-TH1YSE4D9C"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const tg = window.Telegram.WebApp;

        let currentUser = null;
        let player;
        let currentPlayingItem = null;
        let videoWatchTimer = null;
        let videoSyncTimer = null;
        let isSubmittingWithdrawal = false; 
        let selectedAdPackage = null;
        let dailyBrowseTimer = null;

        const VIDEO_CLAIM_THRESHOLD = 1.0;
        const TASK_CLAIM_THRESHOLD = 5.0;
        const DAILY_CLAIM_THRESHOLD = 3.0;

        const AD_TASK_VIEWS_REQUIRED = 5;
        const AD_TASK_REWARD = 0.2;
        const DAILY_LOGIN_PG_REWARD = 0.02;
        const USER_CREATED_TASK_REWARD_PG = 0.07;
        const VIDEO_REWARD_PER_SECOND_PG = 1 / 86400;
        const MAX_DAILY_VIDEO_REWARD_SECONDS = 86400;
        const REFERRAL_COMMISSION_RATE = 0.06;

        const adPackages = [
            { id: 1, tasks: 100, price: 0.30 }, { id: 2, tasks: 200, price: 0.50 },
            { id: 3, tasks: 500, price: 1.10 }, { id: 4, tasks: 1000, price: 2.00 },
            { id: 5, tasks: 2000, price: 3.50 }, { id: 6, tasks: 5000, price: 7.00 }
        ];
        
        const pgWithdrawalPackages = [10, 20, 50, 100, 200, 500];

        function showBanScreen() { document.body.innerHTML = `<div style="display: flex; justify-content: center; align-items: center; height: 100vh; padding: 20px; text-align: center;"><div class="card"><h3>Account Banned</h3><p style="color: #ffc107;">Your account has been banned due to a violation of our terms of service.</p></div></div>`; }
        
        async function cleanupAndGetUser(userId) {
            const userRef = doc(db, 'users', userId);
            const userSnap = await getDoc(userRef);
            if (!userSnap.exists()) return null;
            return { id: userSnap.id, ...userSnap.data() };
        }

        async function fetchAndUpdateCurrentUser() {
            if (!currentUser?.id) return;
            try {
                const updatedUser = await cleanupAndGetUser(currentUser.id);
                if (updatedUser) {
                    currentUser = updatedUser;
                    updateBalanceUI(currentUser.usdtBalance, currentUser.pgCoin);
                }
            } catch (error) { console.error("Error fetching/cleaning current user:", error); }
        }
        
        async function checkAndResetDailies() {
            if (!currentUser) return;
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
            const lastDailyReset = currentUser.lastDailyReset?.toDate();
            const lastDailyResetTime = lastDailyReset ? new Date(lastDailyReset.getFullYear(), lastDailyReset.getMonth(), lastDailyReset.getDate()).getTime() : 0;
            
            if (!lastDailyReset || lastDailyResetTime < today) {
                const updates = { 
                    'lastDailyReset': serverTimestamp(), 
                    'dailyReferralCount': 0,
                    'dailyTasksCompletedCount': 0,
                    'dailyRewardsClaimed': [],
                    'claimedDailyRewards': [],
                    'dailyTelegramVisit1Completed': false,
                    'dailyTelegramVisit2Completed': false,
                    'dailyBrowseVisit1Completed': false,
                    'dailyBrowseVisit2Completed': false,
                    'dailyAdViews_1': 0, 
                    'dailyAdViews_2': 0,
                    'dailyAdViews_3': 0,
                    'totalVideoWatchSecondsToday': 0 
                };
                try {
                    const userRef = doc(db, 'users', currentUser.id);
                    await updateDoc(userRef, updates);
                    await fetchAndUpdateCurrentUser(); 
                } catch (error) { console.error("Error resetting daily limits:", error); }
            }
        }

        async function grantCommission(rewardPg) {
            if (!currentUser.referredBy || !rewardPg || rewardPg <= 0) return;
            const referrerId = currentUser.referredBy;
            const commissionAmount = rewardPg * REFERRAL_COMMISSION_RATE;

            if (commissionAmount > 0) {
                try {
                    const referrerRef = doc(db, 'users', referrerId);
                    await runTransaction(db, async (t) => {
                         t.update(referrerRef, {
                            pgCoin: increment(commissionAmount),
                            lifetimeCommissionPg: increment(commissionAmount)
                        });
                        const transactionData = {
                            userId: referrerId,
                            type: 'Commission',
                            details: `Commission from user ${currentUser.id}`,
                            pgAmount: commissionAmount,
                            status: 'Completed',
                            createdAt: serverTimestamp()
                        };
                        t.set(doc(collection(db, 'transactions')), transactionData);
                    });
                } catch (error) { console.error(`Failed to grant commission to ${referrerId}:`, error); }
            }
        }

        async function initializeUser(tgUser, referrerCode) {
            const userId = String(tgUser.id);
            const userRef = doc(db, 'users', userId);
            let userSnap = await getDoc(userRef);
            let isNewUser = false;

            if (!userSnap.exists()) {
                isNewUser = true;
                const defaultUserData = {
                    usdtBalance: 0, pgCoin: 0, lifetimePgCoinEarned: 0, referralCount: 0,
                    lifetimeCommissionPg: 0,
                    completedTasks: [], 
                    lastDailyReset: serverTimestamp(), lastDailyLoginClaim: null,
                    lastNoticeShown: null,
                    withdrawalCount: 0, 
                    createdAt: serverTimestamp(), telegramUsername: tgUser.username || 'N/A',
                    isBanned: false,
                    isActivated: false,
                    dailyReferralCount: 0, dailyTasksCompletedCount: 0, 
                    dailyRewardsClaimed: [], 
                    claimedDailyRewards: [],
                    dailyTelegramVisit1Completed: false, dailyTelegramVisit2Completed: false,
                    dailyBrowseVisit1Completed: false, dailyBrowseVisit2Completed: false,
                    dailyAdViews_1: 0, dailyAdViews_2: 0, dailyAdViews_3: 0,
                    totalVideoWatchSecondsToday: 0,
                    unclaimedVideoPg: 0, unclaimedVideoPgLastUpdated: null,
                    unclaimedTaskPg: 0,
                    unclaimedDailyPg: 0,
                    referralsSinceLastWithdrawal: 0,
                };
                if (referrerCode && referrerCode !== userId) { 
                    defaultUserData.referredBy = referrerCode; 
                    try {
                        const referrerRef = doc(db, 'users', referrerCode);
                        await updateDoc(referrerRef, {
                            referralCount: increment(1),
                            dailyReferralCount: increment(1),
                            referralsSinceLastWithdrawal: increment(1)
                        });
                    } catch (e) {
                        console.error("Failed to update referrer stats on new user creation", e);
                    }
                }
                await setDoc(userRef, defaultUserData);
                userSnap = await getDoc(userRef);
            }
            
            const userData = userSnap.data();
            if (userData?.isBanned === true) { showBanScreen(); return null; }
            
            const updates = {};
            if (userData.isActivated === undefined) updates.isActivated = true;
            if (userData.dailyReferralCount === undefined) updates.dailyReferralCount = 0;
            if (userData.dailyTasksCompletedCount === undefined) updates.dailyTasksCompletedCount = 0;
            if (userData.dailyRewardsClaimed === undefined) updates.dailyRewardsClaimed = [];
            if (userData.claimedDailyRewards === undefined) updates.claimedDailyRewards = [];
            if (userData.dailyTelegramVisit1Completed === undefined) {
                 updates.dailyTelegramVisit1Completed = false;
                 updates.dailyTelegramVisit2Completed = false;
            }
            if (userData.dailyBrowseVisit1Completed === undefined) {
                 updates.dailyBrowseVisit1Completed = false;
                 updates.dailyBrowseVisit2Completed = false;
            }
            if (userData.dailyAdViews_1 === undefined) {
                updates.dailyAdViews_1 = 0;
                updates.dailyAdViews_2 = 0;
                updates.dailyAdViews_3 = 0;
            }
            if (userData.totalVideoWatchSecondsToday === undefined) updates.totalVideoWatchSecondsToday = 0;
            if (userData.lastNoticeShown === undefined) updates.lastNoticeShown = null;
            if (userData.unclaimedVideoPg === undefined) {
                updates.unclaimedVideoPg = 0;
                updates.unclaimedVideoPgLastUpdated = null;
            }
            if (userData.unclaimedTaskPg === undefined) updates.unclaimedTaskPg = 0;
            if (userData.unclaimedDailyPg === undefined) updates.unclaimedDailyPg = 0;
            if (userData.referralsSinceLastWithdrawal === undefined) updates.referralsSinceLastWithdrawal = 0;


            if (Object.keys(updates).length > 0) { await updateDoc(userRef, updates); }
            
            currentUser = { id: userSnap.id };
            await fetchAndUpdateCurrentUser(); 
            
            await checkAndResetDailies();
            generateReferralLink(currentUser.id);
            
            return { isNewUser, isActivated: currentUser.isActivated };
        }

        function updateBalanceUI(usdtBalance, pgCoinBalance) {
            document.getElementById('userUSDTBalanceDisplay').textContent = parseFloat(usdtBalance || 0).toFixed(4);
            document.getElementById('userPgCoinDisplay').textContent = parseFloat(pgCoinBalance || 0).toFixed(3);
        }
        
        function generateReferralLink(userId) {
            const botUsername = "NewTube12_bot";
            const webAppShortName = "newtubecash";
            const referralLink = `https://t.me/${botUsername}/${webAppShortName}?startapp=${userId}`;
            document.getElementById('referralLinkInput').value = referralLink;
        }
        
        document.getElementById('copyReferralLinkBtn').addEventListener('click', () => {
            const copyButton = document.getElementById('copyReferralLinkBtn');
            navigator.clipboard.writeText(copyButton.previousElementSibling.value).then(() => {
                copyButton.textContent = 'Copied!';
                if (tg && tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
            });
        });
        
        async function grantReward(rewards, transactionInfo = {}) {
             if (!currentUser) return;
             const userRef = doc(db, 'users', currentUser.id);
             const updates = {};
             
             if (rewards.pgCoin && rewards.pgCoin > 0) {
                 updates.pgCoin = increment(rewards.pgCoin);
                 updates.lifetimePgCoinEarned = increment(rewards.pgCoin);
                 await grantCommission(rewards.pgCoin);
             }
             if (rewards.usdt && rewards.usdt > 0) { updates.usdtBalance = increment(rewards.usdt); }
             if (Object.keys(updates).length > 0) { await updateDoc(userRef, updates); }
             
             if (transactionInfo.type) {
                 const transactionData = {
                    userId: currentUser.id, type: transactionInfo.type, details: transactionInfo.details || '',
                    status: 'Completed', createdAt: serverTimestamp()
                };
                if (rewards.pgCoin) transactionData.pgAmount = rewards.pgCoin;
                if (rewards.usdt) transactionData.usdAmount = rewards.usdt;
                await addDoc(collection(db, 'transactions'), transactionData);
             }
        }
        
        async function fetchContent() {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = '<div class="loader"></div>';
            try {
                const q = query(collection(db, 'videos'), orderBy('createdAt', 'desc'), limit(30));
                const snapshot = await getDocs(q);
                renderVideos(snapshot);
            } catch (error) { 
                console.error("Error fetching content:", error); 
                grid.innerHTML = '<p style="grid-column: 1 / -1;">Error loading content.</p>'; 
            }
        }
        
        function renderVideos(snapshot) {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = ''; 
            if (snapshot.empty) { grid.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No videos found.</p>'; return; }
            snapshot.docs.forEach((docSnap) => {
                const video = docSnap.data();
                const item = document.createElement('article');
                item.className = 'movie-item';
                item.dataset.youtubeId = video.youtubeId;
                item.dataset.videoId = docSnap.id;
                item.originalContent = `<div class="thumbnail-container"><img src="${video.thumbnailUrl}" alt="${video.title}" loading="lazy"></div><div class="movie-item-info"><h4>${video.title}</h4><p class="movie-reward">Watch to Earn PG Coin</p></div>`;
                item.innerHTML = item.originalContent;
                item.addEventListener('click', handleVideoClick);
                grid.appendChild(item);
            });
        }
        
        function handleVideoClick(event) {
            if (currentPlayingItem) {
                if(currentPlayingItem.originalContent) currentPlayingItem.innerHTML = currentPlayingItem.originalContent;
                if (player) { player.destroy(); player = null; }
            }
            const clickedItem = event.currentTarget;
            if (currentPlayingItem === clickedItem) { currentPlayingItem = null; return; }
            currentPlayingItem = clickedItem;
            const { youtubeId } = clickedItem.dataset;
            const playerDivId = `player-${youtubeId}-${Date.now()}`;
            clickedItem.innerHTML = `<div id="${playerDivId}" class="player-container"></div>`;
            player = new YT.Player(playerDivId, {
                height: '100%', width: '100%', videoId: youtubeId,
                playerVars: { 'autoplay': 1, 'controls': 1, 'rel': 0, 'fs': 1 },
                events: { 'onStateChange': onPlayerStateChange }
            });
        }
        
        function updateVideoClaimUI() {
            const claimBox = document.getElementById('video-claim-box');
            const unclaimedBalanceEl = document.getElementById('video-unclaimed-balance-box');
            const claimButton = document.getElementById('video-claim-button-box');

            const unclaimedBalance = currentUser?.unclaimedVideoPg || 0;

            unclaimedBalanceEl.textContent = `${unclaimedBalance.toFixed(4)} / ${VIDEO_CLAIM_THRESHOLD.toFixed(3)} PG`;

            if (unclaimedBalance > 0 && !claimBox.classList.contains('visible')) {
                claimBox.classList.add('visible');
            } else if (unclaimedBalance <= 0) {
                 claimBox.classList.remove('visible');
            }

            if (unclaimedBalance >= VIDEO_CLAIM_THRESHOLD) {
                claimButton.disabled = false;
                if (!claimBox.classList.contains('pulsate')) {
                    claimBox.classList.add('pulsate');
                }
            } else {
                claimButton.disabled = true;
                claimBox.classList.remove('pulsate');
            }
        }
        
        async function syncUnclaimedVideoPg() {
            if (!currentUser) return;
            try {
                const userRef = doc(db, 'users', currentUser.id);
                await updateDoc(userRef, {
                    unclaimedVideoPg: currentUser.unclaimedVideoPg,
                    unclaimedVideoPgLastUpdated: serverTimestamp()
                });
            } catch (error) {
                console.error("Failed to sync unclaimed video PG:", error);
            }
        }

        async function claimVideoRewards() {
            const claimButton = document.getElementById('video-claim-button-box');
            if (currentUser.unclaimedVideoPg < VIDEO_CLAIM_THRESHOLD) return;

            claimButton.disabled = true;
            claimButton.textContent = 'Claiming...';
            
            const amountToClaim = Math.floor(currentUser.unclaimedVideoPg / VIDEO_CLAIM_THRESHOLD) * VIDEO_CLAIM_THRESHOLD;
            if (amountToClaim <= 0) {
                claimButton.textContent = 'Claim';
                updateVideoClaimUI();
                return;
            }

            try {
                await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await t.get(userRef);
                    if (!userDoc.exists()) throw new Error("User not found");

                    const currentUnclaimed = userDoc.data().unclaimedVideoPg || 0;
                    if (currentUnclaimed < amountToClaim) throw new Error("Inconsistent balance");
                    
                    t.update(userRef, {
                        pgCoin: increment(amountToClaim),
                        lifetimePgCoinEarned: increment(amountToClaim),
                        unclaimedVideoPg: increment(-amountToClaim)
                    });
                });
                
                await grantCommission(amountToClaim);

                await addDoc(collection(db, 'transactions'), {
                    userId: currentUser.id, type: 'Video Reward',
                    details: 'Claimed from Video Loot Box',
                    pgAmount: amountToClaim, status: 'Completed', createdAt: serverTimestamp()
                });

                showSuccessModal("Reward Claimed!", `You claimed ${amountToClaim.toFixed(3)} PG from watching videos.`);
                await fetchAndUpdateCurrentUser();
                updateVideoClaimUI();

            } catch(error) {
                console.error("Error claiming video rewards:", error);
                alert("Failed to claim rewards. Please try again.");
            } finally {
                claimButton.textContent = 'Claim';
                updateVideoClaimUI();
            }
        }
        document.getElementById('video-claim-button-box').addEventListener('click', claimVideoRewards);

        function triggerCoinVFX(playerElement) {
            const claimBox = document.getElementById('video-claim-box');
            if (!claimBox || !playerElement) return;

            const playerRect = playerElement.getBoundingClientRect();
            const boxRect = claimBox.getBoundingClientRect();

            const coin = document.createElement('div');
            coin.className = 'coin-vfx';
            document.body.appendChild(coin);
            
            const startX = playerRect.left + playerRect.width / 2;
            const startY = playerRect.top + playerRect.height / 2;
            
            const endX = boxRect.left + boxRect.width / 2;
            const endY = boxRect.top + boxRect.height / 2;

            coin.style.left = `${startX}px`;
            coin.style.top = `${startY}px`;
            coin.style.setProperty('--end-x', `${endX - startX}px`);
            coin.style.setProperty('--end-y', `${endY - startY}px`);

            setTimeout(() => coin.remove(), 700);
        }

        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.PLAYING) {
                if (videoWatchTimer) clearInterval(videoWatchTimer);
                if (videoSyncTimer) clearInterval(videoSyncTimer);

                videoWatchTimer = setInterval(async () => {
                    if (!currentUser) return;
                    
                    let watchTimeToday = currentUser.totalVideoWatchSecondsToday || 0;
                    if (watchTimeToday >= MAX_DAILY_VIDEO_REWARD_SECONDS) {
                        clearInterval(videoWatchTimer);
                        return;
                    }
                    
                    currentUser.totalVideoWatchSecondsToday++;
                    currentUser.unclaimedVideoPg = (currentUser.unclaimedVideoPg || 0) + VIDEO_REWARD_PER_SECOND_PG;
                    
                    if (currentUser.totalVideoWatchSecondsToday % 5 === 0) {
                        triggerCoinVFX(event.target.getIframe());
                    }

                    updateVideoClaimUI();
                }, 1000);
                
                videoSyncTimer = setInterval(async () => {
                    await syncUnclaimedVideoPg();
                    await updateDoc(doc(db, 'users', currentUser.id), { totalVideoWatchSecondsToday: currentUser.totalVideoWatchSecondsToday });
                }, 15000);

            } else {
                if (videoWatchTimer) clearInterval(videoWatchTimer);
                if (videoSyncTimer) {
                    clearInterval(videoSyncTimer);
                    syncUnclaimedVideoPg();
                }
            }
        }
        
        function hideAllFloatingElements() {
            document.getElementById('video-claim-box').classList.remove('visible', 'pulsate');
            document.getElementById('task-claim-box').classList.remove('visible', 'pulsate');
            document.getElementById('daily-claim-box').classList.remove('visible', 'pulsate');
            document.getElementById('adsterra-social-bar-container').style.display = 'none';
        }

        function stopAllSectionActivity() {
            if(videoWatchTimer) clearInterval(videoWatchTimer);
            if(videoSyncTimer) {
                clearInterval(videoSyncTimer);
                syncUnclaimedVideoPg();
            }
            videoWatchTimer = null;
            videoSyncTimer = null;
            if (currentPlayingItem?.originalContent) {
                try { currentPlayingItem.innerHTML = currentPlayingItem.originalContent; } catch(e) {}
            }
            if (player) { try { player.destroy(); } catch (e) {} player = null; }
            currentPlayingItem = null;
            hideAllFloatingElements();
        }
        
        function setupAdsToEarn() {
            const container = document.getElementById('ad-task-list');
            container.innerHTML = '';
            if (!currentUser) return;

            const adTasks = [
                { id: '1', title: 'Watch Ads & Earn PG', viewsToday: currentUser.dailyAdViews_1 || 0 },
                { id: '2', title: 'Watch Ads & Earn PG', viewsToday: currentUser.dailyAdViews_2 || 0 },
                { id: '3', title: 'Watch Ads & Earn PG', viewsToday: currentUser.dailyAdViews_3 || 0 },
            ];

            adTasks.forEach(task => {
                const viewsLeft = AD_TASK_VIEWS_REQUIRED - task.viewsToday;
                const isCompleted = viewsLeft <= 0;
                let buttonText = isCompleted ? 'Claimed Today' : `Watch Ad (${viewsLeft} left)`;
                let buttonAction = 'watch';

                if (isCompleted && !currentUser.dailyRewardsClaimed?.includes(`ad_task_${task.id}`)) {
                    buttonText = 'Claim Reward';
                    buttonAction = 'claim';
                }

                const card = document.createElement('div');
                card.className = 'ad-task-card';
                card.innerHTML = `
                    <div class="ad-task-card-info">
                        <h4>${task.title} #${task.id}</h4>
                        <p>Reward: <span class="task-reward-pg">${AD_TASK_REWARD} PG</span> (after 5 ads)</p>
                        <p>Progress: ${task.viewsToday} / ${AD_TASK_VIEWS_REQUIRED} ads watched</p>
                    </div>
                    <button class="ad-task-button" data-task-id="${task.id}" data-action="${buttonAction}" ${isCompleted && buttonAction !== 'claim' ? 'disabled' : ''}>
                        ${buttonText}
                    </button>`;
                container.appendChild(card);
            });
        }
        
        document.getElementById('ad-task-list').addEventListener('click', async (e) => {
            const button = e.target.closest('.ad-task-button');
            if (!button || button.disabled) return;
            
            const taskId = button.dataset.taskId;
            const action = button.dataset.action;

            if (action === 'claim') {
                button.disabled = true; button.textContent = 'Claiming...';
                try {
                    await grantReward({ pgCoin: AD_TASK_REWARD }, { type: 'Ad Task Reward', details: `Claimed for ad task set ${taskId}` });
                    await updateDoc(doc(db, 'users', currentUser.id), { dailyRewardsClaimed: arrayUnion(`ad_task_${taskId}`) });
                    showSuccessModal('Reward Claimed!', `${AD_TASK_REWARD} PG has been added to your balance.`);
                    await fetchAndUpdateCurrentUser();
                    setupAdsToEarn();
                } catch(err) {
                    alert('Failed to claim reward.');
                    button.disabled = false;
                }
                return;
            }

            button.disabled = true;
            button.textContent = 'Loading Ad...';
            
            let adTimer = null;
            let adSuccess = false;
            let countdown = 10;

            const handleVisibilityChange = () => {
                if (document.hidden) {
                    if (adTimer) clearInterval(adTimer);
                } else {
                    if (countdown > 0) startTimer();
                }
            };
            
            const startTimer = () => {
                if (adTimer) clearInterval(adTimer);
                adTimer = setInterval(async () => {
                    countdown--;
                    button.textContent = `Wait ${countdown}s`;
                    if (countdown <= 0) {
                        adSuccess = true;
                        clearInterval(adTimer);
                        document.removeEventListener("visibilitychange", handleVisibilityChange);
                        button.textContent = 'Processing...';
                        
                        try {
                            const updateField = `dailyAdViews_${taskId}`;
                            await updateDoc(doc(db, 'users', currentUser.id), { [updateField]: increment(1) });
                            await fetchAndUpdateCurrentUser();
                            setupAdsToEarn(); 
                        } catch (error) {
                            console.error("Error updating ad views:", error);
                            alert("Failed to update progress. Please try again.");
                            setupAdsToEarn();
                        }
                    }
                }, 1000);
            };

            try {
                window.onAdClosed = () => {
                    clearInterval(adTimer);
                    document.removeEventListener("visibilitychange", handleVisibilityChange);
                    if (!adSuccess) {
                        alert('Ad closed too early. No reward given.');
                        setupAdsToEarn(); 
                    }
                };

                await showRandomAdForTask(); 
                button.textContent = `Wait ${countdown}s`;
                startTimer();
                document.addEventListener("visibilitychange", handleVisibilityChange);

            } catch (err) {
                console.error("Ad failed to load:", err);
                clearInterval(adTimer);
                document.removeEventListener("visibilitychange", handleVisibilityChange);
                alert('Ad failed to load or was closed. Please try again.');
                setupAdsToEarn();
            }
        });

        async function fetchAndRenderTasks(containerId, count) {
            const taskListContainer = document.getElementById(containerId);
            taskListContainer.innerHTML = '<div class="loader"></div>';
            if (!currentUser) return;
            try {
                const q = query(collection(db, 'tasks'), where("isApproved", "==", true), orderBy("createdAt", "desc"), limit(count));
                const snapshot = await getDocs(q);
                taskListContainer.innerHTML = '';
                
                let tasksRendered = 0;
                snapshot.forEach(docSnap => {
                    const task = docSnap.data();
                    if (task.creatorId === currentUser.id || currentUser.completedTasks?.includes(docSnap.id)) return;
                    const isLimitReached = (task.limit || 0) > 0 && (task.completionCount || 0) >= task.limit;
                    if (isLimitReached) return; 

                    const card = document.createElement('div');
                    card.className = 'task-card';
                    card.innerHTML = `<div class="task-card-info"><h4>${task.title}</h4><p>Reward: <span class="task-reward-pg">${task.rewardPg || 0} PG</span></p></div><button class="task-button" data-task-id="${docSnap.id}" data-task-url="${task.url}" data-task-creator="${task.creatorId || 'admin'}" data-state="start">Go</button>`;
                    taskListContainer.appendChild(card);
                    tasksRendered++;
                });

                if (tasksRendered === 0) {
                    taskListContainer.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">No new tasks available for you right now.</p>';
                }

            } catch (error) {
                console.error("Error fetching tasks:", error);
                taskListContainer.innerHTML = '<p style="color:red; text-align:center; grid-column: 1 / -1;">Could not load tasks.</p>';
            }
        }
        
        async function handleTaskButtonClick(e) {
            const button = e.target.closest('.task-button');
            if (!button || button.disabled) return;
            
            const { taskId, taskUrl, state } = button.dataset;

            if (state === 'start') {
                tg.openLink(taskUrl);
                button.disabled = true;
                let countdown = 6;
                button.textContent = `Claim in ${countdown}s`;
                const timer = setInterval(() => {
                    countdown--;
                    button.textContent = `Claim in ${countdown}s`;
                    if (countdown <= 0) {
                        clearInterval(timer);
                        button.disabled = false;
                        button.textContent = 'Claim Reward';
                        button.dataset.state = 'claim';
                    }
                }, 1000);
            } else if (state === 'claim') {
                showTaskConfirmationModal(taskId, taskUrl, button);
            }
        }
        document.getElementById('task-list').addEventListener('click', handleTaskButtonClick);

        function showTaskConfirmationModal(taskId, taskUrl, buttonElement) {
            const modal = document.getElementById('taskConfirmModalOverlay');
            const goBackButton = document.getElementById('taskConfirmGoBackBtn');
            const submitButton = document.getElementById('taskConfirmSubmitBtn');
            
            goBackButton.onclick = () => { tg.openLink(taskUrl); modal.classList.remove('show'); };
            
            submitButton.onclick = async () => {
                modal.classList.remove('show');
                await processTaskClaim(taskId, buttonElement);
            };

            modal.classList.add('show');
        }

        async function processTaskClaim(taskId, button) {
            const taskCard = button.closest('.task-card');
            button.disabled = true;
            
            let countdown = 10;
            button.textContent = `Verifying... ${countdown}s`;
            const timer = setInterval(() => {
                countdown--;
                if(countdown > 0) {
                    button.textContent = `Verifying... ${countdown}s`;
                }
            }, 1000);

            await new Promise(resolve => setTimeout(resolve, 10000));
            clearInterval(timer);
            button.textContent = 'Processing...';

            try {
                const taskDocSnap = await getDoc(doc(db, 'tasks', taskId));
                if (!taskDocSnap.exists()) throw new Error("Task not found.");
                const taskData = taskDocSnap.data();
                const rewardAmount = taskData.rewardPg || 0;
                
                if (rewardAmount <= 0) throw new Error("Task has no reward.");

                await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const taskRef = doc(db, 'tasks', taskId);
                    const userDoc = await t.get(userRef);
                    const taskDoc = await t.get(taskRef);

                    if (!userDoc.exists() || !taskDoc.exists()) throw "USER_OR_TASK_NOT_FOUND";
                    if (userDoc.data().completedTasks?.includes(taskId)) throw "ALREADY_COMPLETED";
                    
                    const currentTaskData = taskDoc.data();
                    if ((currentTaskData.limit || 0) > 0 && (currentTaskData.completionCount || 0) >= currentTaskData.limit) throw "TASK_LIMIT_REACHED";
                    
                    t.update(userRef, { 
                        completedTasks: arrayUnion(taskId), 
                        dailyTasksCompletedCount: increment(1),
                        unclaimedTaskPg: increment(rewardAmount) 
                    });
                    t.update(taskRef, { completionCount: increment(1) });
                });

                showSuccessModal("Task Verified!", `Reward of ${rewardAmount.toFixed(3)} PG added to your Task Loot Box.`);
                
                if (taskCard) taskCard.remove();
                await fetchAndUpdateCurrentUser();
                updateTaskClaimUI();

            } catch (error) {
                const errorMessages = { "ALREADY_COMPLETED": "You have already completed this task.", "TASK_LIMIT_REACHED": "This task has reached its completion limit."};
                alert(errorMessages[error] || 'Failed to claim reward. ' + error.message);
                if (error === "ALREADY_COMPLETED" || error === "TASK_LIMIT_REACHED") {
                     if (taskCard) taskCard.remove();
                } else {
                    button.disabled = false; button.textContent = 'Claim Reward';
                }
            }
        }
        
        function updateTaskClaimUI() {
            const claimBox = document.getElementById('task-claim-box');
            const unclaimedBalanceEl = document.getElementById('task-unclaimed-balance-box');
            const claimButton = document.getElementById('task-claim-button-box');

            const unclaimedBalance = currentUser?.unclaimedTaskPg || 0;

            unclaimedBalanceEl.textContent = `${unclaimedBalance.toFixed(3)} / ${TASK_CLAIM_THRESHOLD.toFixed(3)} PG`;

            if (unclaimedBalance > 0) {
                claimBox.classList.add('visible');
            } else {
                 claimBox.classList.remove('visible');
            }

            if (unclaimedBalance >= TASK_CLAIM_THRESHOLD) {
                claimButton.disabled = false;
                if (!claimBox.classList.contains('pulsate')) {
                    claimBox.classList.add('pulsate');
                }
            } else {
                claimButton.disabled = true;
                claimBox.classList.remove('pulsate');
            }
        }

        async function claimTaskRewards() {
            const claimButton = document.getElementById('task-claim-button-box');
            if (!currentUser || (currentUser.unclaimedTaskPg || 0) < TASK_CLAIM_THRESHOLD) return;

            claimButton.disabled = true;
            claimButton.textContent = 'Claiming...';
            
            const amountToClaim = Math.floor(currentUser.unclaimedTaskPg / TASK_CLAIM_THRESHOLD) * TASK_CLAIM_THRESHOLD;
            if (amountToClaim <= 0) {
                claimButton.textContent = 'Claim';
                updateTaskClaimUI();
                return;
            }

            try {
                await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await t.get(userRef);
                    if (!userDoc.exists()) throw new Error("User not found");

                    const currentUnclaimed = userDoc.data().unclaimedTaskPg || 0;
                    if (currentUnclaimed < amountToClaim) throw new Error("Inconsistent task balance");
                    
                    t.update(userRef, {
                        pgCoin: increment(amountToClaim),
                        lifetimePgCoinEarned: increment(amountToClaim),
                        unclaimedTaskPg: increment(-amountToClaim)
                    });
                });
                
                await grantCommission(amountToClaim);

                await addDoc(collection(db, 'transactions'), {
                    userId: currentUser.id, type: 'Task Reward',
                    details: 'Claimed from Task Loot Box',
                    pgAmount: amountToClaim, status: 'Completed', createdAt: serverTimestamp()
                });

                showSuccessModal("Reward Claimed!", `You claimed ${amountToClaim.toFixed(3)} PG from completed tasks.`);
                await fetchAndUpdateCurrentUser();
                updateTaskClaimUI();

            } catch(error) {
                console.error("Error claiming task rewards:", error);
                alert("Failed to claim task rewards. Please try again.");
            } finally {
                claimButton.textContent = 'Claim';
                updateTaskClaimUI();
            }
        }
        document.getElementById('task-claim-button-box').addEventListener('click', claimTaskRewards);

        // --- NEW DAILY REWARDS LOGIC ---

        function updateDailyClaimUI() {
            const claimBox = document.getElementById('daily-claim-box');
            const unclaimedBalanceEl = document.getElementById('daily-unclaimed-balance-box');
            const claimButton = document.getElementById('daily-claim-button-box');
            const unclaimedBalance = currentUser?.unclaimedDailyPg || 0;

            unclaimedBalanceEl.textContent = `${unclaimedBalance.toFixed(3)} / ${DAILY_CLAIM_THRESHOLD.toFixed(3)} PG`;

            if (unclaimedBalance > 0) {
                claimBox.classList.add('visible');
            } else {
                claimBox.classList.remove('visible');
            }

            if (unclaimedBalance >= DAILY_CLAIM_THRESHOLD) {
                claimButton.disabled = false;
                if (!claimBox.classList.contains('pulsate')) claimBox.classList.add('pulsate');
            } else {
                claimButton.disabled = true;
                claimBox.classList.remove('pulsate');
            }
        }

        async function claimDailyRewards() {
            const claimButton = document.getElementById('daily-claim-button-box');
            if (!currentUser || (currentUser.unclaimedDailyPg || 0) < DAILY_CLAIM_THRESHOLD) return;

            claimButton.disabled = true;
            claimButton.textContent = 'Claiming...';

            const amountToClaim = Math.floor(currentUser.unclaimedDailyPg / DAILY_CLAIM_THRESHOLD) * DAILY_CLAIM_THRESHOLD;
            if (amountToClaim <= 0) {
                claimButton.textContent = 'Claim';
                updateDailyClaimUI();
                return;
            }

            try {
                 await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await t.get(userRef);
                    if (!userDoc.exists()) throw new Error("User not found");

                    const currentUnclaimed = userDoc.data().unclaimedDailyPg || 0;
                    if (currentUnclaimed < amountToClaim) throw new Error("Inconsistent daily balance");

                    t.update(userRef, {
                        pgCoin: increment(amountToClaim),
                        lifetimePgCoinEarned: increment(amountToClaim),
                        unclaimedDailyPg: increment(-amountToClaim)
                    });
                });
                
                await grantCommission(amountToClaim);

                await addDoc(collection(db, 'transactions'), {
                    userId: currentUser.id, type: 'Daily Reward',
                    details: 'Claimed from Daily Loot Box',
                    pgAmount: amountToClaim, status: 'Completed', createdAt: serverTimestamp()
                });

                showSuccessModal("Reward Claimed!", `You claimed ${amountToClaim.toFixed(3)} PG from daily tasks.`);
                await fetchAndUpdateCurrentUser();
                updateDailyClaimUI();
            } catch (error) {
                console.error("Error claiming daily rewards:", error);
                alert("Failed to claim daily rewards. Please try again.");
            } finally {
                claimButton.textContent = 'Claim';
                updateDailyClaimUI();
            }
        }
        document.getElementById('daily-claim-button-box').addEventListener('click', claimDailyRewards);


        function renderDailyTasks() {
            const container = document.getElementById('daily-tasks-grid');
            if (!currentUser) { container.innerHTML = ''; return; }
            
            const dailyReferralCount = currentUser.dailyReferralCount || 0;
            const claimedDaily = currentUser.claimedDailyRewards || [];

            const tasks = [
                // Referral Tasks
                { id: 'ref_1', title: 'Refer 1 Friend Today', required: 1, reward: 0.050, condition: dailyReferralCount >= 1 },
                { id: 'ref_3', title: 'Refer 3 Friends Today', required: 3, reward: 0.200, condition: dailyReferralCount >= 3 },
                { id: 'ref_5', title: 'Refer 5 Friends Today', required: 5, reward: 0.600, condition: dailyReferralCount >= 5 },
                { id: 'ref_10', title: 'Refer 10 Friends Today', required: 10, reward: 1.000, condition: dailyReferralCount >= 10 },
                { id: 'ref_20', title: 'Refer 20+ Friends Today', required: 20, reward: 2.500, condition: dailyReferralCount >= 20 },
                // Telegram Tasks
                { id: 'tg_1', type: 'visit', title: 'Visit Official Channel', reward: 0.01, url: 'https://t.me/tech_and_touch', completed: currentUser.dailyTelegramVisit1Completed, visitTime: 5 },
                { id: 'tg_2', type: 'visit', title: 'Visit Payment Channel', reward: 0.01, url: 'https://t.me/newtube12', completed: currentUser.dailyTelegramVisit2Completed, visitTime: 5 },
                // Website Visit Tasks
                { id: 'web_1', type: 'visit', title: 'Visit Website 1', reward: 0.03, url: 'https://suggestbingo.com/qr4ys636p?key=0098a30fe6a07c76104029fc8045e1bd', completed: currentUser.dailyBrowseVisit1Completed, visitTime: 15 },
                { id: 'web_2', type: 'visit', title: 'Visit Website 2', reward: 0.03, url: 'https://suggestbingo.com/qr4ys636p?key=0098a30fe6a07c76104029fc8045e1bd', completed: currentUser.dailyBrowseVisit2Completed, visitTime: 15 },
            ];

            container.innerHTML = tasks.map(task => {
                let buttonHtml = '';
                const isClaimed = claimedDaily.includes(task.id);
                if (isClaimed) {
                    buttonHtml = `<button class="daily-task-button" disabled>Claimed</button>`;
                } else if (task.type === 'visit') {
                    if (task.completed) {
                         buttonHtml = `<button class="daily-task-button" data-task-id="${task.id}" data-reward="${task.reward}" data-action="claim-visit">Claim</button>`;
                    } else {
                        buttonHtml = `<button class="daily-task-button" data-task-id="${task.id}" data-url="${task.url}" data-time="${task.visitTime}" data-action="visit">Go</button>`;
                    }
                } else { // Referral task
                    if (task.condition) {
                         buttonHtml = `<button class="daily-task-button" data-task-id="${task.id}" data-reward="${task.reward}" data-action="claim-ref">Claim</button>`;
                    } else {
                        buttonHtml = `<button class="daily-task-button" disabled>Invite</button>`;
                    }
                }
                
                const progressText = task.required ? `<p>Progress: ${dailyReferralCount} / ${task.required}</p>` : `<p>Visit to claim reward.</p>`;

                return `
                    <div class="daily-reward-card">
                        <div class="daily-reward-card-info">
                            <h4>${task.title}</h4>
                            ${progressText}
                            <p>Reward: <span class="task-reward-pg">${task.reward.toFixed(3)} PG</span></p>
                        </div>
                        ${buttonHtml}
                    </div>`;
            }).join('');
        }

        document.getElementById('daily-tasks-grid').addEventListener('click', async (e) => {
            const button = e.target.closest('.daily-task-button');
            if (!button || button.disabled) return;

            const { taskId, reward, action, url, time } = button.dataset;
            const userRef = doc(db, 'users', currentUser.id);

            if (action === 'claim-ref' || action === 'claim-visit') {
                button.disabled = true; button.textContent = "Claiming...";
                try {
                    await updateDoc(userRef, {
                        unclaimedDailyPg: increment(parseFloat(reward)),
                        claimedDailyRewards: arrayUnion(taskId)
                    });
                    showSuccessModal("Reward Added!", `+${reward} PG added to your Daily Loot Box.`);
                    await fetchAndUpdateCurrentUser();
                    renderDailyTasks();
                    updateDailyClaimUI();
                } catch (err) {
                    alert('Failed to claim reward.');
                    button.disabled = false; button.textContent = "Claim";
                }
            } else if (action === 'visit') {
                tg.openLink(url);
                button.disabled = true;
                let countdown = parseInt(time, 10);
                button.textContent = `Wait ${countdown}s`;
                const timer = setInterval(async () => {
                    countdown--;
                    button.textContent = `Wait ${countdown}s`;
                    if (countdown <= 0) {
                        clearInterval(timer);
                        button.textContent = `Processing...`;
                        const updateField = {
                            'tg_1': 'dailyTelegramVisit1Completed', 'tg_2': 'dailyTelegramVisit2Completed',
                            'web_1': 'dailyBrowseVisit1Completed', 'web_2': 'dailyBrowseVisit2Completed'
                        }[taskId];
                        if (updateField) {
                            await updateDoc(userRef, { [updateField]: true });
                            await fetchAndUpdateCurrentUser();
                            renderDailyTasks();
                        }
                    }
                }, 1000);
            }
        });

        // --- END DAILY REWARDS LOGIC ---


        function renderTaskPackages() {
            const grid = document.getElementById('ad-package-grid');
            grid.innerHTML = '';
            adPackages.forEach(pkg => {
                const card = document.createElement('div');
                card.className = 'ad-package-card';
                card.dataset.packageId = pkg.id;
                card.innerHTML = `<h4>${pkg.tasks} Tasks</h4><p>${pkg.price.toFixed(2)} USDT</p>`;
                grid.appendChild(card);
            });
        }
        
        document.getElementById('ad-package-grid').addEventListener('click', (e) => {
            const card = e.target.closest('.ad-package-card');
            if (!card) return;
            document.querySelectorAll('#ad-package-grid .ad-package-card').forEach(c => c.classList.remove('selected'));
            card.classList.add('selected');
            const packageId = parseInt(card.dataset.packageId, 10);
            selectedAdPackage = adPackages.find(p => p.id === packageId);
        });

        async function renderMyAds() {
            const container = document.getElementById('my-ads-list');
            container.innerHTML = '<div class="loader"></div>';
            if (!currentUser) return;
            try {
                const q = query(collection(db, 'tasks'), where("creatorId", "==", currentUser.id), orderBy("createdAt", "desc"));
                const snapshot = await getDocs(q);
                if (snapshot.empty) { container.innerHTML = '<p style="text-align:center;">You have not created any task advertisements yet.</p>'; return; }
                container.innerHTML = '';
                snapshot.forEach(docSnap => {
                    const ad = docSnap.data();
                    const isCompleted = (ad.completionCount || 0) >= (ad.limit || 0);
                    const card = document.createElement('div');
                    card.className = 'user-ad-item';
                    card.innerHTML = `
                        <h4>${ad.title}</h4>
                        <p class="info-text" style="word-break: break-all;">URL: ${ad.url}</p>
                        <p class="progress-text">Progress: ${(ad.completionCount || 0)} / ${ad.limit}</p>
                        <p class="status-text ${isCompleted ? 'completed' : 'active'}">Status: ${isCompleted ? 'Completed ✅' : 'Active'}</p>
                    `;
                    container.appendChild(card);
                });
            } catch (error) {
                console.error("Error fetching my ads:", error);
                container.innerHTML = '<p style="text-align:center; color: red;">Could not load your ads.</p>';
            }
        }

        document.getElementById('create-task-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const submitBtn = e.target.querySelector('button[type="submit"]');
            if (!selectedAdPackage) { alert('Please select a task package.'); return; }
            const title = document.getElementById('task-title-input').value.trim();
            const url = document.getElementById('task-url-input').value.trim();
            if (!title || !url) { alert('Please provide both a title and a URL for your task.'); return; }
            if ((currentUser.usdtBalance || 0) < selectedAdPackage.price) { alert('Insufficient USDT balance to purchase this package.'); return; }
            
            submitBtn.disabled = true; submitBtn.textContent = 'Processing...';
            try {
                await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await t.get(userRef);
                    if (!userDoc.exists() || (userDoc.data().usdtBalance || 0) < selectedAdPackage.price) throw new Error("Insufficient balance.");
                    t.update(userRef, { usdtBalance: increment(-selectedAdPackage.price) });
                    const newTaskData = { title, url, rewardPg: USER_CREATED_TASK_REWARD_PG, limit: selectedAdPackage.tasks, completionCount: 0, creatorId: currentUser.id, isApproved: true, createdAt: serverTimestamp() };
                    t.set(doc(collection(db, 'tasks')), newTaskData);
                });
                showSuccessModal("Task Created!", "Your new task is now live for other users to complete.");
                e.target.reset();
                document.querySelectorAll('#ad-package-grid .ad-package-card.selected').forEach(c => c.classList.remove('selected'));
                selectedAdPackage = null;
                document.getElementById('createTaskModalOverlay').classList.remove('show');
                await fetchAndUpdateCurrentUser();
                await renderMyAds();
            } catch (error) {
                console.error("Error creating task:", error);
                alert(`Failed to create task: ${error.message}`);
            } finally {
                submitBtn.disabled = false; submitBtn.textContent = 'Create Task';
            }
        });

        function showSuccessModal(title, message) {
            const modal = document.getElementById('successModalOverlay');
            document.getElementById('successModalTitle').textContent = title;
            document.getElementById('successModalMessage').innerHTML = message;
            modal.classList.add('show');
            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
            setTimeout(() => { modal.classList.remove('show'); }, 4000);
        }
        
        function renderPgWithdrawalUI() {
            if (!currentUser) return;
            const balance = currentUser.pgCoin || 0;
            document.getElementById('withdrawPgCoinBalance').textContent = balance.toFixed(3);
            const grid = document.getElementById('withdraw-package-grid');
            grid.innerHTML = '';
            pgWithdrawalPackages.forEach(amount => {
                const card = document.createElement('button');
                card.className = 'withdraw-package-card';
                card.dataset.amount = amount;
                if (balance < amount) {
                    card.classList.add('disabled');
                    card.disabled = true;
                }
                card.innerHTML = `<h4>${amount} PG</h4>`;
                grid.appendChild(card);
            });
        }
        
        document.getElementById('withdraw-package-grid').addEventListener('click', (e) => {
            const card = e.target.closest('.withdraw-package-card');
            if (!card || card.disabled) return;
            
            const amount = parseFloat(card.dataset.amount);
            const method = document.getElementById('pgWithdrawalMethod').value;
            const details = document.getElementById('pgAccountDetails').value.trim();

            if (!details) {
                alert('Please enter your account details first.');
                document.getElementById('pgAccountDetails').focus();
                return;
            }
            if ((currentUser.referralsSinceLastWithdrawal || 0) < 2) {
                alert(`Withdrawal Failed: You need at least 2 new referrals to make a withdrawal. You currently have ${currentUser.referralsSinceLastWithdrawal || 0}.`);
                return;
            }

            showWithdrawalConfirmationModal(amount, method, details);
        });

        function showWithdrawalConfirmationModal(amount, method, details) {
            const modal = document.getElementById('withdrawConfirmModalOverlay');
            document.getElementById('withdrawConfirmText').textContent = `Are you sure you want to withdraw ${amount} PG to your ${method} account (${details})?`;
            
            const cancelBtn = document.getElementById('withdrawConfirmCancelBtn');
            const confirmBtn = document.getElementById('withdrawConfirmSubmitBtn');

            const close = () => modal.classList.remove('show');

            const handleConfirm = async () => {
                close();
                await processPgWithdrawal(amount, method, details);
            };

            cancelBtn.onclick = close;
            confirmBtn.onclick = handleConfirm;

            modal.classList.add('show');
        }

        async function processPgWithdrawal(amount, method, details) {
            if (isSubmittingWithdrawal) return;
            isSubmittingWithdrawal = true;

            try {
                if (isNaN(amount) || amount <= 0) throw new Error(`Invalid withdrawal amount.`);
                if (amount > (currentUser.pgCoin || 0)) throw new Error(`Insufficient PG Coin balance.`);
                if ((currentUser.referralsSinceLastWithdrawal || 0) < 2) {
                    throw new Error(`You need at least 2 new referrals to make a withdrawal. You currently have ${currentUser.referralsSinceLastWithdrawal || 0}.`);
                }

                await runTransaction(db, async (t) => {
                    const userRef = doc(db, 'users', currentUser.id);
                    const userDoc = await t.get(userRef);
                    if (!userDoc.exists()) throw new Error(`User not found.`);
                    const userData = userDoc.data();
                    if ((userData.pgCoin || 0) < amount) throw new Error(`Insufficient balance.`);
                    if ((userData.referralsSinceLastWithdrawal || 0) < 2) throw new Error(`Referral requirement not met.`);
                    
                    const requestData = { 
                        userId: currentUser.id, 
                        telegramUsername: currentUser.telegramUsername, 
                        method, 
                        details, 
                        status: 'pending', 
                        createdAt: serverTimestamp(), 
                        withdrawType: 'pg', 
                        fee: 0,
                        totalDeducted: amount,
                        pgAmount: amount 
                    };
                    
                    t.set(doc(collection(db, 'withdrawals')), requestData);
                    t.update(userRef, { 
                        pgCoin: increment(-amount), 
                        withdrawalCount: increment(1),
                        referralsSinceLastWithdrawal: 0 // Reset after successful request
                    });
                });

                await fetchAndUpdateCurrentUser();
                document.getElementById('pgWithdrawalDetailsForm').reset();
                showSuccessModal("Request Sent!", `Your withdrawal request for ${amount} PG is pending. Check status in the History tab.`);
            } catch (error) { 
                alert(`Error: ${error.message}`); 
            } finally { 
                isSubmittingWithdrawal = false;
                renderPgWithdrawalUI(); 
            }
        }
        
        async function showCombinedHistory() {
            const historyContainer = document.getElementById('combined-history-list');
            const modal = document.getElementById('historyModalOverlay');
            modal.classList.add('show');
            historyContainer.innerHTML = '<div class="loader"></div>';
            try {
                const withdrawalsQuery = query(collection(db, "withdrawals"), where("userId", "==", currentUser.id), orderBy("createdAt", "desc"), limit(25));
                const transactionsQuery = query(collection(db, "transactions"), where("userId", "==", currentUser.id), orderBy("createdAt", "desc"), limit(25));
                
                const [withdrawalsSnap, transactionsSnap] = await Promise.all([
                    getDocs(withdrawalsQuery), getDocs(transactionsQuery)
                ]);

                let combinedList = [];

                withdrawalsSnap.forEach(doc => {
                    const data = doc.data();
                    combinedList.push({
                        ...data, type: 'Withdrawal', timestamp: data.createdAt
                    });
                });
                transactionsSnap.forEach(doc => {
                    const data = doc.data();
                    combinedList.push({
                        ...data, timestamp: data.createdAt
                    });
                });

                combinedList.sort((a, b) => (b.timestamp?.toMillis() || 0) - (a.timestamp?.toMillis() || 0));

                if (combinedList.length === 0) {
                    historyContainer.innerHTML = '<p style="text-align:center;">No history found.</p>';
                    return;
                }
                
                historyContainer.innerHTML = '';
                let lastDate = null;

                combinedList.forEach(data => {
                    if (!data.timestamp) return;
                    
                    const date = data.timestamp.toDate();
                    const formattedDate = date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
                    const formattedTime = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

                    if (formattedDate !== lastDate) {
                        const dateHeader = document.createElement('div');
                        dateHeader.className = 'history-date-header';
                        dateHeader.textContent = formattedDate;
                        historyContainer.appendChild(dateHeader);
                        lastDate = formattedDate;
                    }

                    let title = data.type;
                    let amountStr = '';
                    let amountClass = '';
                    let status = data.status || 'Completed';
                    let statusClass = `status-${status.toLowerCase()}`;
                    
                    if (title === 'Withdrawal') {
                        amountStr = `- ${(data.totalDeducted || 0).toFixed(data.withdrawType === 'usdt' ? 4 : 3)} ${data.withdrawType.toUpperCase()}`;
                        amountClass = 'amount-negative';
                    } else if (data.pgAmount) {
                        amountStr = `+ ${data.pgAmount.toFixed(3)} PG`;
                        amountClass = 'amount-positive';
                    } else if (data.usdAmount) {
                        amountStr = `+ ${data.usdAmount.toFixed(4)} USDT`;
                        amountClass = 'amount-positive';
                    }

                    const item = document.createElement('div');
                    item.className = 'history-item';
                    item.innerHTML = `
                        <div class="history-item-left">
                            <strong>${title}</strong>
                            <small>${data.details || formattedTime}</small>
                        </div>
                        <div class="history-item-right">
                            <strong class="${amountClass}">${amountStr}</strong>
                            <small class="${statusClass}">${status}</small>
                        </div>`;
                    historyContainer.appendChild(item);
                });

            } catch (error) {
                console.error("Error fetching combined history:", error);
                historyContainer.innerHTML = '<p style="color:red;text-align:center;">Error loading history.</p>';
            }
        }
        
        function renderReferralStats() {
            if (!currentUser) return;
            document.getElementById('referral-userid').textContent = currentUser.id;
            document.getElementById('referral-lifetime-referrals').textContent = currentUser.referralCount || 0;
            document.getElementById('referral-usdt-balance').textContent = (currentUser.usdtBalance || 0).toFixed(4);
            document.getElementById('referral-commission-pg').textContent = (currentUser.lifetimeCommissionPg || 0).toFixed(3);
        }
        
        const showMonetagAd = () => new Promise((res, rej) => {
            if (typeof show_9442539 === 'function') {
                show_9442539().then(res).catch(rej);
            } else { rej('Monetag SDK missing'); }
        });
        const showGigaPubAd = () => new Promise((res, rej) => {
             if(typeof window.showGiga === 'function') {
                window.showGiga("main").then(res).catch(rej);
             } else { rej('GigaPub SDK missing'); }
        });
        const showAdextraAd = () => new Promise((res, rej) => {
            if(typeof p_adextra === 'function') {
                p_adextra({ onSuccess: res, onError: (e) => rej(new Error("Adextra ad failed: " + e)) });
            } else { rej('Adextra SDK missing'); }
        });

        async function showRandomAdForTask() {
            const adProviders = [showMonetagAd, showGigaPubAd, showAdextraAd];
            const randomAdProvider = adProviders[Math.floor(Math.random() * adProviders.length)];
            try { await randomAdProvider(); } 
            catch(err) { console.warn("An ad provider failed, trying another one...", err);
                const otherProviders = adProviders.filter(p => p !== randomAdProvider);
                if (otherProviders.length > 0) {
                    const fallbackProvider = otherProviders[Math.floor(Math.random() * otherProviders.length)];
                    try { await fallbackProvider(); } catch(fallbackErr) { console.error("Fallback ad provider also failed:", fallbackErr); throw fallbackErr; }
                } else { throw err; }
            }
        }
        
        document.getElementById('history-btn').addEventListener('click', showCombinedHistory);
        document.getElementById('closeHistoryBtn').addEventListener('click', () => document.getElementById('historyModalOverlay').classList.remove('show'));
        document.getElementById('show-create-task-btn').addEventListener('click', () => document.getElementById('createTaskModalOverlay').classList.add('show'));
        document.getElementById('closeTaskModalBtn').addEventListener('click', () => document.getElementById('createTaskModalOverlay').classList.remove('show'));

        let adsterraScriptLoaded = false;
        function loadAdsterraScript() {
            if (adsterraScriptLoaded) return;
            const container = document.getElementById('adsterra-social-bar-container');
            const script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = '//suggestbingo.com/55/02/5c/55025c7818ef24365e262ed0d416a7a0.js';
            container.appendChild(script);
            adsterraScriptLoaded = true;
        }

        document.querySelectorAll('.bottom-nav-item, .header-icon-btn').forEach(link => {
            if(!link.dataset.tabTarget) return;
            link.addEventListener('click', async (e) => {
                e.preventDefault();
                const targetId = link.dataset.tabTarget;
                if (!currentUser || document.querySelector(targetId)?.classList.contains('active')) return;
                
                stopAllSectionActivity();
                document.querySelectorAll('.bottom-nav-item.active, .header-icon-btn.active, .content-section.active').forEach(el => el.classList.remove('active'));
                
                document.querySelectorAll(`[data-tab-target="${targetId}"]`).forEach(l => l.classList.add('active'));
                document.querySelector(targetId).classList.add('active');

                switch(targetId) {
                    case '#profile-content': 
                        renderReferralStats(); 
                        renderDailyTasks();
                        updateDailyClaimUI();
                        break;
                    case '#ads-content': setupAdsToEarn(); break;
                    case '#video-content': 
                        await fetchContent();
                        updateVideoClaimUI();
                        loadAdsterraScript();
                        document.getElementById('adsterra-social-bar-container').style.display = 'block';
                        break;
                    case '#task-content': 
                        renderTaskPackages();
                        await renderMyAds(); 
                        await fetchAndRenderTasks('task-list', 50);
                        updateTaskClaimUI();
                        break;
                    case '#withdraw-content': 
                        renderPgWithdrawalUI();
                        break;
                }
            });
        });
        
        function setupUserIdDisplay(userId) {
            const userIdContainer = document.getElementById('header-user-id');
            userIdContainer.querySelector('span').textContent = `ID: ${userId}`;
            userIdContainer.addEventListener('click', () => {
                navigator.clipboard.writeText(userId).then(() => {
                    if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                    showSuccessModal("Copied!", `User ID ${userId} copied to clipboard.`);
                });
            });
        }
        
        async function showDailyNoticePopup() {
            const lastShown = currentUser.lastNoticeShown?.toDate();
            const now = new Date();
            if (lastShown && (now.getTime() - lastShown.getTime()) < 24 * 60 * 60 * 1000) {
                return;
            }
            
            const overlay = document.getElementById('noticeModalOverlay');
            overlay.classList.add('show');
            document.getElementById('noticeConfirmBtn').addEventListener('click', async () => {
                overlay.classList.remove('show');
                await updateDoc(doc(db, 'users', currentUser.id), { lastNoticeShown: serverTimestamp() });
            }, { once: true });
        }


        async function main() {
            try {
                if (!tg.initDataUnsafe?.user) { document.body.innerHTML = `<div class="card"><h3>Error</h3><p>This app can only be launched from Telegram.</p></div>`; return; }
                tg.ready(); tg.expand();
                
                const initStatus = await initializeUser(tg.initDataUnsafe.user, tg.initDataUnsafe.start_param);
                if (!initStatus) return;

                setupUserIdDisplay(currentUser.id);

                document.getElementById('referral-userid').addEventListener('click', () => {
                    if (currentUser?.id) navigator.clipboard.writeText(currentUser.id).then(() => {
                        if (tg?.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                        showSuccessModal("Copied!", `User ID ${currentUser.id} copied to clipboard.`);
                    });
                });
                
                showDailyNoticePopup();
                renderReferralStats();
                renderDailyTasks();
                updateDailyClaimUI();

            } catch (error) {
                console.error("Initialization failed:", error);
                document.body.innerHTML = `<div class="card"><h3>Application Error</h3><p>Could not initialize. Please restart.</p><p style="font-size: 0.8em; color: #888;">Error: ${error.message}</p></div>`;
            }
        }
        main();
    </script>

</body>
</html>
```